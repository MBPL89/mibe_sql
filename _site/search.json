[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "MIBE SQL Corner",
    "section": "",
    "text": "Welcome to the MIBE SQL Corner! This page is dedicated to all the key concepts, notes, and resources you need for mastering SQL in the Coding and Data Management course. Whether you‚Äôre just starting or refining your skills, you‚Äôll find everything you need to excel in SQL here. Let‚Äôs dive in and sharpen those coding skills!\nYou will also use this website to query databases. It features interactive fields, where you can type and edit your SQL queries.\n\n\n\n\n\n\n\n  \n  \n    ¬© 2025. All Rights Reserved.\n  \n  \n\n  \n  \n    Enabled by Dr. Marcin Bartosiak"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "1-single-entity.html#the-relational-model",
    "href": "1-single-entity.html#the-relational-model",
    "title": "Introduction to SQL. Single entity",
    "section": "",
    "text": "The relational model is a way of organizing data into tables (called relations).\nThe Relational Model represents data and their relationships through a collection of tables. Each table also known as a relation consists of rows and columns. Every column has a unique name and corresponds to a specific attribute, while each row contains a set of related data values representing a real-world entity or relationship.\nThe relational model represents how data is stored in Relational Databases. A relational database consists of a collection of tables each of which is assigned a unique name.\n\n\n\nRelational Model\n\n\nRelation or table: * Matrix of intersecting tuples and attributes + Tuples: Rows + Attributes: Columns"
  },
  {
    "objectID": "1-single-entity.html#single-entity",
    "href": "1-single-entity.html#single-entity",
    "title": "Introduction to SQL. Single entity",
    "section": "",
    "text": "An entity is some thing in the environment. It can be a physical entity (e.g., student) or an abstraction (e.g., marriage). You can think of an entity as a class of objects (or phenomena). An instance is a particular occurrence of an entity.\n\n\n\n\n\nNo worries! It will get easier with the examples below üòÖ\n\n\n\nEntity: ‚ÄúCar‚Äù is an entity because it represents a general category of objects that share common characteristics, such as having wheels, an engine, and the ability to transport people.\n\nInstance: A specific car, like a red 2015 Volkswagen Beetle with license plate ABC123, is an instance of the ‚ÄúCar‚Äù entity. It is a particular example with unique attributes.\n\n\n\n\n\n\n\n\n\n\nEntity: ‚ÄúTree‚Äù is an entity because it represents a general type of object that has roots, a trunk, and leaves.\n\nInstance: A specific tree in a forest, such as the 50-year-old oak tree standing near the river in Amazon Rainforest, is an instance of the ‚ÄúTree‚Äù entity. It is a unique example of the general concept.\n\n\n\n\n\n\n\n\n\nFirst, we need to draw an entity.\nRemember, an entity is:\n\nSome thing in the environment\nA physical entity (e.g., student) or an abstraction (e.g., marriage)\nAn entity is a class (or entity set)\nAn instance is a particular occurrence of an entity\n\n\n\n\n\n\n\nNote\n\n\n\nAn entity is represented by a rectangle in modelling notation\n\n\n\n\n\n\n\n\n\nAn entity\n\n\nSecond, let‚Äôs think about attributes.\nAn attribute is a discrete data element that describes an entity.\n\nAttributes must be conceptually unique\n\nHomonym: Same name is used to label different attributes\nSynonym: Different names are used to describe the same attribute\n\n\n\n\n\n\n\n\nNote\n\n\n\nAttribute names must be unique within a data model\nAttribute names should be meaningful\n\n\n\n\n\n\n\n\n\nAttributes\n\n\nThere is one more step before we have our model ready. We need to add identifiers.\nEvery instance of an entity must be uniquely identified.\nAn identifier can be an attribute or collection of attributes.\nAn identifier can be created if there is no obvious attribute (surrogate).\n\n\n\n\n\n\nNote\n\n\n\nA leading asterisk denotes an identifier in our entity.\n\n\n\n\n\n\n\n\n\nIdentifier (*)\n\n\nThat‚Äôs it! You‚Äôve created your first database model. It‚Äôs a simple one‚Äîjust a single table. But soon, we‚Äôll be designing much more complex databases, all built on these few basic steps."
  },
  {
    "objectID": "1-single-entity.html#exercise",
    "href": "1-single-entity.html#exercise",
    "title": "Introduction to SQL. Single entity",
    "section": "",
    "text": "Create a data model for recording details of the herd of cows that you manage"
  },
  {
    "objectID": "1-single-entity.html#querying-a-table",
    "href": "1-single-entity.html#querying-a-table",
    "title": "Introduction to SQL. Single entity",
    "section": "Querying a Table",
    "text": "Querying a Table\nIn SQL, the simplest way to retrieve data is by using SELECT * FROM tableName;. This command asks the database to return everything in the table. Think of it as saying, ‚ÄúHey, server, show me (SELECT) all the data (*) in this table (FROM)!‚Äù\nOf course, tableName is just a placeholder. We will have to replace it with the real name. In our case, the table is called brand.\nTry it yourself with our brand table:\n\nSELECT * FROM tableName;\n\n\n\n\n\n\n\nNote\n\n\n\nHave you noticed the small detail at the end of line? Every query has to end with ;. It tells the server that your query ends here. Everything after this sign is a new code. This will be important when we run more than one query at a time."
  },
  {
    "objectID": "1-single-entity.html#projection-choosing-columns",
    "href": "1-single-entity.html#projection-choosing-columns",
    "title": "Introduction to SQL. Single entity",
    "section": "Projection: Choosing Columns",
    "text": "Projection: Choosing Columns\nSometimes, you don‚Äôt need all the data‚Äîjust specific columns.\n\n\n\n\n\nYou can request only what you need by listing column names:\n\nSELECT brandName, brandChain FROM brand; \n\nThis is like asking, ‚ÄúTell me just the brand name and chain, please.‚Äù"
  },
  {
    "objectID": "1-single-entity.html#restriction-choosing-rows",
    "href": "1-single-entity.html#restriction-choosing-rows",
    "title": "Introduction to SQL. Single entity",
    "section": "Restriction: Choosing Rows",
    "text": "Restriction: Choosing Rows\nIf you only want certain rows, use WHERE to filter results.\n\n\n\n\n\nTry yourself and report all brands owned by Hilton Worldwide.\n\nSELECT * FROM brand \n  WHERE ... ;\n\nThis is like telling the server, ‚ÄúOnly show me brands owned by Hilton.‚Äù\nYou can choose any other lodging chain instead of ‚ÄòHilton Worldwide‚Äô. For example, try with ‚ÄòAccor‚Äô and see how the results change.\n\n\n\n\n\n\nWarning\n\n\n\nHilton or Accor are values, not attributes. Unlike column names or table name, you always have to wrap text values with quotation marks ('...' or \"...\").\n\n\n\n\n\n\n\n\nTip\n\n\n\nFollowing the same logic, you can exclude a value from the results. You have to replace = with != or &lt;&gt; (they both mean the same thing).\n\n\nTry yourself and report all brands but Hilton Worldwide. Edit the query to try it with &lt;&gt; too.\n\nSELECT * FROM brand \n  WHERE brandChain != 'Hilton Worldwide';"
  },
  {
    "objectID": "1-single-entity.html#projection-and-restriction-together",
    "href": "1-single-entity.html#projection-and-restriction-together",
    "title": "Introduction to SQL. Single entity",
    "section": "Projection and Restriction Together",
    "text": "Projection and Restriction Together\nCombining both techniques, you can select specific columns and filter rows. List the brand name and segment of all brands owned by Hilton Worldwide:\n\nSELECT ... FROM ... \n  WHERE ...;\n\nNow you‚Äôre asking, ‚ÄúShow me just the names and segments of Hilton brands.‚Äù"
  },
  {
    "objectID": "1-single-entity.html#primary-key-retrieval",
    "href": "1-single-entity.html#primary-key-retrieval",
    "title": "Introduction to SQL. Single entity",
    "section": "Primary Key Retrieval",
    "text": "Primary Key Retrieval\nA primary key uniquely identifies a row. If you query by it, you get at most one result:\n\nSELECT * FROM brand \n  WHERE brandID = 10;\n\nThis is like saying, ‚ÄúGive me all details about the brand with ID 10.‚Äù\nImportant Notice that numerical values do not have to be wrapped with quotation marks."
  },
  {
    "objectID": "1-single-entity.html#queries-without-primary-key",
    "href": "1-single-entity.html#queries-without-primary-key",
    "title": "Introduction to SQL. Single entity",
    "section": "Queries Without Primary Key",
    "text": "Queries Without Primary Key\nWithout a primary key, multiple rows can be returned:\n\nSELECT * FROM brand \n  WHERE brandChain = 'Accor';"
  },
  {
    "objectID": "1-single-entity.html#the-in-operator",
    "href": "1-single-entity.html#the-in-operator",
    "title": "Introduction to SQL. Single entity",
    "section": "The IN Operator",
    "text": "The IN Operator\nIf you want to filter by multiple values, IN operator will come handy:\n\nSELECT * FROM brand \n  WHERE brandSegment IN ('Luxury', 'Economy');\n\nThis is the equivalent of saying, ‚ÄúGive me brands that are either Luxury or Economy.‚Äù\nYou could get the same results by using WHERE with OR:\n\nSELECT * FROM brand \n    WHERE brandSegment = 'Luxury'\n        OR brandSegment = 'Economy';\n\nDo you see how much more efficient it is with IN?"
  },
  {
    "objectID": "1-single-entity.html#the-not-in-operator",
    "href": "1-single-entity.html#the-not-in-operator",
    "title": "Introduction to SQL. Single entity",
    "section": "The NOT IN Operator",
    "text": "The NOT IN Operator\nTo exclude more than one value, use NOT IN:\n\nSELECT * FROM brand \n  WHERE brandName NOT IN ('Sofitel', 'Thalassa', 'Curio', 'Conrad');\n\nThis means, ‚ÄúShow me everything except these brands.‚Äù"
  },
  {
    "objectID": "1-single-entity.html#ordering-columns",
    "href": "1-single-entity.html#ordering-columns",
    "title": "Introduction to SQL. Single entity",
    "section": "Ordering Columns",
    "text": "Ordering Columns\nThe order of selected columns in your query defines how results appear. This just structures the results the way you prefer.\nCompare these two queries\n\nSELECT brandName, brandSegment FROM brand WHERE brandChain = 'Accor';\n\n\nSELECT brandSegment, brandName FROM brand WHERE brandChain = 'Accor';"
  },
  {
    "objectID": "1-single-entity.html#ordering-rows",
    "href": "1-single-entity.html#ordering-rows",
    "title": "Introduction to SQL. Single entity",
    "section": "Ordering Rows",
    "text": "Ordering Rows\nIf you need to sort the results, you can use ORDER BY.\n\n\n\n\n\nList all brands with rooms smaller than 350 square feet with largest first:\n\nSELECT * FROM brand WHERE brandMinSqFt &lt; 350 ORDER BY brandMinSqFt DESC;\n\nThis means, ‚ÄúShow me brands with rooms under 350 sqft, biggest first, and if sizes match, sort alphabetically.‚Äù\n\n\n\n\n\n\nTip\n\n\n\nDESC means descending order (biggest first). If you need ascending order (smallest first), you can replace it with ASC or simply remove it (ascending order is default in SQL).\n\n\n\n\n\n\n\n\nNote\n\n\n\nHave you noticed that there are many brands with the same value? We can order results by two columns. If the results in the first column are identical, the second column will be used to sort them. Let‚Äôs add brandName to our ORDER BY clause.\n\n\nList all brands with rooms smaller than 350 square feet with largest first. Where areas are identical, list brands in alphabetical order.\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nNotice that our results are ordered by brandMinSqFt in descending order (DESC), and alphabetically by brandName (you can add ASC after brandName to get the same results).\n\n\n\n\n\n\n\n\nTip\n\n\n\nLast one more thing. Notice that we use &lt; in this query. WHERE condition can take all the comparison operators: =, !=, &lt;, &gt;, &lt;=, and &gt;=."
  },
  {
    "objectID": "1-single-entity.html#calculated-fields",
    "href": "1-single-entity.html#calculated-fields",
    "title": "Introduction to SQL. Single entity",
    "section": "Calculated Fields",
    "text": "Calculated Fields\nSQL allows calculations directly in queries. Let‚Äôs say we want to convert square feet to square meters in the results (m¬≤ = f¬≤ / 10.764)."
  },
  {
    "objectID": "1-single-entity.html#renaming-output-fields",
    "href": "1-single-entity.html#renaming-output-fields",
    "title": "Introduction to SQL. Single entity",
    "section": "Renaming Output Fields",
    "text": "Renaming Output Fields\nThe column name for our calculated field in the results above doesn‚Äôt look nice. To make results clearer, use AS to rename calculated fields (or any other column in your query).\nGet minimum room area in square meters for each brand. Rename the output\n\n\n\nNow the result column will be labeled brandSqMt instead of an anonymous calculation. This new name is called alias."
  },
  {
    "objectID": "1-single-entity.html",
    "href": "1-single-entity.html",
    "title": "Introduction to SQL. Single entity",
    "section": "",
    "text": "Database Model is the logical representation of the structure of the data.\n\n\n\nDatabase Model Example\n\n\nIn general, there are two types of database models:\n\nConceptual Data Model\n\nThe logical representation of the structure of the data (conceptual metadata)\nUsing a specific modelling notation (e.g., ER diagramming, crow-foot notation, UML)\n\n\n\n\n\n\n\n\n\n\nHand-drawn crowfoot model\n\n\n\n\n\n\n\nER diagram\n\n\n\n\n\n\nFigure¬†1\n\n\n\n\nImplementable Data Model\n\nProduced in specialized software\nReady to launch on a server\nConceptual design\nData dictionary\n\n\n\n\n\nImplementable Model\n\n\nModelling is Designing\nA database must model the real world\n\nTo model means:\n\nTo represent faithfully\nGiven the database design objectives\nWithin scope and under given constraints\n\n\nObjective: Storing and retrieving data about the real world\nData modelling is a design technique for capturing data reality\n\n\nThe relational model is a way of organizing data into tables (called relations).\nThe Relational Model represents data and their relationships through a collection of tables. Each table also known as a relation consists of rows and columns. Every column has a unique name and corresponds to a specific attribute, while each row contains a set of related data values representing a real-world entity or relationship.\nThe relational model represents how data is stored in Relational Databases. A relational database consists of a collection of tables each of which is assigned a unique name.\n\n\n\nRelational Model\n\n\nRelation or table: * Matrix of intersecting tuples and attributes + Tuples: Rows + Attributes: Columns\n\n\n\nAn entity is some thing in the environment. It can be a physical entity (e.g., student) or an abstraction (e.g., marriage). You can think of an entity as a class of objects (or phenomena). An instance is a particular occurrence of an entity.\n\n\n\n\n\nNo worries! It will get easier with the examples below üòÖ\n\n\n\nEntity: ‚ÄúCar‚Äù is an entity because it represents a general category of objects that share common characteristics, such as having wheels, an engine, and the ability to transport people.\n\nInstance: A specific car, like a red 2015 Volkswagen Beetle with license plate ABC123, is an instance of the ‚ÄúCar‚Äù entity. It is a particular example with unique attributes.\n\n\n\n\n\n\n\n\n\n\nEntity: ‚ÄúTree‚Äù is an entity because it represents a general type of object that has roots, a trunk, and leaves.\n\nInstance: A specific tree in a forest, such as the 50-year-old oak tree standing near the river in Amazon Rainforest, is an instance of the ‚ÄúTree‚Äù entity. It is a unique example of the general concept.\n\n\n\n\n\n\n\n\n\nFirst, we need to draw an entity.\nRemember, an entity is:\n\nSome thing in the environment\nA physical entity (e.g., student) or an abstraction (e.g., marriage)\nAn entity is a class (or entity set)\nAn instance is a particular occurrence of an entity\n\n\n\n\n\n\n\nNote\n\n\n\nAn entity is represented by a rectangle in modelling notation\n\n\n\n\n\n\n\n\n\nAn entity\n\n\nSecond, let‚Äôs think about attributes.\nAn attribute is a discrete data element that describes an entity.\n\nAttributes must be conceptually unique\n\nHomonym: Same name is used to label different attributes\nSynonym: Different names are used to describe the same attribute\n\n\n\n\n\n\n\n\nNote\n\n\n\nAttribute names must be unique within a data model\nAttribute names should be meaningful\n\n\n\n\n\n\n\n\n\nAttributes\n\n\nThere is one more step before we have our model ready. We need to add identifiers.\nEvery instance of an entity must be uniquely identified.\nAn identifier can be an attribute or collection of attributes.\nAn identifier can be created if there is no obvious attribute (surrogate).\n\n\n\n\n\n\nNote\n\n\n\nA leading asterisk denotes an identifier in our entity.\n\n\n\n\n\n\n\n\n\nIdentifier (*)\n\n\nThat‚Äôs it! You‚Äôve created your first database model. It‚Äôs a simple one‚Äîjust a single table. But soon, we‚Äôll be designing much more complex databases, all built on these few basic steps.\n\n\n\n\nCreate a data model for recording details of the herd of cows that you manage"
  },
  {
    "objectID": "Homework1.html",
    "href": "Homework1.html",
    "title": "Homework 1",
    "section": "",
    "text": "The following queries use the classicmodels schema. All queries use the products table.\n\n\n\n\n\n\n\nPrepare a list of products sorted by product name in descending order.\n\n\n\nList the product names and their quantity available from high to low?\n\n\n\nReport the MSRP for the products in ‚ÄúVintage Cars‚Äù category?\n\n\n\nReport the product(s) with the buy price of 48.81.\n\n\n\nReport those products with the price greater than 70.\n\n\n\nWhich products have product scale ratio 1:10 and 1:72?\n\n\n\nList the product names except the ones in the Planes and Ships category.\n\n\n\nReport the names of products excluding Motorcycles and Classic Cars.\n\n\n\nReport the products having MSRP greater than 110.\n\n\n\nList the product vendors in ascending alphabetical order.\n\n\n\n\n\n\n\n  \n  \n    ¬© 2025. All Rights Reserved.\n  \n  \n\n  \n  \n    Enabled by Dr. Marcin Bartosiak"
  },
  {
    "objectID": "Homework1.html#sql---homework-1",
    "href": "Homework1.html#sql---homework-1",
    "title": "Homework 1",
    "section": "",
    "text": "The following queries use the classicmodels schema. All queries use the products table.\n\n\n\n\n\n\n\nPrepare a list of products sorted by product name in descending order.\n\n\n\nList the product names and their quantity available from high to low?\n\n\n\nReport the MSRP for the products in ‚ÄúVintage Cars‚Äù category?\n\n\n\nReport the product(s) with the buy price of 48.81.\n\n\n\nReport those products with the price greater than 70.\n\n\n\nWhich products have product scale ratio 1:10 and 1:72?\n\n\n\nList the product names except the ones in the Planes and Ships category.\n\n\n\nReport the names of products excluding Motorcycles and Classic Cars.\n\n\n\nReport the products having MSRP greater than 110.\n\n\n\nList the product vendors in ascending alphabetical order.\n\n\n\n\n\n\n\n  \n  \n    ¬© 2025. All Rights Reserved.\n  \n  \n\n  \n  \n    Enabled by Dr. Marcin Bartosiak"
  },
  {
    "objectID": "scavenger_hunt.html",
    "href": "scavenger_hunt.html",
    "title": "Murder in SQLCity",
    "section": "",
    "text": "SELECT \n    name\nFROM \n    sqlite_schema\nWHERE \n    type ='table' AND \n    name NOT LIKE 'sqlite_%';"
  },
  {
    "objectID": "scavenger_hunt.html#test",
    "href": "scavenger_hunt.html#test",
    "title": "Murder in SQLCity",
    "section": "",
    "text": "SELECT \n    name\nFROM \n    sqlite_schema\nWHERE \n    type ='table' AND \n    name NOT LIKE 'sqlite_%';"
  },
  {
    "objectID": "Readings.html",
    "href": "Readings.html",
    "title": "Readings",
    "section": "",
    "text": "Richard Watson Data Management: Databases and Organizations 6th Edition Prospect Press\nAvailable in the Department‚Äôs library and at\nData Management, Databases, and Analytics\n\n\n\n\n\n\n\n\n\n\n\n\nCoronel C. and Morris S. Database Systems: Design, Implementation and Management\n12th Edition, Cengage Learning.\nAvailable in the Department‚Äôs library.\n\n\n\n\n\n\n\n\n\n  \n  \n    ¬© 2025. All Rights Reserved.\n  \n  \n\n  \n  \n    Enabled by Dr. Marcin Bartosiak"
  },
  {
    "objectID": "Readings.html#readings",
    "href": "Readings.html#readings",
    "title": "Readings",
    "section": "",
    "text": "Richard Watson Data Management: Databases and Organizations 6th Edition Prospect Press\nAvailable in the Department‚Äôs library and at\nData Management, Databases, and Analytics\n\n\n\n\n\n\n\n\n\n\n\n\nCoronel C. and Morris S. Database Systems: Design, Implementation and Management\n12th Edition, Cengage Learning.\nAvailable in the Department‚Äôs library.\n\n\n\n\n\n\n\n\n\n  \n  \n    ¬© 2025. All Rights Reserved.\n  \n  \n\n  \n  \n    Enabled by Dr. Marcin Bartosiak"
  },
  {
    "objectID": "Introduction.html",
    "href": "Introduction.html",
    "title": "Database Management - Introduction",
    "section": "",
    "text": "‚ÄúAll the value of this company is in its people. If you burned down all our plants, and we just kept our people and our information files, we should soon be as strong as ever.‚Äù\n\n\n\n\n\nThomas Watson Jr, 2nd President of IBM\n\n\n\n\n\n\n\n\n\n\n\n‚ÄúThe most meaningful way to differentiate your company from your competitors, the best way to put distance between you and the crowd, is to do an outstanding job with information. How you can gather,manage and use information will determine whether you win or lose‚Äù\n\n\n\n\n\nBill Gates, Founder of Microsoft\n\n\n\n\n\nThe two quotes above show us a very important truth about managing organization. In the Information society, which is based on innovation, knowledge and services, the key determinant of success has shifted from product quality to decision quality. In the traditional industrial society, the better quality product you had, the better market position you had (which is still very true in some cases). Nowadays, Companies are very dependent on information systems to create value for their customers. In other words, the better information you have, the better is your position.\nIf you are not convinced, think about your own private life. In today‚Äôs fast-paced world, managing personal information effectively is essential. Tools like calendars and address books serve as crucial external memory systems, helping us stay organized and on top of our daily tasks.\n\n\n\n\n\n\nA calendar not only helps us track appointments, meetings, and deadlines but also organizes time in a structured way, often with features to quickly navigate to today‚Äôs date or upcoming events.\n\n\n\n\n\n\n\n\n\n\n\n\nSimilarly, address books store important contact details, such as phone numbers and email addresses, allowing for easy access to frequently contacted individuals.\n\n\n\n\n\n\nBoth systems are designed to reduce the mental burden of remembering every detail, providing an efficient means of storing and retrieving information, thus enabling us to focus on more important tasks.\nThere are some common features of all these systems:\n\nStorage medium\n\nElectronic / paper\n\nStructure for storing data\nData is organized for:\n\nEfficient data entry\nRapid data retrieval\n\nAny design requires trade-offs\n\n\n\nOrganizations, like people, need to remember many things. Deciding where and how to store data frequently involves a trade-off.\nOrganizational data are used by a variety of information systems.\n\n\n\nA simple Informaion Sysem\n\n\nThere are many types of Information Systems in organizations.\n\n\n\n\n\n\n\nType of IS\nSystem‚Äôs purpose\n\n\n\n\nTPS\nTransaction processing system: Collects and stores data from routine transactions\n\n\nMIS\nManagement information system: Converts data from a TPS into information for planning, controlling, and managing an organization\n\n\nDSS\nDecision support system: Supports managerial decision making by providing models for processing and analysing data\n\n\nEIS\nExecutive information system: Provides senior management with information necessary to monitor organizational performance, and develop and implement strategies\n\n\nOLAP\nOnline analytical processing: Presents a multidimensional, logical view of data\n\n\nData mining\nUses statistical analysis and artificial intelligence techniques to identify hidden relationships in data\n\n\nBI\nBusiness intelligence: Systems for gathering, storing, analyzing, and accessing data to improve decision-making\n\n\n\nAll of them may require some sort of data to work.\n\n\n\nThe IS cycle\n\n\n\n\nFor the data to be effectively fed into all these systems, data management systems must meet specific requirements:\n\n\n\n\n\n\n\nRequirement\nDescription\n\n\n\n\nShareable\nReadily accessible to multiple users (at the same time).\n\n\nTransportable\nEasily accessible by users in different locations (e.g., salesperson, decision-maker).\n\n\nSecure\nSafe from destruction or unauthorized use.\n\n\nAccurate\nReliable and trustworthy.\n\n\nTimely\nCurrent and up-to-date.\n\n\nRelevant\nValuable and appropriate for its intended use.\n\n\n\n\n\n\n\nSimilarly, there are challenges and problems that database management systems must overcome:\n\n\n\n\n\n\n\nChallenge\nDescription\n\n\n\n\nRedundancy\nThe same data is replicated in multiple locations.\n\n\nLack of Data Control\nData is not secure or effectively organized and managed.\n\n\nPoor Interface\nData is not accessible.\n\n\nDelays\nData is not timely.\n\n\nLack of Reality\nData is not relevant because it lacks fidelity to the real world it represents.\n\n\nLack of Data Integration\nRelated data is stored in separate, isolated locations."
  },
  {
    "objectID": "Introduction.html#managin-data",
    "href": "Introduction.html#managin-data",
    "title": "Database Management - Introduction",
    "section": "",
    "text": "¬© 2025. All Rights Reserved.\n  \n  \n\n  \n  \n    Enabled by Dr. Marcin Bartosiak"
  },
  {
    "objectID": "Introduction.html#managing-data",
    "href": "Introduction.html#managing-data",
    "title": "Database Management - Introduction",
    "section": "",
    "text": "‚ÄúAll the value of this company is in its people. If you burned down all our plants, and we just kept our people and our information files, we should soon be as strong as ever.‚Äù\n\n\n\n\n\nThomas Watson Jr, 2nd President of IBM\n\n\n\n\n\n\n\n\n\n\n\n‚ÄúThe most meaningful way to differentiate your company from your competitors, the best way to put distance between you and the crowd, is to do an outstanding job with information. How you can gather,manage and use information will determine whether you win or lose‚Äù\n\n\n\n\n\nBill Gates, Founder of Microsoft\n\n\n\n\n\nThe two quotes above show us a very important truth about managing organization. In the Information society, which is based on innovation, knowledge and services, the key determinant of success has shifted from product quality to decision quality. In the traditional industrial society, the better quality product you had, the better market position you had (which is still very true in some cases). Nowadays, Companies are very dependent on information systems to create value for their customers. In other words, the better information you have, the better is your position.\nIf you are not convinced, think about your own private life. In today‚Äôs fast-paced world, managing personal information effectively is essential. Tools like calendars and address books serve as crucial external memory systems, helping us stay organized and on top of our daily tasks.\n\n\n\n\n\n\nA calendar not only helps us track appointments, meetings, and deadlines but also organizes time in a structured way, often with features to quickly navigate to today‚Äôs date or upcoming events.\n\n\n\n\n\n\n\n\n\n\n\n\nSimilarly, address books store important contact details, such as phone numbers and email addresses, allowing for easy access to frequently contacted individuals.\n\n\n\n\n\n\nBoth systems are designed to reduce the mental burden of remembering every detail, providing an efficient means of storing and retrieving information, thus enabling us to focus on more important tasks.\nThere are some common features of all these systems:\n\nStorage medium\n\nElectronic / paper\n\nStructure for storing data\nData is organized for:\n\nEfficient data entry\nRapid data retrieval\n\nAny design requires trade-offs"
  },
  {
    "objectID": "Introduction.html#organizational-data-management",
    "href": "Introduction.html#organizational-data-management",
    "title": "Database Management - Introduction",
    "section": "",
    "text": "Organizations, like people, need to remember many things. Deciding where and how to store data frequently involves a trade-off.\nOrganizational data are used by a variety of information systems.\n\n\n\nA simple Informaion Sysem\n\n\nThere are many types of Information Systems in organizations.\n\n\n\n\n\n\n\nType of IS\nSystem‚Äôs purpose\n\n\n\n\nTPS\nTransaction processing system: Collects and stores data from routine transactions\n\n\nMIS\nManagement information system: Converts data from a TPS into information for planning, controlling, and managing an organization\n\n\nDSS\nDecision support system: Supports managerial decision making by providing models for processing and analysing data\n\n\nEIS\nExecutive information system: Provides senior management with information necessary to monitor organizational performance, and develop and implement strategies\n\n\nOLAP\nOnline analytical processing: Presents a multidimensional, logical view of data\n\n\nData mining\nUses statistical analysis and artificial intelligence techniques to identify hidden relationships in data\n\n\nBI\nBusiness intelligence: Systems for gathering, storing, analyzing, and accessing data to improve decision-making\n\n\n\nAll of them may require some sort of data to work.\n\n\n\nThe IS cycle\n\n\n\n\nFor the data to be effectively fed into all these systems, data management systems must meet specific requirements:\n\n\n\n\n\n\n\nRequirement\nDescription\n\n\n\n\nShareable\nReadily accessible to multiple users (at the same time).\n\n\nTransportable\nEasily accessible by users in different locations (e.g., salesperson, decision-maker).\n\n\nSecure\nSafe from destruction or unauthorized use.\n\n\nAccurate\nReliable and trustworthy.\n\n\nTimely\nCurrent and up-to-date.\n\n\nRelevant\nValuable and appropriate for its intended use.\n\n\n\n\n\n\n\nSimilarly, there are challenges and problems that database management systems must overcome:\n\n\n\n\n\n\n\nChallenge\nDescription\n\n\n\n\nRedundancy\nThe same data is replicated in multiple locations.\n\n\nLack of Data Control\nData is not secure or effectively organized and managed.\n\n\nPoor Interface\nData is not accessible.\n\n\nDelays\nData is not timely.\n\n\nLack of Reality\nData is not relevant because it lacks fidelity to the real world it represents.\n\n\nLack of Data Integration\nRelated data is stored in separate, isolated locations."
  },
  {
    "objectID": "Introduction.html#databases-and-database-design",
    "href": "Introduction.html#databases-and-database-design",
    "title": "Database Management - Introduction",
    "section": "Databases and Database Design",
    "text": "Databases and Database Design\n\nData vs.¬†Information\nBefore diving into databases, it‚Äôs crucial to grasp the distinction between data, information, and knowledge. Databases don‚Äôt just store raw data ‚Äì they organize it into meaningful information that can be analyzed to generate knowledge.\nData consists of raw facts and figures without context, like individual numbers or words. Information emerges when data is organized and given context, making it meaningful and useful ‚Äì for instance, when those numbers represent monthly sales figures. Knowledge goes further: it‚Äôs the understanding gained from analyzing and applying information, allowing us to make informed decisions and recognize patterns.\n\n\n\n\n\n\n\n\nCategory\nCharacteristics\nExample\n\n\n\n\nData\n‚Ä¢ Raw facts‚Ä¢ No context‚Ä¢ Just numbers and text\nTemperature readings: 23, 25, 22, 24, 26\n\n\nInformation\n‚Ä¢ Data with context‚Ä¢ Processed data‚Ä¢ Value added to data‚Ä¢ Summarized‚Ä¢ Organized‚Ä¢ Analyzed\nDaily temperature readings in Celsius for Pavia, week of June 1-5, 2024, showing an average of 24¬∞C with an upward trend\n\n\nKnowledge\n‚Ä¢ Knowing what information is required‚Ä¢ Knowing what the information means\nUnderstanding that the rising temperature trend in Pavia indicates the start of summer and knowing to adjust city services (like water supply) and public health advisories accordingly\n\n\n\nA database‚Äôs true value lies in its ability to transform raw data into actionable insights through structured organization and relationships.\n\n\nDatabase\nA database is an organized collection of related files used to store and manage data efficiently. It serves as a single logical data repository, ensuring that data is structured, accessible, and self-describing. Databases contain both user data (actual stored information) and metadata (data about the data, such as structure and relationships).\nIn a relational database, data is organized into tables, where each row (record) represents a unit of interest, and each column (field) defines an attribute of that unit.\nThere are different types of databases based on usage and architecture:\n\nTypes of Databases Explained\n\n1. Single-User vs.¬†Multi-User Databases\n\nSingle-User Database: Designed for one user at a time, typically used in personal applications or small-scale projects (e.g., Microsoft Access, SQLite).\n\nMulti-User Database: Supports multiple users accessing and modifying data simultaneously, often used in businesses and enterprise systems (e.g., MySQL, PostgreSQL).\n\n\n\n2. Operational (Transactional) vs.¬†Analytical Databases\n\nOperational (Transactional) Database: Used for real-time operations, such as processing daily business transactions (e.g., banking systems, e-commerce platforms). These databases are optimized for fast inserts, updates, and deletes.\n\nAnalytical Database: Designed for reporting and decision-making, optimized for complex queries and data analysis rather than frequent transactions (e.g., data warehouses like Amazon Redshift or Google BigQuery).\n\n\n\n3. Centralized, Distributed, or Cloud Databases\n\nCentralized Database: All data is stored in a single location, often on a dedicated server. This setup simplifies management but can become a bottleneck as data scales.\n\nDistributed Database: Data is spread across multiple locations or servers, improving performance and reliability (e.g., Google Spanner, Apache Cassandra).\n\nCloud Database: Hosted on cloud platforms, allowing for scalable, flexible, and remotely accessible data storage (e.g., AWS RDS, Google Cloud SQL).\n\n\n\n4. Single-Tenant vs.¬†Multi-Tenant Databases\n\nSingle-Tenant Database: Each customer (tenant) has their own dedicated database. This provides better security and customization but can be expensive (e.g., private database instances for enterprises).\n\nMulti-Tenant Database: A single database serves multiple customers, with data logically separated. This is commonly used in SaaS (Software as a Service) applications (e.g., Salesforce, Shopify).\n\n\n\n5. Relational vs.¬†Non-Relational Databases\n\nRelational Database (RDBMS): Uses structured tables with predefined relationships and follows SQL for querying (e.g., MySQL, PostgreSQL, Oracle). Best for structured, consistent data.\n\nNon-Relational Database (NoSQL): Stores data in flexible formats like key-value pairs, documents, graphs, or columns (e.g., MongoDB, Redis, Cassandra). Ideal for big data, real-time applications, and unstructured data.\n\nEach database type is suited for different use cases depending on the scale, structure, and nature of the data being managed.\n\n\n\n\nDatabase Model\nDatabase Model is the logical representation of the structure of the data.\n\n\n\nDatabase Model Example\n\n\nData Modelling\n\nThe technique for creating the logical structure of a database\n\nWhat files (tables) should be in the database?\nHow are these files related?\nWhat columns should describe each row in a table?\n\nData Modeling is an iterative process\nData Modeling is a communication tool\n\n\n\n\n\n\n\nNote\n\n\n\nData Modelling is a design process\n\n\nDESIGN The specification of an object, intended to accomplish goals, in a particular environment, using a set of primitive components, satisfying a set of requirements, subject to constraints.\n\n\n\nDifferent requirements = different design\n\n\n\n\n\n\n\n\nNote\n\n\n\nData Modelling is an iterative process\n\n\n\n\n\n\n\n\nData modeling is a highly repetitive and cyclical process, requiring continuous refinement and improvement at every stage. It begins with an initial conceptual model, which is repeatedly reviewed, adjusted, and expanded based on new insights, stakeholder feedback, and evolving business needs. Each iteration involves revisiting assumptions, restructuring relationships, and optimizing performance to ensure the model remains accurate and efficient. As data requirements change, the process loops back, refining previous versions and incorporating necessary modifications. This ongoing cycle of evaluation and enhancement ensures that the final data model is robust, scalable, and aligned with organizational goals.\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nData Modelling is a communication process\n\n\nIt serves as a bridge between technical teams, business stakeholders, and end users. It translates complex data structures into understandable diagrams and definitions, ensuring that everyone involved has a clear understanding of how data is organized, stored, and utilized. Effective data modeling requires collaboration, as stakeholders provide input on business rules and requirements while data architects translate these needs into structured models. This shared understanding helps prevent misinterpretations, aligns expectations, and ensures that the final database or system supports business objectives efficiently."
  },
  {
    "objectID": "Introduction.html#wait-why-bother",
    "href": "Introduction.html#wait-why-bother",
    "title": "Database Management - Introduction",
    "section": "WAIT! WHY BOTHER?",
    "text": "WAIT! WHY BOTHER?\n\n\n\n\n\n\n\n\n\nWhy don‚Äôt we just use Excel like everyone else???\n\n\n\n\n\n\n\n\n\nWhile Excel is a powerful tool for organizing and analyzing data, it is not designed for managing large-scale, complex datasets that require consistency, security, and efficient querying. Databases offer structured storage, ensuring data integrity through constraints, relationships, and normalization, which Excel lacks. Additionally, databases handle concurrent access, scalability, automation, and advanced querying via SQL, making them the superior choice for robust and reliable data management.l\n\n\n\n\n\nBad things can happen, when you use Excel to store your data üò¢\n\n\n\n\n\nOne major issue with using Excel for data management is the risk of anomalies‚Äîproblems that arise due to poorly structured data.\n\n\n\n\n\n\nWarning\n\n\n\nAnomalies are problems that occur in a poorly designed database when inserting, updating, or deleting data. They happen because data is not organized properly, leading to inconsistencies, duplication, or unintended data loss.\n\n\nLet‚Äôs consider this table. It contains stock market data that is used by an investment firm dealing with international commodities and agricultural products. Think about the problems we may have with it\n\n\n\n\n\n\n\nStock market data\n\n\n\n\n\n\n\n\nWarning\n\n\n\nInsertion anomalies occur when adding new data is difficult due to missing dependencies.\n\n\nFor example n our table you cannot add a new nation exchange rate without creating a (fake) stock\n\n\n\n\n\n\nWarning\n\n\n\nUpdate anomalies lead to inconsistencies when changes must be made in multiple places.\n\n\nWhen the exchange rate in the UK changes you must update the rows for 10 shares. Likely to generate errors and/or inconsistencies\n\n\n\n\n\n\nWarning\n\n\n\nDeletion anomalies cause unintended data loss when removing a record also removes critical information.\n\n\nFor example, if you sell ‚ÄúBombay Duck‚Äù you lose information about the Indian exchange rate.\nUnlike Excel, databases prevent these anomalies through normalization, ensuring data is stored efficiently and consistently."
  },
  {
    "objectID": "Introduction.html#database-management-systems",
    "href": "Introduction.html#database-management-systems",
    "title": "Database Management - Introduction",
    "section": "Database Management Systems",
    "text": "Database Management Systems\n\n\n\n\n\n\nNote\n\n\n\nA Database Management System (DBMS) is software that allows users to create, store, manage, and retrieve data efficiently.\n\n\n\n\n\n\n\n\n\nDatabase Management System (Icons created by Ranah Pixel Studio, Freepik, Pixel perfect, and xnimrodx - Flaticon)\n\n\nA Database Management System (DBMS) is essential for businesses as it reduces data inconsistency, ensuring that the same information does not appear differently across multiple locations. A DBMS also improves data sharing, security, and access, allowing authorized users to retrieve and update data seamlessly. This leads to better decision-making as businesses can rely on accurate and up-to-date information. Additionally, it enhances end-user productivity by streamlining workflows and reducing errors.\nExamples of DBMS include MySQL, PostgreSQL, Oracle, and Microsoft SQL Server.\nOverall, a DBMS provides better data integration, making business operations more efficient and reliable.\n\nDBMS Functions:\n\n\n\n\n\n\n\nFunction\nDescription\n\n\n\n\nData dictionary management\nStores definitions of the data elements and their relationships\n\n\nData storage management\nPerformance tuning: Ensures efficient performance of the database in terms of storage and access speed\n\n\nData transformation and presentation\nTransforms entered data to conform to required data structures\n\n\nSecurity management\nEnforces user security and data privacy\n\n\nMultiuser access control\nSophisticated algorithms ensure that multiple users can access the database concurrently without compromising its integrity\n\n\nBackup and recovery management\nEnables recovery of the database after a failure\n\n\nData integrity management\nMinimizes redundancy and maximizes consistency\n\n\nDatabase access languages and application programming interfaces\n- Query language: Lets the user specify what must be done without having to specify how- Structured Query Language (SQL): De facto query language and data access standard supported by the majority of DBMS vendors\n\n\nDatabase communication interfaces\nAccept end-user requests via multiple, different network environments\n\n\n\n\n\n\nImages and GIFs Disclaimer: Some of the images and GIFs used on this website are not owned by me. They are used for educational and illustrative purposes only. All rights belong to their respective owners. If you believe any content violates copyright, please contact me for prompt removal.\n\n\n\n\n\n\n  \n  \n    ¬© 2025. All Rights Reserved.\n  \n  \n\n  \n  \n    Enabled by Dr. Marcin Bartosiak"
  },
  {
    "objectID": "Introduction.html#types-of-databases-explained",
    "href": "Introduction.html#types-of-databases-explained",
    "title": "Database Management - Introduction",
    "section": "Types of Databases Explained",
    "text": "Types of Databases Explained\n\n1. Single-User vs.¬†Multi-User Databases\n\nSingle-User Database: Designed for one user at a time, typically used in personal applications or small-scale projects (e.g., Microsoft Access, SQLite).\n\nMulti-User Database: Supports multiple users accessing and modifying data simultaneously, often used in businesses and enterprise systems (e.g., MySQL, PostgreSQL).\n\n\n\n2. Operational (Transactional) vs.¬†Analytical Databases\n\nOperational (Transactional) Database: Used for real-time operations, such as processing daily business transactions (e.g., banking systems, e-commerce platforms). These databases are optimized for fast inserts, updates, and deletes.\n\nAnalytical Database: Designed for reporting and decision-making, optimized for complex queries and data analysis rather than frequent transactions (e.g., data warehouses like Amazon Redshift or Google BigQuery).\n\n\n\n3. Centralized, Distributed, or Cloud Databases\n\nCentralized Database: All data is stored in a single location, often on a dedicated server. This setup simplifies management but can become a bottleneck as data scales.\n\nDistributed Database: Data is spread across multiple locations or servers, improving performance and reliability (e.g., Google Spanner, Apache Cassandra).\n\nCloud Database: Hosted on cloud platforms, allowing for scalable, flexible, and remotely accessible data storage (e.g., AWS RDS, Google Cloud SQL).\n\n\n\n4. Single-Tenant vs.¬†Multi-Tenant Databases\n\nSingle-Tenant Database: Each customer (tenant) has their own dedicated database. This provides better security and customization but can be expensive (e.g., private database instances for enterprises).\n\nMulti-Tenant Database: A single database serves multiple customers, with data logically separated. This is commonly used in SaaS (Software as a Service) applications (e.g., Salesforce, Shopify).\n\n\n\n5. Relational vs.¬†Non-Relational Databases\n\nRelational Database (RDBMS): Uses structured tables with predefined relationships and follows SQL for querying (e.g., MySQL, PostgreSQL, Oracle). Best for structured, consistent data.\n\nNon-Relational Database (NoSQL): Stores data in flexible formats like key-value pairs, documents, graphs, or columns (e.g., MongoDB, Redis, Cassandra). Ideal for big data, real-time applications, and unstructured data.\n\nEach database type is suited for different use cases depending on the scale, structure, and nature of the data being managed.\n\n\nDatabase Model\nDatabase Model is the logical representation of the structure of the data.\n\n\n\nDatabase Model Example\n\n\nData Modelling\n\nThe technique for creating the logical structure of a database\n\nWhat files (tables) should be in the database?\nHow are these files related?\nWhat columns should describe each row in a table?\n\nData Modeling is an iterative process\nData Modeling is a communication tool\n\n\n\n\n\n\n\nNote\n\n\n\nData Modelling is a design process\n\n\nDESIGN The specification of an object, intended to accomplish goals, in a particular environment, using a set of primitive components, satisfying a set of requirements, subject to constraints.\n\n\n\n\n\n\nNote\n\n\n\nData Modelling is an iterative process\n\n\n\n\n\n\n\n\nData modeling is a highly repetitive and cyclical process, requiring continuous refinement and improvement at every stage. It begins with an initial conceptual model, which is repeatedly reviewed, adjusted, and expanded based on new insights, stakeholder feedback, and evolving business needs. Each iteration involves revisiting assumptions, restructuring relationships, and optimizing performance to ensure the model remains accurate and efficient. As data requirements change, the process loops back, refining previous versions and incorporating necessary modifications. This ongoing cycle of evaluation and enhancement ensures that the final data model is robust, scalable, and aligned with organizational goals.\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nData Modelling is a communication process\n\n\nIt serves as a bridge between technical teams, business stakeholders, and end users. It translates complex data structures into understandable diagrams and definitions, ensuring that everyone involved has a clear understanding of how data is organized, stored, and utilized. Effective data modeling requires collaboration, as stakeholders provide input on business rules and requirements while data architects translate these needs into structured models. This shared understanding helps prevent misinterpretations, aligns expectations, and ensures that the final database or system supports business objectives efficiently."
  },
  {
    "objectID": "Introduction.html#data-vs.-information",
    "href": "Introduction.html#data-vs.-information",
    "title": "Database Management - Introduction",
    "section": "Data vs.¬†Information",
    "text": "Data vs.¬†Information\nBefore diving into databases, it‚Äôs crucial to grasp the distinction between data, information, and knowledge. Databases don‚Äôt just store raw data ‚Äì they organize it into meaningful information that can be analyzed to generate knowledge.\nData consists of raw facts and figures without context, like individual numbers or words. Information emerges when data is organized and given context, making it meaningful and useful ‚Äì for instance, when those numbers represent monthly sales figures. Knowledge goes further: it‚Äôs the understanding gained from analyzing and applying information, allowing us to make informed decisions and recognize patterns.\n\n\n\n\n\n\n\n\nCategory\nCharacteristics\nExample\n\n\n\n\nData\n‚Ä¢ Raw facts‚Ä¢ No context‚Ä¢ Just numbers and text\nTemperature readings: 23, 25, 22, 24, 26\n\n\nInformation\n‚Ä¢ Data with context‚Ä¢ Processed data‚Ä¢ Value added to data‚Ä¢ Summarized‚Ä¢ Organized‚Ä¢ Analyzed\nDaily temperature readings in Celsius for Pavia, week of June 1-5, 2024, showing an average of 24¬∞C with an upward trend\n\n\nKnowledge\n‚Ä¢ Knowing what information is required‚Ä¢ Knowing what the information means\nUnderstanding that the rising temperature trend in Pavia indicates the start of summer and knowing to adjust city services (like water supply) and public health advisories accordingly\n\n\n\nA database‚Äôs true value lies in its ability to transform raw data into actionable insights through structured organization and relationships."
  },
  {
    "objectID": "Introduction.html#database",
    "href": "Introduction.html#database",
    "title": "Database Management - Introduction",
    "section": "Database",
    "text": "Database\nA database is an organized collection of related files used to store and manage data efficiently. It serves as a single logical data repository, ensuring that data is structured, accessible, and self-describing. Databases contain both user data (actual stored information) and metadata (data about the data, such as structure and relationships).\nIn a relational database, data is organized into tables, where each row (record) represents a unit of interest, and each column (field) defines an attribute of that unit.\nThere are different types of databases based on usage and architecture:\n\nTypes of Databases Explained\n\n1. Single-User vs.¬†Multi-User Databases\n\nSingle-User Database: Designed for one user at a time, typically used in personal applications or small-scale projects (e.g., Microsoft Access, SQLite).\n\nMulti-User Database: Supports multiple users accessing and modifying data simultaneously, often used in businesses and enterprise systems (e.g., MySQL, PostgreSQL).\n\n\n\n2. Operational (Transactional) vs.¬†Analytical Databases\n\nOperational (Transactional) Database: Used for real-time operations, such as processing daily business transactions (e.g., banking systems, e-commerce platforms). These databases are optimized for fast inserts, updates, and deletes.\n\nAnalytical Database: Designed for reporting and decision-making, optimized for complex queries and data analysis rather than frequent transactions (e.g., data warehouses like Amazon Redshift or Google BigQuery).\n\n\n\n3. Centralized, Distributed, or Cloud Databases\n\nCentralized Database: All data is stored in a single location, often on a dedicated server. This setup simplifies management but can become a bottleneck as data scales.\n\nDistributed Database: Data is spread across multiple locations or servers, improving performance and reliability (e.g., Google Spanner, Apache Cassandra).\n\nCloud Database: Hosted on cloud platforms, allowing for scalable, flexible, and remotely accessible data storage (e.g., AWS RDS, Google Cloud SQL).\n\n\n\n4. Single-Tenant vs.¬†Multi-Tenant Databases\n\nSingle-Tenant Database: Each customer (tenant) has their own dedicated database. This provides better security and customization but can be expensive (e.g., private database instances for enterprises).\n\nMulti-Tenant Database: A single database serves multiple customers, with data logically separated. This is commonly used in SaaS (Software as a Service) applications (e.g., Salesforce, Shopify).\n\n\n\n5. Relational vs.¬†Non-Relational Databases\n\nRelational Database (RDBMS): Uses structured tables with predefined relationships and follows SQL for querying (e.g., MySQL, PostgreSQL, Oracle). Best for structured, consistent data.\n\nNon-Relational Database (NoSQL): Stores data in flexible formats like key-value pairs, documents, graphs, or columns (e.g., MongoDB, Redis, Cassandra). Ideal for big data, real-time applications, and unstructured data.\n\nEach database type is suited for different use cases depending on the scale, structure, and nature of the data being managed."
  },
  {
    "objectID": "Introduction.html#database-model",
    "href": "Introduction.html#database-model",
    "title": "Database Management - Introduction",
    "section": "Database Model",
    "text": "Database Model\nDatabase Model is the logical representation of the structure of the data.\n\n\n\nDatabase Model Example\n\n\nData Modelling\n\nThe technique for creating the logical structure of a database\n\nWhat files (tables) should be in the database?\nHow are these files related?\nWhat columns should describe each row in a table?\n\nData Modeling is an iterative process\nData Modeling is a communication tool\n\n\n\n\n\n\n\nNote\n\n\n\nData Modelling is a design process\n\n\nDESIGN: the specification of an object, intended to accomplish goals, in a particular environment, using a set of primitive components, satisfying a set of requirements, subject to constraints.\n\n\n\nDifferent requirements = different design\n\n\n\n\n\n\n\n\nNote\n\n\n\nData Modelling is an iterative process\n\n\n\n\n\n\n\n\nData modeling is a highly repetitive and cyclical process, requiring continuous refinement and improvement at every stage. It begins with an initial conceptual model, which is repeatedly reviewed, adjusted, and expanded based on new insights, stakeholder feedback, and evolving business needs. Each iteration involves revisiting assumptions, restructuring relationships, and optimizing performance to ensure the model remains accurate and efficient. As data requirements change, the process loops back, refining previous versions and incorporating necessary modifications. This ongoing cycle of evaluation and enhancement ensures that the final data model is robust, scalable, and aligned with organizational goals.\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nData Modelling is a communication process\n\n\nIt serves as a bridge between technical teams, business stakeholders, and end users. It translates complex data structures into understandable diagrams and definitions, ensuring that everyone involved has a clear understanding of how data is organized, stored, and utilized. Effective data modeling requires collaboration, as stakeholders provide input on business rules and requirements while data architects translate these needs into structured models. This shared understanding helps prevent misinterpretations, aligns expectations, and ensures that the final database or system supports business objectives efficiently."
  },
  {
    "objectID": "1-single-entity-complete.html",
    "href": "1-single-entity-complete.html",
    "title": "Introduction to SQL. Single entity",
    "section": "",
    "text": "Database Model is the logical representation of the structure of the data.\n\n\n\nDatabase Model Example\n\n\nIn general, there are two types of database models:\n\nConceptual Data Model\n\nThe logical representation of the structure of the data (conceptual metadata)\nUsing a specific modelling notation (e.g., ER diagramming, crow-foot notation, UML)\n\n\n\n\n\n\n\n\n\n\nHand-drawn crowfoot model\n\n\n\n\n\n\n\nER diagram\n\n\n\n\n\n\nFigure¬†1\n\n\n\n\nImplementable Data Model\n\nProduced in specialized software\nReady to launch on a server\nConceptual design\nData dictionary\n\n\n\n\n\nImplementable Model\n\n\nModelling is Designing\nA database must model the real world\n\nTo model means:\n\nTo represent faithfully\nGiven the database design objectives\nWithin scope and under given constraints\n\n\nObjective: Storing and retrieving data about the real world\nData modelling is a design technique for capturing data reality\n\n\nThe relational model is a way of organizing data into tables (called relations).\nThe Relational Model represents data and their relationships through a collection of tables. Each table also known as a relation consists of rows and columns. Every column has a unique name and corresponds to a specific attribute, while each row contains a set of related data values representing a real-world entity or relationship.\nThe relational model represents how data is stored in Relational Databases. A relational database consists of a collection of tables each of which is assigned a unique name.\n\n\n\nRelational Model\n\n\nRelation or table: * Matrix of intersecting tuples and attributes + Tuples: Rows + Attributes: Columns\n\n\n\nAn entity is some thing in the environment. It can be a physical entity (e.g., student) or an abstraction (e.g., marriage). You can think of an entity as a class of objects (or phenomena). An instance is a particular occurrence of an entity.\n\n\n\n\n\nNo worries! It will get easier with the examples below üòÖ\n\n\n\nEntity: ‚ÄúCar‚Äù is an entity because it represents a general category of objects that share common characteristics, such as having wheels, an engine, and the ability to transport people.\n\nInstance: A specific car, like a red 2015 Volkswagen Beetle with license plate ABC123, is an instance of the ‚ÄúCar‚Äù entity. It is a particular example with unique attributes.\n\n\n\n\n\n\n\n\n\n\nEntity: ‚ÄúTree‚Äù is an entity because it represents a general type of object that has roots, a trunk, and leaves.\n\nInstance: A specific tree in a forest, such as the 50-year-old oak tree standing near the river in Amazon Rainforest, is an instance of the ‚ÄúTree‚Äù entity. It is a unique example of the general concept.\n\n\n\n\n\n\n\n\n\nFirst, we need to draw an entity.\nRemember, an entity is:\n\nSome thing in the environment\nA physical entity (e.g., student) or an abstraction (e.g., marriage)\nAn entity is a class (or entity set)\nAn instance is a particular occurrence of an entity\n\n\n\n\n\n\n\nNote\n\n\n\nAn entity is represented by a rectangle in modelling notation\n\n\n\n\n\n\n\n\n\nAn entity\n\n\nSecond, let‚Äôs think about attributes.\nAn attribute is a discrete data element that describes an entity.\n\nAttributes must be conceptually unique\n\nHomonym: Same name is used to label different attributes\nSynonym: Different names are used to describe the same attribute\n\n\n\n\n\n\n\n\nNote\n\n\n\nAttribute names must be unique within a data model\nAttribute names should be meaningful\n\n\n\n\n\n\n\n\n\nAttributes\n\n\nThere is one more step before we have our model ready. We need to add identifiers.\nEvery instance of an entity must be uniquely identified.\nAn identifier can be an attribute or collection of attributes.\nAn identifier can be created if there is no obvious attribute (surrogate).\n\n\n\n\n\n\nNote\n\n\n\nA leading asterisk denotes an identifier in our entity.\n\n\n\n\n\n\n\n\n\nIdentifier (*)\n\n\nThat‚Äôs it! You‚Äôve created your first database model. It‚Äôs a simple one‚Äîjust a single table. But soon, we‚Äôll be designing much more complex databases, all built on these few basic steps.\n\n\n\n\nCreate a data model for recording details of the herd of cows that you manage"
  },
  {
    "objectID": "1-single-entity-complete.html#the-relational-model",
    "href": "1-single-entity-complete.html#the-relational-model",
    "title": "Introduction to SQL. Single entity",
    "section": "",
    "text": "The relational model is a way of organizing data into tables (called relations).\nThe Relational Model represents data and their relationships through a collection of tables. Each table also known as a relation consists of rows and columns. Every column has a unique name and corresponds to a specific attribute, while each row contains a set of related data values representing a real-world entity or relationship.\nThe relational model represents how data is stored in Relational Databases. A relational database consists of a collection of tables each of which is assigned a unique name.\n\n\n\nRelational Model\n\n\nRelation or table: * Matrix of intersecting tuples and attributes + Tuples: Rows + Attributes: Columns"
  },
  {
    "objectID": "1-single-entity-complete.html#single-entity",
    "href": "1-single-entity-complete.html#single-entity",
    "title": "Introduction to SQL. Single entity",
    "section": "",
    "text": "An entity is some thing in the environment. It can be a physical entity (e.g., student) or an abstraction (e.g., marriage). You can think of an entity as a class of objects (or phenomena). An instance is a particular occurrence of an entity.\n\n\n\n\n\nNo worries! It will get easier with the examples below üòÖ\n\n\n\nEntity: ‚ÄúCar‚Äù is an entity because it represents a general category of objects that share common characteristics, such as having wheels, an engine, and the ability to transport people.\n\nInstance: A specific car, like a red 2015 Volkswagen Beetle with license plate ABC123, is an instance of the ‚ÄúCar‚Äù entity. It is a particular example with unique attributes.\n\n\n\n\n\n\n\n\n\n\nEntity: ‚ÄúTree‚Äù is an entity because it represents a general type of object that has roots, a trunk, and leaves.\n\nInstance: A specific tree in a forest, such as the 50-year-old oak tree standing near the river in Amazon Rainforest, is an instance of the ‚ÄúTree‚Äù entity. It is a unique example of the general concept.\n\n\n\n\n\n\n\n\n\nFirst, we need to draw an entity.\nRemember, an entity is:\n\nSome thing in the environment\nA physical entity (e.g., student) or an abstraction (e.g., marriage)\nAn entity is a class (or entity set)\nAn instance is a particular occurrence of an entity\n\n\n\n\n\n\n\nNote\n\n\n\nAn entity is represented by a rectangle in modelling notation\n\n\n\n\n\n\n\n\n\nAn entity\n\n\nSecond, let‚Äôs think about attributes.\nAn attribute is a discrete data element that describes an entity.\n\nAttributes must be conceptually unique\n\nHomonym: Same name is used to label different attributes\nSynonym: Different names are used to describe the same attribute\n\n\n\n\n\n\n\n\nNote\n\n\n\nAttribute names must be unique within a data model\nAttribute names should be meaningful\n\n\n\n\n\n\n\n\n\nAttributes\n\n\nThere is one more step before we have our model ready. We need to add identifiers.\nEvery instance of an entity must be uniquely identified.\nAn identifier can be an attribute or collection of attributes.\nAn identifier can be created if there is no obvious attribute (surrogate).\n\n\n\n\n\n\nNote\n\n\n\nA leading asterisk denotes an identifier in our entity.\n\n\n\n\n\n\n\n\n\nIdentifier (*)\n\n\nThat‚Äôs it! You‚Äôve created your first database model. It‚Äôs a simple one‚Äîjust a single table. But soon, we‚Äôll be designing much more complex databases, all built on these few basic steps."
  },
  {
    "objectID": "1-single-entity-complete.html#exercise",
    "href": "1-single-entity-complete.html#exercise",
    "title": "Introduction to SQL. Single entity",
    "section": "",
    "text": "Create a data model for recording details of the herd of cows that you manage"
  },
  {
    "objectID": "1-single-entity-complete.html#querying-a-table",
    "href": "1-single-entity-complete.html#querying-a-table",
    "title": "Introduction to SQL. Single entity",
    "section": "Querying a Table",
    "text": "Querying a Table\nIn SQL, the simplest way to retrieve data is by using SELECT * FROM tableName;. This command asks the database to return everything in the table. Think of it as saying, ‚ÄúHey, server, show me (SELECT) all the data (*) in this table (FROM)!‚Äù\nOf course, tableName is just a placeholder. We will have to replace it with the real name. In our case, the table is called brand.\nTry it yourself with our brand table:\n\nSELECT * FROM brand;\n\n\n\n\n\n\n\nNote\n\n\n\nHave you noticed the small detail at the end of line? Every query has to end with ;. It tells the server that your query ends here. Everything after this sign is a new code. This will be important when we run more than one query at a time."
  },
  {
    "objectID": "1-single-entity-complete.html#projection-choosing-columns",
    "href": "1-single-entity-complete.html#projection-choosing-columns",
    "title": "Introduction to SQL. Single entity",
    "section": "Projection: Choosing Columns",
    "text": "Projection: Choosing Columns\nSometimes, you don‚Äôt need all the data‚Äîjust specific columns.\n\n\n\n\n\nYou can request only what you need by listing column names:\n\nSELECT brandName, brandChain FROM brand; \n\nThis is like asking, ‚ÄúTell me just the brand name and chain, please.‚Äù"
  },
  {
    "objectID": "1-single-entity-complete.html#restriction-choosing-rows",
    "href": "1-single-entity-complete.html#restriction-choosing-rows",
    "title": "Introduction to SQL. Single entity",
    "section": "Restriction: Choosing Rows",
    "text": "Restriction: Choosing Rows\nIf you only want certain rows, use WHERE to filter results.\n\n\n\n\n\nTry yourself and report all brands owned by Hilton Worldwide.\n\nSELECT * FROM brand \n  WHERE brandChain = 'Hilton Worldwide';\n\nThis is like telling the server, ‚ÄúOnly show me brands owned by Hilton.‚Äù\nYou can choose any other lodging chain instead of ‚ÄòHilton Worldwide‚Äô. For example, try with ‚ÄòAccor‚Äô and see how the results change.\n\n\n\n\n\n\nWarning\n\n\n\nHilton or Accor are values, not attributes. Unlike column names or table name, you always have to wrap text values with quotation marks ('...' or \"...\").\n\n\n\n\n\n\n\n\nTip\n\n\n\nFollowing the same logic, you can exclude a value from the results. You have to replace = with != or &lt;&gt; (they both mean the same thing).\n\n\nTry yourself and report all brands but Hilton Worldwide. Edit the query to try it with &lt;&gt; too.\n\nSELECT * FROM brand \n  WHERE brandChain &lt;&gt; 'Hilton Worldwide';"
  },
  {
    "objectID": "1-single-entity-complete.html#projection-and-restriction-together",
    "href": "1-single-entity-complete.html#projection-and-restriction-together",
    "title": "Introduction to SQL. Single entity",
    "section": "Projection and Restriction Together",
    "text": "Projection and Restriction Together\nCombining both techniques, you can select specific columns and filter rows. List the brand name and segment of all brands owned by Hilton Worldwide:\n\nSELECT brandName, brandSegment FROM brand \n  WHERE brandChain = 'Hilton Worldwide';\n\nNow you‚Äôre asking, ‚ÄúShow me just the names and segments of Hilton brands.‚Äù"
  },
  {
    "objectID": "1-single-entity-complete.html#primary-key-retrieval",
    "href": "1-single-entity-complete.html#primary-key-retrieval",
    "title": "Introduction to SQL. Single entity",
    "section": "Primary Key Retrieval",
    "text": "Primary Key Retrieval\nA primary key uniquely identifies a row. If you query by it, you get at most one result:\n\nSELECT * FROM brand \n  WHERE brandID = 10;\n\nThis is like saying, ‚ÄúGive me all details about the brand with ID 10.‚Äù\nImportant Notice that numerical values do not have to be wrapped with quotation marks."
  },
  {
    "objectID": "1-single-entity-complete.html#queries-without-primary-key",
    "href": "1-single-entity-complete.html#queries-without-primary-key",
    "title": "Introduction to SQL. Single entity",
    "section": "Queries Without Primary Key",
    "text": "Queries Without Primary Key\nWithout a primary key, multiple rows can be returned:\n\nSELECT * FROM brand \n  WHERE brandChain = 'Accor';"
  },
  {
    "objectID": "1-single-entity-complete.html#the-in-operator",
    "href": "1-single-entity-complete.html#the-in-operator",
    "title": "Introduction to SQL. Single entity",
    "section": "The IN Operator",
    "text": "The IN Operator\nIf you want to filter by multiple values, IN operator will come handy:\n\nSELECT * FROM brand \n  WHERE brandSegment IN ('Luxury', 'Economy');\n\nThis is the equivalent of saying, ‚ÄúGive me brands that are either Luxury or Economy.‚Äù\nYou could get the same results by using WHERE with OR:\n\nSELECT * FROM brand \n    WHERE brandSegment = 'Luxury'\n        OR brandSegment = 'Economy';\n\nDo you see how much more efficient it is with IN?"
  },
  {
    "objectID": "1-single-entity-complete.html#the-not-in-operator",
    "href": "1-single-entity-complete.html#the-not-in-operator",
    "title": "Introduction to SQL. Single entity",
    "section": "The NOT IN Operator",
    "text": "The NOT IN Operator\nTo exclude more than one value, use NOT IN:\n\nSELECT * FROM brand \n  WHERE brandName NOT IN ('Sofitel', 'Thalassa', 'Curio', 'Conrad');\n\nThis means, ‚ÄúShow me everything except these brands.‚Äù"
  },
  {
    "objectID": "1-single-entity-complete.html#ordering-columns",
    "href": "1-single-entity-complete.html#ordering-columns",
    "title": "Introduction to SQL. Single entity",
    "section": "Ordering Columns",
    "text": "Ordering Columns\nThe order of selected columns in your query defines how results appear. This just structures the results the way you prefer.\nCompare these two queries\n\nSELECT brandName, brandSegment FROM brand WHERE brandChain = 'Accor';\n\n\nSELECT brandSegment, brandName FROM brand WHERE brandChain = 'Accor';"
  },
  {
    "objectID": "1-single-entity-complete.html#ordering-rows",
    "href": "1-single-entity-complete.html#ordering-rows",
    "title": "Introduction to SQL. Single entity",
    "section": "Ordering Rows",
    "text": "Ordering Rows\nIf you need to sort the results, you can use ORDER BY.\n\n\n\n\n\nList all brands with rooms smaller than 350 square feet with largest first:\n\nSELECT * FROM brand WHERE brandMinSqFt &lt; 350 ORDER BY brandMinSqFt DESC;\n\nThis means, ‚ÄúShow me brands with rooms under 350 sqft, biggest first, and if sizes match, sort alphabetically.‚Äù\n\n\n\n\n\n\nTip\n\n\n\nDESC means descending order (biggest first). If you need ascending order (smallest first), you can replace it with ASC or simply remove it (ascending order is default in SQL).\n\n\n\n\n\n\n\n\nNote\n\n\n\nHave you noticed that there are many brands with the same value? We can order results by two columns. If the results in the first column are identical, the second column will be used to sort them. Let‚Äôs add brandName to our ORDER BY clause.\n\n\nList all brands with rooms smaller than 350 square feet with largest first. Where areas are identical, list brands in alphabetical order.\n\nSELECT * FROM brand WHERE brandMinSqFt &lt; 350 ORDER BY brandMinSqFt DESC, brandName;\n\n\n\n\n\n\n\nNote\n\n\n\nNotice that our results are ordered by brandMinSqFt in descending order (DESC), and alphabetically by brandName (you can add ASC after brandName to get the same results).\n\n\n\n\n\n\n\n\nTip\n\n\n\nLast one more thing. Notice that we use &lt; in this query. WHERE condition can take all the comparison operators: =, !=, &lt;, &gt;, &lt;=, and &gt;=."
  },
  {
    "objectID": "1-single-entity-complete.html#calculated-fields",
    "href": "1-single-entity-complete.html#calculated-fields",
    "title": "Introduction to SQL. Single entity",
    "section": "Calculated Fields",
    "text": "Calculated Fields\nSQL allows calculations directly in queries. Let‚Äôs say we want to convert square feet to square meters in the results (m¬≤ = f¬≤ / 10.764).\n\nSELECT brandName, brandMinSqFt / 10.764 FROM brand;"
  },
  {
    "objectID": "1-single-entity-complete.html#renaming-output-fields",
    "href": "1-single-entity-complete.html#renaming-output-fields",
    "title": "Introduction to SQL. Single entity",
    "section": "Renaming Output Fields",
    "text": "Renaming Output Fields\nThe column name for our calculated field in the results above doesn‚Äôt look nice. To make results clearer, use AS to rename calculated fields (or any other column in your query).\nGet minimum room area in square meters for each brand. Rename the output\n\nSELECT brandName, brandMinSqFt / 10.764 AS brandSqMt FROM brand;\n\nNow the result column will be labeled brandSqMt instead of an anonymous calculation. This new name is called alias."
  },
  {
    "objectID": "1-single-entity-complete.html#extra-practice-cell",
    "href": "1-single-entity-complete.html#extra-practice-cell",
    "title": "Introduction to SQL. Single entity",
    "section": "Extra practice cell",
    "text": "Extra practice cell\n\n\n\n\nThat‚Äôs it for now! üéâ\nEven if it seems like just a little, learning this is already a great achievement!\n\n\n\n\n\n\nRemember, SQL is like having a conversation in English with the database:\n\n‚ÄúShow me everything‚Äù ‚Üí SELECT * FROM table;\n\n‚ÄúGive me only what I need‚Äù ‚Üí SELECT column FROM table;\n\n‚ÄúFilter the results‚Äù ‚Üí WHERE = condition\n\n‚ÄúSort them‚Äù ‚Üí ORDER BY column\n\nWith these basics, you‚Äôre already on your way to mastering SQL!\n\n\n\n\n\n\n\n\n\nImages and GIFs Disclaimer: Some of the images and GIFs used on this website are not owned by me. They are used for educational and illustrative purposes only. All rights belong to their respective owners. If you believe any content violates copyright, please contact me for prompt removal.\n\n\n\n\n\n\n  \n  \n    ¬© 2025. All Rights Reserved.\n  \n  \n\n  \n  \n    Enabled by Dr. Marcin Bartosiak"
  },
  {
    "objectID": "1-single-entity.html#extra-practice-cell",
    "href": "1-single-entity.html#extra-practice-cell",
    "title": "Introduction to SQL. Single entity",
    "section": "Extra practice cell",
    "text": "Extra practice cell\n\n\n\n\nThat‚Äôs it for now! üéâ\nEven if it seems like just a little, learning this is already a great achievement!\n\n\n\n\n\n\nRemember, SQL is like having a conversation in English with the database:\n\n‚ÄúShow me everything‚Äù ‚Üí SELECT * FROM table;\n\n‚ÄúGive me only what I need‚Äù ‚Üí SELECT column FROM table;\n\n‚ÄúFilter the results‚Äù ‚Üí WHERE = condition\n\n‚ÄúSort them‚Äù ‚Üí ORDER BY column\n\nWith these basics, you‚Äôre already on your way to mastering SQL!\n\n\n\n\n\n\n\n\n\nImages and GIFs Disclaimer: Some of the images and GIFs used on this website are not owned by me. They are used for educational and illustrative purposes only. All rights belong to their respective owners. If you believe any content violates copyright, please contact me for prompt removal.\n\n\n\n\n\n\n  \n  \n    ¬© 2025. All Rights Reserved.\n  \n  \n\n  \n  \n    Enabled by Dr. Marcin Bartosiak"
  },
  {
    "objectID": "1-single-entity.html#eliminating-duplicates",
    "href": "1-single-entity.html#eliminating-duplicates",
    "title": "Introduction to SQL. Single entity",
    "section": "Eliminating Duplicates",
    "text": "Eliminating Duplicates\nThe DISTINCT keyword in SQL is used to eliminate duplicate rows from query results, ensuring that only unique values are displayed. This is particularly useful when reporting different possible values for a specific column, such as brand segments.\nRun this query first. Then, modify it to retrieve a list of all unique brand segments without repetition.\n\nSELECT brandSegment FROM brand;"
  },
  {
    "objectID": "1-single-entity-complete.html#eliminating-duplicates",
    "href": "1-single-entity-complete.html#eliminating-duplicates",
    "title": "Introduction to SQL. Single entity",
    "section": "Eliminating Duplicates",
    "text": "Eliminating Duplicates\nThe DISTINCT keyword in SQL is used to eliminate duplicate rows from query results, ensuring that only unique values are displayed. This is particularly useful when reporting different possible values for a specific column, such as brand segments.\nRun this query first. Then, modify it to retrieve a list of all unique brand segments without repetition.\n\nSELECT DISTINCT brandSegment FROM brand;"
  },
  {
    "objectID": "Notes.html",
    "href": "Notes.html",
    "title": "Notes",
    "section": "",
    "text": "In SQL, REGEXP (short for regular expression) is used to match a string against a pattern. It allows you to search for complex patterns in text data. It is often used to perform advanced searches, such as matching substrings, validating formats, or finding specific patterns in a column.\nFor example, the query below lists all brands containing ‚ÄòHotel‚Äô in their name. We don‚Äôt know the exact names. Just that small piece.\nSELECT brandName FROM brand\n        WHERE brandName REGEXP 'hotel';\n\n\n\n\n\n\nNote\n\n\n\nPay attention how the syntax for REGEXP uses the WHERE clause (which is, again, great!ü§© because you already know how to use WHERE).\n\n\nCommon Regular Expression Syntax:\n\n^ : Matches the start of a string.\n$ : Matches the end of a string.\n. : Matches any single character.\n* : Matches 0 or more occurrences of the preceding element.\n+ : Matches 1 or more occurrences of the preceding element.\n[] : Matches any character within the brackets.\n[A-Z] : Matches any upper case letter.\n[a-z] : Matches any lower case letter\n[0-9] : Matches any digit from 0 through to 9.\n\nExamples\nSELECT brandName FROM brand\n        WHERE brandName REGEXP '^H';\nSELECT brandName FROM brand\n        WHERE brandName REGEXP '$or';\nSELECT headquarters FROM lodgingchain\n        WHERE headquarters REGEXP '[united]';\nSELECT headquarters FROM lodgingchain\n        WHERE headquarters REGEXP '[United]';\nSELECT headquarters FROM lodgingchain\n        WHERE headquarters REGEXP '+or';"
  },
  {
    "objectID": "Notes.html#regular-expressions",
    "href": "Notes.html#regular-expressions",
    "title": "Notes",
    "section": "",
    "text": "In SQL, REGEXP (short for regular expression) is used to match a string against a pattern. It allows you to search for complex patterns in text data. It is often used to perform advanced searches, such as matching substrings, validating formats, or finding specific patterns in a column.\nFor example, the query below lists all brands containing ‚ÄòHotel‚Äô in their name. We don‚Äôt know the exact names. Just that small piece.\nSELECT brandName FROM brand\n        WHERE brandName REGEXP 'hotel';\n\n\n\n\n\n\nNote\n\n\n\nPay attention how the syntax for REGEXP uses the WHERE clause (which is, again, great!ü§© because you already know how to use WHERE).\n\n\nCommon Regular Expression Syntax:\n\n^ : Matches the start of a string.\n$ : Matches the end of a string.\n. : Matches any single character.\n* : Matches 0 or more occurrences of the preceding element.\n+ : Matches 1 or more occurrences of the preceding element.\n[] : Matches any character within the brackets.\n[A-Z] : Matches any upper case letter.\n[a-z] : Matches any lower case letter\n[0-9] : Matches any digit from 0 through to 9.\n\nExamples\nSELECT brandName FROM brand\n        WHERE brandName REGEXP '^H';\nSELECT brandName FROM brand\n        WHERE brandName REGEXP '$or';\nSELECT headquarters FROM lodgingchain\n        WHERE headquarters REGEXP '[united]';\nSELECT headquarters FROM lodgingchain\n        WHERE headquarters REGEXP '[United]';\nSELECT headquarters FROM lodgingchain\n        WHERE headquarters REGEXP '+or';"
  },
  {
    "objectID": "2-one-to-many.html",
    "href": "2-one-to-many.html",
    "title": "One-to-Many relationship",
    "section": "",
    "text": "Now that you‚Äôve learned how to model a basic, single-entity database, let‚Äôs explore attributes, which define the characteristics of an entity.\n\n\nAttributes store important details about each record in a table, helping to describe and organize data effectively.\nIn a database, attributes can be classified based on whether they require a value. A required attribute must always have a value and cannot be left empty, while an optional attribute can be left empty (NULL).\n\n\n\n\n\n\nWarning\n\n\n\nWe use NULL to indicate missing values. Missing values can occur for different reasons, such as an existing attribute without data (e.g., a middle name) or an inapplicable condition (e.g., an apartment number for a house address).\nDon‚Äôt confuse NULL values with blank or zero.\nMultiple meanings:\n\nUnknown data\nInapplicable data\nNo value supplied\nValue undefined\n\nWe will come back to NULL values later.\n\n\nEach attribute has a domain, which defines the set of possible values it can take.\n\n\n\n\n\n\nTip\n\n\n\nA domain is the set of possible values that an attribute can have. Think of it like a rule that defines what kind of data is allowed in a column. For example, if you have an attribute ‚ÄúAge,‚Äù its domain might be whole numbers between 0 and 120. If you have a ‚ÄúCountry‚Äù attribute, its domain would be a list of valid country names. Domains help keep data consistent and prevent errors, like entering text in a column meant for numbers.\n\n\nTo uniquely identify each record, identifiers are used‚Äîthese are attributes that hold unique values for each instance. In relational databases, the primary key serves as this unique identifier.\nSometimes, a composite identifier is needed, which combines two or more attributes to uniquely identify a record (e.g., a combination of Course ID and Student ID to track enrollments).\nAttributes can be classified into different types:\n\nComposite attribute: Attribute that can be subdivided to yield additional attributes\nSimple attribute: Attribute that cannot be subdivided\nDerived attribute: Attribute whose value is calculated from other attributes\n\nDerived using an algorithm (i.e., Yield = Dividend * Quantity)\nSometimes called ‚Äòcalculated fields‚Äô\n\nSingle-valued attribute: Attribute that holds only a single value\nMultivalued attributes: Attributes that hold many values\n\nUnderstanding these attribute types is essential for designing efficient databases that accurately represent real-world scenarios.\n\n\n\nThink of the data scientists database we modeled last week.\n\n\n\n\n\nHow would the model change, if our data scientist could get a second degree? Or multiple certificates?\nA multivalued attribute is an attribute that can have multiple values for a single entity. For example, an employee might have multiple phone numbers or an author might write multiple books. In database design, multivalued attributes should be handled properly to maintain data consistency. One approach is to create separate attributes for each component of the multivalued attribute (e.g., Phone_1, Phone_2). A better approach is to create a new entity that holds the multiple values, linking it to the original entity through a relationship (e.g., an Employee_Phone table linked to an Employee table). This ensures better organization, eliminates redundancy, and improves data integrity.\nNow, try to apply that knowledge to our data scientists database.\n\n\n\nThere is one more new thing in the model above. Habe you noticed that the entities are ‚Äúlinked‚Äù. These are entity relationships.\nIn database design, relationships define how different entities (tables) are associated with one another. These relationships follow business rules, which describe how entities interact based on real-world scenarios. For example:\n\na customer can place many orders\na team can have many players.\n\nThese relationships help ensure that data is properly structured and connected.\nA key characteristic of relationships is that they are bi-directional, meaning they should always be read both ways. For example, while a customer can place many orders, each order is placed by only one customer. Understanding relationships in both directions is crucial for designing a clear and logical database structure.\nProperly defining entity relationships improves data integrity, reduces redundancy, and enhances query efficiency. By embedding relationships directly into the database design, businesses can enforce rules and constraints that reflect real-world operations, making data retrieval and management more efficient.\nConsider our brand table from last week. Let‚Äôs say we want to track also info about lodging chains.\n\n\n\n\n\nSince we have multiple hotels owned by the same chain, storing this information in one table would create redundancies.\nIt is better to create a new entity, and specify the relationship beween the two.\n\n\n\n\n\n\n\n\nThis particular case of relationship is called one-to-many relationship.\nA one-to-many relationship means that one record in a table is linked to many records in another table. Like in our case, one lodging chain can own many hotels, but each hotel belongs to only one chain. See the example of Hilton Hotels:\n\n\n\n\n\nThis type of relationship helps organize data efficiently, avoiding duplication and ensuring consistency.\nLet‚Äôs go back to our stock portfolio table for a second. Remember that it contains stock market data that is used by an investment firm dealing with international commodities and agricultural products.\n\n\n\n\n\n\n\nStock market data\n\n\nWe said that there might be several problems (called anomalies) with it:\n\nInsertion anomalies occur when adding new data is difficult due to missing dependencies.\nUpdate anomalies lead to inconsistencies when changes must be made in multiple places.\nDeletion anomalies cause unintended data loss when removing a record also removes critical information.\n\nLet‚Äôs try to design a database to store our stock portfolio data!\n\n\nDevelop a data model for Marriott International to keep track of relevant information about its portfolio of hotels\nFocus on the assets, not on customers, employees, or transactions\n\n\n\n\n\n\n\n\nHierarchical relationships occur frequently in databases and follow a one-to-many structure, where one entity has multiple related entities beneath it. This structure is similar to a tree, where a parent node can have multiple child nodes, but each child has only one parent. For example, in a company database, one manager oversees many employees, but each employee has only one direct manager. Similarly, a firm can have many divisions, a division can have many departments, and a department can have many sections (see the example below).\nThese relationships help organize data logically and efficiently, making it easier to navigate and retrieve information.\n\n\n\n\n\n\n\n\n\nSo far, we covered a lot of abstract terms like entity, instances, attributes etc. As you correctly notice, we could simply say table, row, and columns instead. However, there is a good reason for using these abstract terms.\nUnderstanding entities, instances, and attributes rather than just tables, rows, and columns is important because it helps us focus on the conceptual meaning of the data rather than just its storage format.\n\nEntity vs.¬†Table: An entity represents a real-world object or concept (like a ‚ÄúCustomer‚Äù or ‚ÄúProduct‚Äù), while a table is just how we store data in a database. Thinking in terms of entities helps us design better database models before deciding how to implement them.\n\nInstance vs.¬†Row: An instance is a specific example of an entity (e.g., a particular customer, ‚ÄúJohn Doe‚Äù). A row is how that instance is stored in a table. Thinking in terms of instances makes it easier to understand relationships between data.\n\nAttribute vs.¬†Column: An attribute describes a characteristic of an entity (e.g., a customer‚Äôs ‚ÄúName‚Äù or ‚ÄúEmail‚Äù). A column is just where this data is stored. By focusing on attributes first, we ensure that all necessary information is captured properly.\n\nBy using these abstract concepts, we can design flexible and well-structured databases before deciding how to implement them in a specific DBMS.\n\n\nWhen designing a relational database, entities and their relationships are translated into tables and columns. The process follows these key steps:\n\nEach entity becomes a table\n\nThe entity name becomes the table name\n\nEach attribute becomes a column\n\n\n\n\nIn a one-to-many relationship, we structure the tables as follows:\n\nAdd a column to the table on the ‚Äúmany‚Äù side of the relationship\n\nStore the identifier of the ‚Äúone‚Äù side in this added column\n\nThis ensures proper linkage between related data while maintaining database integrity.\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nThe conceptual database model uses a parsimonious notation, meaning that extra attributes do not need to be explicitly modeled, as they can be inferred from the relationship.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEnsuring data integrity is crucial in relational databases. Entity integrity maintains the uniqueness and validity of primary keys, while referential integrity ensures that foreign keys correctly reference existing primary keys. These rules help prevent inconsistencies and maintain reliable relationships between tables.\n\n\n\nA primary key must be unique.\n\nPrimary keys can never have NULL values.\n\n\n\n\n\nFor every non-null value of a foreign key, there must be a matching primary key with that value.\n\nExample: For every value of chainID in the brand table, there must be a corresponding value of chainID in the lodgingChain table.\n\nA primary key must exist before a foreign key can be defined.\n\n##Implementable database model\nRemember these beatiful drawings?\n\n\n\n\n\n\n\n\nHand-drawn crowfoot model\n\n\n\n\n\n\n\nER diagram\n\n\n\n\n\n\nFigure¬†1\n\n\n\nSo far, we mainly focused on a conceptual database model. But there is also implementational (or logical) database model.\nThe conceptual database model focuses on the high-level structure of the data, emphasizing entities, relationships, and constraints without considering how the data will be physically stored. It serves as a blueprint for understanding data requirements and is independent of any specific database management system (DBMS). On the other hand, the implementational database model translates the conceptual design into a format that a DBMS can use, incorporating tables, columns, keys, and constraints based on a specific database system. While the conceptual model is abstract and business-oriented, the implementational model is detailed and technical, bridging the gap between design and actual database implementation.\nWe will learn how to design such implementational models in few weeks. First, let‚Äôs learn how to read them.\n\n\n\n\n\n\n\n\n\n\n\n\n\nAn implementational database model\n\n\n\n\n\n\n\n\n\n\n\nWorkbench symbolism\n\n\n\n\n\n\n\n\n\nIn database modeling, identifying and non-identifying relationships refer to how entities are related to one another. An identifying relationship occurs when the child entity‚Äôs existence depends on the parent entity, and the child entity‚Äôs primary key includes the parent‚Äôs primary key. This often happens in cases where the child cannot exist without the parent (e.g., an order item cannot exist without an order). In contrast, a non-identifying relationship occurs when the child entity can exist independently of the parent entity, and the child‚Äôs primary key does not include the parent‚Äôs primary key. Here, the relationship is more loosely coupled (e.g., a customer can exist without an address).\nIn the implementational model, the relationships will look slightly differnt.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nIn the conceptual model, we will have to add a small plus (+) over a relationship, to mark the identifying relationship."
  },
  {
    "objectID": "2-one-to-many.html#attributes",
    "href": "2-one-to-many.html#attributes",
    "title": "One-to-Many relationship",
    "section": "",
    "text": "Attributes store important details about each record in a table, helping to describe and organize data effectively.\nIn a database, attributes can be classified based on whether they require a value. A required attribute must always have a value and cannot be left empty, while an optional attribute can be left empty (NULL).\n\n\n\n\n\n\nWarning\n\n\n\nWe use NULL to indicate missing values. Missing values can occur for different reasons, such as an existing attribute without data (e.g., a middle name) or an inapplicable condition (e.g., an apartment number for a house address).\nDon‚Äôt confuse NULL values with blank or zero.\nMultiple meanings:\n\nUnknown data\nInapplicable data\nNo value supplied\nValue undefined\n\nWe will come back to NULL values later.\n\n\nEach attribute has a domain, which defines the set of possible values it can take.\n\n\n\n\n\n\nTip\n\n\n\nA domain is the set of possible values that an attribute can have. Think of it like a rule that defines what kind of data is allowed in a column. For example, if you have an attribute ‚ÄúAge,‚Äù its domain might be whole numbers between 0 and 120. If you have a ‚ÄúCountry‚Äù attribute, its domain would be a list of valid country names. Domains help keep data consistent and prevent errors, like entering text in a column meant for numbers.\n\n\nTo uniquely identify each record, identifiers are used‚Äîthese are attributes that hold unique values for each instance. In relational databases, the primary key serves as this unique identifier.\nSometimes, a composite identifier is needed, which combines two or more attributes to uniquely identify a record (e.g., a combination of Course ID and Student ID to track enrollments).\nAttributes can be classified into different types:\n\nComposite attribute: Attribute that can be subdivided to yield additional attributes\nSimple attribute: Attribute that cannot be subdivided\nDerived attribute: Attribute whose value is calculated from other attributes\n\nDerived using an algorithm (i.e., Yield = Dividend * Quantity)\nSometimes called ‚Äòcalculated fields‚Äô\n\nSingle-valued attribute: Attribute that holds only a single value\nMultivalued attributes: Attributes that hold many values\n\nUnderstanding these attribute types is essential for designing efficient databases that accurately represent real-world scenarios."
  },
  {
    "objectID": "2-one-to-many.html#multivalued-attributes",
    "href": "2-one-to-many.html#multivalued-attributes",
    "title": "One-to-Many relationship",
    "section": "",
    "text": "Think of the data scientists database we modeled last week.\n\n\n\n\n\nHow would the model change, if our data scientist could get a second degree? Or multiple certificates?\nA multivalued attribute is an attribute that can have multiple values for a single entity. For example, an employee might have multiple phone numbers or an author might write multiple books. In database design, multivalued attributes should be handled properly to maintain data consistency. One approach is to create separate attributes for each component of the multivalued attribute (e.g., Phone_1, Phone_2). A better approach is to create a new entity that holds the multiple values, linking it to the original entity through a relationship (e.g., an Employee_Phone table linked to an Employee table). This ensures better organization, eliminates redundancy, and improves data integrity.\nNow, try to apply that knowledge to our data scientists database."
  },
  {
    "objectID": "2-one-to-many.html#entity-relaionship",
    "href": "2-one-to-many.html#entity-relaionship",
    "title": "One-to-Many relationship",
    "section": "",
    "text": "There is one more new thing in the model above. Habe you noticed that the entities are ‚Äúlinked‚Äù. These are entity relationships.\nIn database design, relationships define how different entities (tables) are associated with one another. These relationships follow business rules, which describe how entities interact based on real-world scenarios. For example:\n\na customer can place many orders\na team can have many players.\n\nThese relationships help ensure that data is properly structured and connected.\nA key characteristic of relationships is that they are bi-directional, meaning they should always be read both ways. For example, while a customer can place many orders, each order is placed by only one customer. Understanding relationships in both directions is crucial for designing a clear and logical database structure.\nProperly defining entity relationships improves data integrity, reduces redundancy, and enhances query efficiency. By embedding relationships directly into the database design, businesses can enforce rules and constraints that reflect real-world operations, making data retrieval and management more efficient.\nConsider our brand table from last week. Let‚Äôs say we want to track also info about lodging chains.\n\n\n\n\n\nSince we have multiple hotels owned by the same chain, storing this information in one table would create redundancies.\nIt is better to create a new entity, and specify the relationship beween the two."
  },
  {
    "objectID": "2-one-to-many.html#one-to-many-relationship",
    "href": "2-one-to-many.html#one-to-many-relationship",
    "title": "One-to-Many relationship",
    "section": "",
    "text": "This particular case of relationship is called one-to-many relationship.\nA one-to-many relationship means that one record in a table is linked to many records in another table. Like in our case, one lodging chain can own many hotels, but each hotel belongs to only one chain. See the example of Hilton Hotels:\n\n\n\n\n\nThis type of relationship helps organize data efficiently, avoiding duplication and ensuring consistency.\nLet‚Äôs go back to our stock portfolio table for a second. Remember that it contains stock market data that is used by an investment firm dealing with international commodities and agricultural products.\n\n\n\n\n\n\n\nStock market data\n\n\nWe said that there might be several problems (called anomalies) with it:\n\nInsertion anomalies occur when adding new data is difficult due to missing dependencies.\nUpdate anomalies lead to inconsistencies when changes must be made in multiple places.\nDeletion anomalies cause unintended data loss when removing a record also removes critical information.\n\nLet‚Äôs try to design a database to store our stock portfolio data!\n\n\nDevelop a data model for Marriott International to keep track of relevant information about its portfolio of hotels\nFocus on the assets, not on customers, employees, or transactions\n\n\n\n\n\n\n\n\nHierarchical relationships occur frequently in databases and follow a one-to-many structure, where one entity has multiple related entities beneath it. This structure is similar to a tree, where a parent node can have multiple child nodes, but each child has only one parent. For example, in a company database, one manager oversees many employees, but each employee has only one direct manager. Similarly, a firm can have many divisions, a division can have many departments, and a department can have many sections (see the example below).\nThese relationships help organize data logically and efficiently, making it easier to navigate and retrieve information."
  },
  {
    "objectID": "2-one-to-many.html#mapping-to-a-relational-database",
    "href": "2-one-to-many.html#mapping-to-a-relational-database",
    "title": "One-to-Many relationship",
    "section": "",
    "text": "So far, we covered a lot of abstract terms like entity, instances, attributes etc. As you correctly notice, we could simply say table, row, and columns instead. However, there is a good reason for using these abstract terms.\nUnderstanding entities, instances, and attributes rather than just tables, rows, and columns is important because it helps us focus on the conceptual meaning of the data rather than just its storage format.\n\nEntity vs.¬†Table: An entity represents a real-world object or concept (like a ‚ÄúCustomer‚Äù or ‚ÄúProduct‚Äù), while a table is just how we store data in a database. Thinking in terms of entities helps us design better database models before deciding how to implement them.\n\nInstance vs.¬†Row: An instance is a specific example of an entity (e.g., a particular customer, ‚ÄúJohn Doe‚Äù). A row is how that instance is stored in a table. Thinking in terms of instances makes it easier to understand relationships between data.\n\nAttribute vs.¬†Column: An attribute describes a characteristic of an entity (e.g., a customer‚Äôs ‚ÄúName‚Äù or ‚ÄúEmail‚Äù). A column is just where this data is stored. By focusing on attributes first, we ensure that all necessary information is captured properly.\n\nBy using these abstract concepts, we can design flexible and well-structured databases before deciding how to implement them in a specific DBMS.\n\n\nWhen designing a relational database, entities and their relationships are translated into tables and columns. The process follows these key steps:\n\nEach entity becomes a table\n\nThe entity name becomes the table name\n\nEach attribute becomes a column\n\n\n\n\nIn a one-to-many relationship, we structure the tables as follows:\n\nAdd a column to the table on the ‚Äúmany‚Äù side of the relationship\n\nStore the identifier of the ‚Äúone‚Äù side in this added column\n\nThis ensures proper linkage between related data while maintaining database integrity.\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nThe conceptual database model uses a parsimonious notation, meaning that extra attributes do not need to be explicitly modeled, as they can be inferred from the relationship.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEnsuring data integrity is crucial in relational databases. Entity integrity maintains the uniqueness and validity of primary keys, while referential integrity ensures that foreign keys correctly reference existing primary keys. These rules help prevent inconsistencies and maintain reliable relationships between tables.\n\n\n\nA primary key must be unique.\n\nPrimary keys can never have NULL values.\n\n\n\n\n\nFor every non-null value of a foreign key, there must be a matching primary key with that value.\n\nExample: For every value of chainID in the brand table, there must be a corresponding value of chainID in the lodgingChain table.\n\nA primary key must exist before a foreign key can be defined.\n\n##Implementable database model\nRemember these beatiful drawings?\n\n\n\n\n\n\n\n\nHand-drawn crowfoot model\n\n\n\n\n\n\n\nER diagram\n\n\n\n\n\n\nFigure¬†1\n\n\n\nSo far, we mainly focused on a conceptual database model. But there is also implementational (or logical) database model.\nThe conceptual database model focuses on the high-level structure of the data, emphasizing entities, relationships, and constraints without considering how the data will be physically stored. It serves as a blueprint for understanding data requirements and is independent of any specific database management system (DBMS). On the other hand, the implementational database model translates the conceptual design into a format that a DBMS can use, incorporating tables, columns, keys, and constraints based on a specific database system. While the conceptual model is abstract and business-oriented, the implementational model is detailed and technical, bridging the gap between design and actual database implementation.\nWe will learn how to design such implementational models in few weeks. First, let‚Äôs learn how to read them.\n\n\n\n\n\n\n\n\n\n\n\n\n\nAn implementational database model\n\n\n\n\n\n\n\n\n\n\n\nWorkbench symbolism\n\n\n\n\n\n\n\n\n\nIn database modeling, identifying and non-identifying relationships refer to how entities are related to one another. An identifying relationship occurs when the child entity‚Äôs existence depends on the parent entity, and the child entity‚Äôs primary key includes the parent‚Äôs primary key. This often happens in cases where the child cannot exist without the parent (e.g., an order item cannot exist without an order). In contrast, a non-identifying relationship occurs when the child entity can exist independently of the parent entity, and the child‚Äôs primary key does not include the parent‚Äôs primary key. Here, the relationship is more loosely coupled (e.g., a customer can exist without an address).\nIn the implementational model, the relationships will look slightly differnt.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nIn the conceptual model, we will have to add a small plus (+) over a relationship, to mark the identifying relationship."
  },
  {
    "objectID": "2-one-to-many.html#aggregate-functions",
    "href": "2-one-to-many.html#aggregate-functions",
    "title": "One-to-Many relationship",
    "section": "Aggregate functions",
    "text": "Aggregate functions\nIn SQL aggregate functions help you combine lots of data into one result. These are like math operations that work on whole columns of information instead of just single values.\nHere are the main aggregate functions:\n\nCOUNT(): Tells you how many items are in your data (like counting how many customers you have)\nSUM(): Adds up numbers (like finding your total sales for the month)\nAVG(): Calculates the average (like finding the typical price of products)\nMIN(): Finds the smallest value (like identifying your cheapest item)\nMAX(): Finds the largest value (like identifying your most expensive item)\n\nThese functions are super helpful when you want to get quick summaries from your database without looking at every single row of information. You simply add the to your query follwoing this pattern:\n\nSELECT FUNCTION(columnName) FROM tableName;\n\nLet‚Äôs test them in our brand table!\nFind the average hotel room square footage for all brands.\n\n\n\nWhat is the area of the largest hotel room specification in the DB? Rename as ‚ÄúBiggest Room‚Äù\n\n\n\nHow many total brands do we have data for?\n\n\n\nWhat is the total number of hotel rooms? - All rooms of all chains.\n\n\n\n\n\n\nTip\n\n\n\nThe solve this task, you will have to query different table‚Ä¶"
  },
  {
    "objectID": "2-one-to-many.html#joining-tables",
    "href": "2-one-to-many.html#joining-tables",
    "title": "One-to-Many relationship",
    "section": "JOINing tables",
    "text": "JOINing tables\nJoining tables in SQL allows you to combine related data from different tables into a single result set. The simplest way to join tables is using the WHERE clause with the equals operator (which is great!ü§© because you already know how to use WHERE).\nHere‚Äôs how it works:\n\nBasic JOIN using WHERE: You list both tables in the FROM clause and use WHERE to match related columns\nExample syntax: SELECT * FROM brand, lodgingchain WHERE brand.chainID = lodgingchain.chainID;\nHow it works: This tells SQL to match each row from the first table with rows from the second table where the specified columns have the same value\nResult: Only rows where the join condition is true appear in your results\n\nThis approach creates what‚Äôs known as an ‚Äúinner join‚Äù - it only shows data where there are matches between both tables. We will explore more powerful ways to join tables in our next session.\nTry it yourself!\n\nSELECT * FROM brand, lodgingchain \n  WHERE brand.chainID = lodgingchain.chainID;\n\n\nExercise\nReport the headquarter location of each brand‚Äôs parent chain.Order by brand name.\n\n\n\n\n\n\n\n\n\nWatch out for cross-products\n\n\n\nA cross-product in SQL occurs when you join two tables without specifying a join condition. This creates a result set containing every possible combination of rows from both tables. For example, if you run SELECT * FROM brand, lodgingchain; without a WHERE clause, each row from the brand table will be paired with every row from the lodgingchain table. If your brand table has 100 rows and your lodgingchain table has 500 rows, you‚Äôll end up with 50,000 rows in your result set.\nCross-products are rarely useful in practical applications and can cause serious performance problems with large tables, which is why properly specifying join conditions with WHERE clauses is essential for efficient queries.\n\nSELECT * FROM brand, lodgingchain;\n\n\n\n\n\n\n\n\n\nThe risk of homonyms\n\n\n\nHomonyms in database design‚Äîparticularly columns with identical names across different tables‚Äîcreate risks. When fields like ‚Äúid‚Äù or ‚Äústatus‚Äù appear in multiple tables but represent different concepts, developers may mistakenly join these columns or apply incorrect business logic. This confusion leads to flawed queries, unpredictable results, and potential data corruption.\nTo prevent these issues, best practices include using descriptive, context-specific column names (e.g., ‚Äúcustomer_id‚Äù instead of just ‚Äúid‚Äù), implementing consistent naming conventions, and maintaining clear documentation of each column‚Äôs specific meaning and purpose.\nHowever, sometimes you may find a database with homonyms. Let‚Äôs take a look at our nation-stock database. Try to run the query below. What is the result? How would you change the query to get the correct result?\n\n\n\n\n\n\nSELECT * FROM stock, nation\n    WHERE natcode = natcode;"
  },
  {
    "objectID": "2-one-to-many.html#grouping-the-results",
    "href": "2-one-to-many.html#grouping-the-results",
    "title": "One-to-Many relationship",
    "section": "Grouping the results",
    "text": "Grouping the results\nThe GROUP BY clause in SQL allows you to organize similar data into groups and perform aggregate functions on each group separately rather than on the entire table.\nHere‚Äôs how it works:\n\nBasic purpose: Groups rows that have the same values in specified columns\nTypical usage: Used with aggregate functions (COUNT, SUM, AVG, etc.) to perform calculations on each group\nExample syntax: SELECT chainHQ, COUNT(*) FROM lodgingChaing GROUP BY chainHQ;\nResult: One row for each unique value in the grouped column(s)\nMultiple columns: You can group by multiple columns like GROUP BY department, job_title\nCommon requirement: Generally, columns in the SELECT list must either be part of the GROUP BY clause or used within an aggregate function\n\n\nSELECT headquarters, COUNT(*) FROM lodgingchain \n  GROUP BY headquarters;\n\nGROUP BY is essential for summarizing data and generating reports that show totals, averages, or counts for different categories within your data.\n\nExercise\nReport number of brands in each chain by chain name (not chainID).\n\n\n\n\n\nHAVING\nIn SQL, the HAVING clause is used to filter the results of a GROUP BY query. It is like WHERE clause for grouped results. However, HAVING allows you to filter groups based on aggregate functions (like COUNT(), SUM(), AVG(), etc.), which cannot be done using the WHERE clause.\n\n\n\n\n\n\nNote\n\n\n\nThe WHERE clause filters rows before they are grouped, while HAVING filters groups after the aggregation is done.\n\n\nConsider the previous example. We can easily filter the results and keep only, for example, countries with at least 3 headquarters.\n\nSELECT headquarters, COUNT(*) FROM lodgingchain \n  GROUP BY headquarters\n  HAVING COUNT(*) &gt;= 3;\n\n\nExercise\nReport the average room area and number of brands for all chains that own more than one brand"
  },
  {
    "objectID": "2-one-to-many.html#subqueries",
    "href": "2-one-to-many.html#subqueries",
    "title": "One-to-Many relationship",
    "section": "Subqueries",
    "text": "Subqueries\nA subquery is a query that is nested inside another query. It is used to retrieve data that will be used in the main query for filtering, selecting, or computing results. Subqueries can be placed in the SELECT, FROM, or WHERE clauses of a SQL query.\nThere are two main types of subqueries: 1. Scalar subqueries: Return a single value. 2. Table subqueries: Return multiple rows and columns.\nFor now, we will only focus on scalar subqueries.\nWhen to Use Subqueries:\n\nWhen you need to compare a value in a column with a result from another query.\nWhen you want to perform an operation on a subset of data before using it in the main query.\nWhen a join is not possible or too complex to use.\n\n\nExample of a Subquery in the WHERE Clause:\nReport the name of all brands headquartered in the same country as the Grand Hyatt.\n\nSELECT brandName FROM lodgingChain, brand \n  WHERE lodgingChain.chainID = brand.chainID \n  AND headquarters IN (SELECT headquarters \n                FROM lodgingChain, brand\n                WHERE lodgingChain.chainID = brand.chainID \n                AND brandName='Grand Hyatt');\n\nA subquery in the WHERE clause can be used to filter results based on data from another table. You can run the subquery as a separate query and see its results.\n\nSELECT headquarters FROM lodgingChain, brand\n  WHERE lodgingChain.chainID = brand.chainID \n  AND brandName='Grand Hyatt'\n\n\n\nExercise\nReport all data about the oldest chain with worldwide presence (i.e., founded earliest)"
  },
  {
    "objectID": "2-one-to-many.html#extra-practice-cell",
    "href": "2-one-to-many.html#extra-practice-cell",
    "title": "One-to-Many relationship",
    "section": "Extra practice cell",
    "text": "Extra practice cell\n\n\n\n\n\n\n\n\n\n\nThat‚Äôs it for now, but this is just the beginning! üéâ\nThere‚Äôs so much more to explore. With each step, you‚Äôll unlock more powerful ways to interact with databases and make sense of data. Keep practicing, stay curious, and get ready for even more exciting topics ahead!\n\n\n\n\n\n\n\n\nImages and GIFs Disclaimer: Some of the images and GIFs used on this website are not owned by me. They are used for educational and illustrative purposes only. All rights belong to their respective owners. If you believe any content violates copyright, please contact me for prompt removal.\n\n\n\n\n\n\n  \n  \n    ¬© 2025. All Rights Reserved.\n  \n  \n\n  \n  \n    Enabled by Dr. Marcin Bartosiak"
  },
  {
    "objectID": "Homework1-solution.html",
    "href": "Homework1-solution.html",
    "title": "Homework 1 solution",
    "section": "",
    "text": "The following queries use the classicmodels schema. All queries use the products table.\n\n\n\n\n\n\n\nPrepare a list of products sorted by product name in descending order.\n\nSELECT * FROM products \n ORDER BY productName DESC;\n\nList the product names and their quantity available from high to low?\n\nSELECT productName, quantityInStock FROM products\n ORDER BY quantityInStock DESC;\n\nReport the MSRP for the products in ‚ÄúVintage Cars‚Äù category?\n\nSELECT MSRP FROM products\n WHERE productLine = 'Vintage Cars';    \n\nReport the product(s) with the buy price of 48.81.\n\nSELECT * FROM products\n WHERE buyPrice = 48.81;   \n\nReport those products with the price greater than 70.\n\nSELECT * FROM products\n WHERE buyPrice &gt; 70;    \n\nWhich products have product scale ratio 1:10 and 1:72?\n\nSELECT * FROM products\n WHERE productScale IN ('1:10', '1:72');    \n\nList the product names except the ones in the Planes and Ships category.\n\nSELECT productName FROM products\n WHERE productLine NOT IN ('Planes', 'Ships');   \n\nReport the names of products excluding Motorcycles and Classic Cars.\n\nSELECT productName FROM products\n WHERE productLine NOT IN ('Motorcycles', 'Classic Cars');    \n\nReport the products having MSRP greater than 110.\n\nSELECT * FROM products\n WHERE MSRP &gt; 110;\n\nList the product vendors in ascending alphabetical order.\n\nSELECT DISTINCT productVendor FROM products\n ORDER BY productVendor ASC; \n\n\n\n\n\n\n\n\nTip\n\n\n\nASC is not obligatory. By default ORDER BY is asceding.\n\n\n\n\n\n  \n  \n    ¬© 2025. All Rights Reserved.\n  \n  \n\n  \n  \n    Enabled by Dr. Marcin Bartosiak"
  },
  {
    "objectID": "Homework1-solution.html#sql---homework-1---solution",
    "href": "Homework1-solution.html#sql---homework-1---solution",
    "title": "Homework 1 solution",
    "section": "",
    "text": "The following queries use the classicmodels schema. All queries use the products table.\n\n\n\n\n\n\n\nPrepare a list of products sorted by product name in descending order.\n\nSELECT * FROM products \n ORDER BY productName DESC;\n\nList the product names and their quantity available from high to low?\n\nSELECT productName, quantityInStock FROM products\n ORDER BY quantityInStock DESC;\n\nReport the MSRP for the products in ‚ÄúVintage Cars‚Äù category?\n\nSELECT MSRP FROM products\n WHERE productLine = 'Vintage Cars';    \n\nReport the product(s) with the buy price of 48.81.\n\nSELECT * FROM products\n WHERE buyPrice = 48.81;   \n\nReport those products with the price greater than 70.\n\nSELECT * FROM products\n WHERE buyPrice &gt; 70;    \n\nWhich products have product scale ratio 1:10 and 1:72?\n\nSELECT * FROM products\n WHERE productScale IN ('1:10', '1:72');    \n\nList the product names except the ones in the Planes and Ships category.\n\nSELECT productName FROM products\n WHERE productLine NOT IN ('Planes', 'Ships');   \n\nReport the names of products excluding Motorcycles and Classic Cars.\n\nSELECT productName FROM products\n WHERE productLine NOT IN ('Motorcycles', 'Classic Cars');    \n\nReport the products having MSRP greater than 110.\n\nSELECT * FROM products\n WHERE MSRP &gt; 110;\n\nList the product vendors in ascending alphabetical order.\n\nSELECT DISTINCT productVendor FROM products\n ORDER BY productVendor ASC; \n\n\n\n\n\n\n\n\nTip\n\n\n\nASC is not obligatory. By default ORDER BY is asceding.\n\n\n\n\n\n  \n  \n    ¬© 2025. All Rights Reserved.\n  \n  \n\n  \n  \n    Enabled by Dr. Marcin Bartosiak"
  },
  {
    "objectID": "2-one-to-many-complete.html",
    "href": "2-one-to-many-complete.html",
    "title": "One-to-Many relationship",
    "section": "",
    "text": "Now that you‚Äôve learned how to model a basic, single-entity database, let‚Äôs explore attributes, which define the characteristics of an entity.\n\n\nAttributes store important details about each record in a table, helping to describe and organize data effectively.\nIn a database, attributes can be classified based on whether they require a value. A required attribute must always have a value and cannot be left empty, while an optional attribute can be left empty (NULL).\n\n\n\n\n\n\nWarning\n\n\n\nWe use NULL to indicate missing values. Missing values can occur for different reasons, such as an existing attribute without data (e.g., a middle name) or an inapplicable condition (e.g., an apartment number for a house address).\nDon‚Äôt confuse NULL values with blank or zero.\nMultiple meanings:\n\nUnknown data\nInapplicable data\nNo value supplied\nValue undefined\n\nWe will come back to NULL values later.\n\n\nEach attribute has a domain, which defines the set of possible values it can take.\n\n\n\n\n\n\nTip\n\n\n\nA domain is the set of possible values that an attribute can have. Think of it like a rule that defines what kind of data is allowed in a column. For example, if you have an attribute ‚ÄúAge,‚Äù its domain might be whole numbers between 0 and 120. If you have a ‚ÄúCountry‚Äù attribute, its domain would be a list of valid country names. Domains help keep data consistent and prevent errors, like entering text in a column meant for numbers.\n\n\nTo uniquely identify each record, identifiers are used‚Äîthese are attributes that hold unique values for each instance. In relational databases, the primary key serves as this unique identifier.\nSometimes, a composite identifier is needed, which combines two or more attributes to uniquely identify a record (e.g., a combination of Course ID and Student ID to track enrollments).\nAttributes can be classified into different types:\n\nComposite attribute: Attribute that can be subdivided to yield additional attributes\nSimple attribute: Attribute that cannot be subdivided\nDerived attribute: Attribute whose value is calculated from other attributes\n\nDerived using an algorithm (i.e., Yield = Dividend * Quantity)\nSometimes called ‚Äòcalculated fields‚Äô\n\nSingle-valued attribute: Attribute that holds only a single value\nMultivalued attributes: Attributes that hold many values\n\nUnderstanding these attribute types is essential for designing efficient databases that accurately represent real-world scenarios.\n\n\n\nThink of the data scientists database we modeled last week.\n\n\n\n\n\nHow would the model change, if our data scientist could get a second degree? Or multiple certificates?\n\n\n\n\n\n\nNote\n\n\n\n\n\n\n\n\n\n\n\n\n\nA multivalued attribute is an attribute that can have multiple values for a single entity. For example, an employee might have multiple phone numbers or an author might write multiple books. In database design, multivalued attributes should be handled properly to maintain data consistency. One approach is to create separate attributes for each component of the multivalued attribute (e.g., Phone_1, Phone_2). A better approach is to create a new entity that holds the multiple values, linking it to the original entity through a relationship (e.g., an Employee_Phone table linked to an Employee table). This ensures better organization, eliminates redundancy, and improves data integrity.\nNow, try to apply that knowledge to our data scientists database.\n\n\n\n\n\n\nNote\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThere is one more new thing in the model above. Habe you noticed that the entities are ‚Äúlinked‚Äù. These are entity relationships.\nIn database design, relationships define how different entities (tables) are associated with one another. These relationships follow business rules, which describe how entities interact based on real-world scenarios. For example:\n\na customer can place many orders\na team can have many players.\n\nThese relationships help ensure that data is properly structured and connected.\nA key characteristic of relationships is that they are bi-directional, meaning they should always be read both ways. For example, while a customer can place many orders, each order is placed by only one customer. Understanding relationships in both directions is crucial for designing a clear and logical database structure.\nProperly defining entity relationships improves data integrity, reduces redundancy, and enhances query efficiency. By embedding relationships directly into the database design, businesses can enforce rules and constraints that reflect real-world operations, making data retrieval and management more efficient.\nConsider our brand table from last week. Let‚Äôs say we want to track also info about lodging chains.\n\n\n\n\n\nSince we have multiple hotels owned by the same chain, storing this information in one table would create redundancies.\nIt is better to create a new entity, and specify the relationship beween the two.\n\n\n\n\n\n\n\n\nThis particular case of relationship is called one-to-many relationship.\nA one-to-many relationship means that one record in a table is linked to many records in another table. Like in our case, one lodging chain can own many hotels, but each hotel belongs to only one chain. See the example of Hilton Hotels:\n\n\n\n\n\nThis type of relationship helps organize data efficiently, avoiding duplication and ensuring consistency.\nLet‚Äôs go back to our stock portfolio table for a second. Remember that it contains stock market data that is used by an investment firm dealing with international commodities and agricultural products.\n\n\n\n\n\n\n\nStock market data\n\n\nWe said that there might be several problems (called anomalies) with it:\n\nInsertion anomalies occur when adding new data is difficult due to missing dependencies.\nUpdate anomalies lead to inconsistencies when changes must be made in multiple places.\nDeletion anomalies cause unintended data loss when removing a record also removes critical information.\n\nLet‚Äôs try to design a database to store our stock portfolio data!\n\n\n\n\n\n\nNote\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDevelop a data model for Marriott International to keep track of relevant information about its portfolio of hotels\nFocus on the assets, not on customers, employees, or transactions\n\n\n\n\n\n\n\n\nHierarchical relationships occur frequently in databases and follow a one-to-many structure, where one entity has multiple related entities beneath it. This structure is similar to a tree, where a parent node can have multiple child nodes, but each child has only one parent. For example, in a company database, one manager oversees many employees, but each employee has only one direct manager. Similarly, a firm can have many divisions, a division can have many departments, and a department can have many sections (see the example below).\nThese relationships help organize data logically and efficiently, making it easier to navigate and retrieve information.\n\n\n\n\n\n\n\n\n\nSo far, we covered a lot of abstract terms like entity, instances, attributes etc. As you correctly notice, we could simply say table, row, and columns instead. However, there is a good reason for using these abstract terms.\nUnderstanding entities, instances, and attributes rather than just tables, rows, and columns is important because it helps us focus on the conceptual meaning of the data rather than just its storage format.\n\nEntity vs.¬†Table: An entity represents a real-world object or concept (like a ‚ÄúCustomer‚Äù or ‚ÄúProduct‚Äù), while a table is just how we store data in a database. Thinking in terms of entities helps us design better database models before deciding how to implement them.\n\nInstance vs.¬†Row: An instance is a specific example of an entity (e.g., a particular customer, ‚ÄúJohn Doe‚Äù). A row is how that instance is stored in a table. Thinking in terms of instances makes it easier to understand relationships between data.\n\nAttribute vs.¬†Column: An attribute describes a characteristic of an entity (e.g., a customer‚Äôs ‚ÄúName‚Äù or ‚ÄúEmail‚Äù). A column is just where this data is stored. By focusing on attributes first, we ensure that all necessary information is captured properly.\n\nBy using these abstract concepts, we can design flexible and well-structured databases before deciding how to implement them in a specific DBMS.\n\n\nWhen designing a relational database, entities and their relationships are translated into tables and columns. The process follows these key steps:\n\nEach entity becomes a table\n\nThe entity name becomes the table name\n\nEach attribute becomes a column\n\n\n\n\nIn a one-to-many relationship, we structure the tables as follows:\n\nAdd a column to the table on the ‚Äúmany‚Äù side of the relationship\n\nStore the identifier of the ‚Äúone‚Äù side in this added column\n\nThis ensures proper linkage between related data while maintaining database integrity.\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nThe conceptual database model uses a parsimonious notation, meaning that extra attributes do not need to be explicitly modeled, as they can be inferred from the relationship.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEnsuring data integrity is crucial in relational databases. Entity integrity maintains the uniqueness and validity of primary keys, while referential integrity ensures that foreign keys correctly reference existing primary keys. These rules help prevent inconsistencies and maintain reliable relationships between tables.\n\n\n\nA primary key must be unique.\n\nPrimary keys can never have NULL values.\n\n\n\n\n\nFor every non-null value of a foreign key, there must be a matching primary key with that value.\n\nExample: For every value of chainID in the brand table, there must be a corresponding value of chainID in the lodgingChain table.\n\nA primary key must exist before a foreign key can be defined.\n\n##Implementable database model\nRemember these beatiful drawings?\n\n\n\n\n\n\n\n\nHand-drawn crowfoot model\n\n\n\n\n\n\n\nER diagram\n\n\n\n\n\n\nFigure¬†1\n\n\n\nSo far, we mainly focused on a conceptual database model. But there is also implementational (or logical) database model.\nThe conceptual database model focuses on the high-level structure of the data, emphasizing entities, relationships, and constraints without considering how the data will be physically stored. It serves as a blueprint for understanding data requirements and is independent of any specific database management system (DBMS). On the other hand, the implementational database model translates the conceptual design into a format that a DBMS can use, incorporating tables, columns, keys, and constraints based on a specific database system. While the conceptual model is abstract and business-oriented, the implementational model is detailed and technical, bridging the gap between design and actual database implementation.\nWe will learn how to design such implementational models in few weeks. First, let‚Äôs learn how to read them.\n\n\n\n\n\n\n\n\n\n\n\n\n\nAn implementational database model\n\n\n\n\n\n\n\n\n\n\n\nWorkbench symbolism\n\n\n\n\n\n\n\n\n\nIn database modeling, identifying and non-identifying relationships refer to how entities are related to one another. An identifying relationship occurs when the child entity‚Äôs existence depends on the parent entity, and the child entity‚Äôs primary key includes the parent‚Äôs primary key. This often happens in cases where the child cannot exist without the parent (e.g., an order item cannot exist without an order). In contrast, a non-identifying relationship occurs when the child entity can exist independently of the parent entity, and the child‚Äôs primary key does not include the parent‚Äôs primary key. Here, the relationship is more loosely coupled (e.g., a customer can exist without an address).\nIn the implementational model, the relationships will look slightly differnt.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nIn the conceptual model, we will have to add a small plus (+) over a relationship, to mark the identifying relationship."
  },
  {
    "objectID": "2-one-to-many-complete.html#attributes",
    "href": "2-one-to-many-complete.html#attributes",
    "title": "One-to-Many relationship",
    "section": "",
    "text": "Attributes store important details about each record in a table, helping to describe and organize data effectively.\nIn a database, attributes can be classified based on whether they require a value. A required attribute must always have a value and cannot be left empty, while an optional attribute can be left empty (NULL).\n\n\n\n\n\n\nWarning\n\n\n\nWe use NULL to indicate missing values. Missing values can occur for different reasons, such as an existing attribute without data (e.g., a middle name) or an inapplicable condition (e.g., an apartment number for a house address).\nDon‚Äôt confuse NULL values with blank or zero.\nMultiple meanings:\n\nUnknown data\nInapplicable data\nNo value supplied\nValue undefined\n\nWe will come back to NULL values later.\n\n\nEach attribute has a domain, which defines the set of possible values it can take.\n\n\n\n\n\n\nTip\n\n\n\nA domain is the set of possible values that an attribute can have. Think of it like a rule that defines what kind of data is allowed in a column. For example, if you have an attribute ‚ÄúAge,‚Äù its domain might be whole numbers between 0 and 120. If you have a ‚ÄúCountry‚Äù attribute, its domain would be a list of valid country names. Domains help keep data consistent and prevent errors, like entering text in a column meant for numbers.\n\n\nTo uniquely identify each record, identifiers are used‚Äîthese are attributes that hold unique values for each instance. In relational databases, the primary key serves as this unique identifier.\nSometimes, a composite identifier is needed, which combines two or more attributes to uniquely identify a record (e.g., a combination of Course ID and Student ID to track enrollments).\nAttributes can be classified into different types:\n\nComposite attribute: Attribute that can be subdivided to yield additional attributes\nSimple attribute: Attribute that cannot be subdivided\nDerived attribute: Attribute whose value is calculated from other attributes\n\nDerived using an algorithm (i.e., Yield = Dividend * Quantity)\nSometimes called ‚Äòcalculated fields‚Äô\n\nSingle-valued attribute: Attribute that holds only a single value\nMultivalued attributes: Attributes that hold many values\n\nUnderstanding these attribute types is essential for designing efficient databases that accurately represent real-world scenarios."
  },
  {
    "objectID": "2-one-to-many-complete.html#multivalued-attributes",
    "href": "2-one-to-many-complete.html#multivalued-attributes",
    "title": "One-to-Many relationship",
    "section": "",
    "text": "Think of the data scientists database we modeled last week.\n\n\n\n\n\nHow would the model change, if our data scientist could get a second degree? Or multiple certificates?\n\n\n\n\n\n\nNote\n\n\n\n\n\n\n\n\n\n\n\n\n\nA multivalued attribute is an attribute that can have multiple values for a single entity. For example, an employee might have multiple phone numbers or an author might write multiple books. In database design, multivalued attributes should be handled properly to maintain data consistency. One approach is to create separate attributes for each component of the multivalued attribute (e.g., Phone_1, Phone_2). A better approach is to create a new entity that holds the multiple values, linking it to the original entity through a relationship (e.g., an Employee_Phone table linked to an Employee table). This ensures better organization, eliminates redundancy, and improves data integrity.\nNow, try to apply that knowledge to our data scientists database.\n\n\n\n\n\n\nNote"
  },
  {
    "objectID": "2-one-to-many-complete.html#entity-relaionship",
    "href": "2-one-to-many-complete.html#entity-relaionship",
    "title": "One-to-Many relationship",
    "section": "",
    "text": "There is one more new thing in the model above. Habe you noticed that the entities are ‚Äúlinked‚Äù. These are entity relationships.\nIn database design, relationships define how different entities (tables) are associated with one another. These relationships follow business rules, which describe how entities interact based on real-world scenarios. For example:\n\na customer can place many orders\na team can have many players.\n\nThese relationships help ensure that data is properly structured and connected.\nA key characteristic of relationships is that they are bi-directional, meaning they should always be read both ways. For example, while a customer can place many orders, each order is placed by only one customer. Understanding relationships in both directions is crucial for designing a clear and logical database structure.\nProperly defining entity relationships improves data integrity, reduces redundancy, and enhances query efficiency. By embedding relationships directly into the database design, businesses can enforce rules and constraints that reflect real-world operations, making data retrieval and management more efficient.\nConsider our brand table from last week. Let‚Äôs say we want to track also info about lodging chains.\n\n\n\n\n\nSince we have multiple hotels owned by the same chain, storing this information in one table would create redundancies.\nIt is better to create a new entity, and specify the relationship beween the two."
  },
  {
    "objectID": "2-one-to-many-complete.html#one-to-many-relationship",
    "href": "2-one-to-many-complete.html#one-to-many-relationship",
    "title": "One-to-Many relationship",
    "section": "",
    "text": "This particular case of relationship is called one-to-many relationship.\nA one-to-many relationship means that one record in a table is linked to many records in another table. Like in our case, one lodging chain can own many hotels, but each hotel belongs to only one chain. See the example of Hilton Hotels:\n\n\n\n\n\nThis type of relationship helps organize data efficiently, avoiding duplication and ensuring consistency.\nLet‚Äôs go back to our stock portfolio table for a second. Remember that it contains stock market data that is used by an investment firm dealing with international commodities and agricultural products.\n\n\n\n\n\n\n\nStock market data\n\n\nWe said that there might be several problems (called anomalies) with it:\n\nInsertion anomalies occur when adding new data is difficult due to missing dependencies.\nUpdate anomalies lead to inconsistencies when changes must be made in multiple places.\nDeletion anomalies cause unintended data loss when removing a record also removes critical information.\n\nLet‚Äôs try to design a database to store our stock portfolio data!\n\n\n\n\n\n\nNote\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDevelop a data model for Marriott International to keep track of relevant information about its portfolio of hotels\nFocus on the assets, not on customers, employees, or transactions\n\n\n\n\n\n\n\n\nHierarchical relationships occur frequently in databases and follow a one-to-many structure, where one entity has multiple related entities beneath it. This structure is similar to a tree, where a parent node can have multiple child nodes, but each child has only one parent. For example, in a company database, one manager oversees many employees, but each employee has only one direct manager. Similarly, a firm can have many divisions, a division can have many departments, and a department can have many sections (see the example below).\nThese relationships help organize data logically and efficiently, making it easier to navigate and retrieve information."
  },
  {
    "objectID": "2-one-to-many-complete.html#mapping-to-a-relational-database",
    "href": "2-one-to-many-complete.html#mapping-to-a-relational-database",
    "title": "One-to-Many relationship",
    "section": "",
    "text": "So far, we covered a lot of abstract terms like entity, instances, attributes etc. As you correctly notice, we could simply say table, row, and columns instead. However, there is a good reason for using these abstract terms.\nUnderstanding entities, instances, and attributes rather than just tables, rows, and columns is important because it helps us focus on the conceptual meaning of the data rather than just its storage format.\n\nEntity vs.¬†Table: An entity represents a real-world object or concept (like a ‚ÄúCustomer‚Äù or ‚ÄúProduct‚Äù), while a table is just how we store data in a database. Thinking in terms of entities helps us design better database models before deciding how to implement them.\n\nInstance vs.¬†Row: An instance is a specific example of an entity (e.g., a particular customer, ‚ÄúJohn Doe‚Äù). A row is how that instance is stored in a table. Thinking in terms of instances makes it easier to understand relationships between data.\n\nAttribute vs.¬†Column: An attribute describes a characteristic of an entity (e.g., a customer‚Äôs ‚ÄúName‚Äù or ‚ÄúEmail‚Äù). A column is just where this data is stored. By focusing on attributes first, we ensure that all necessary information is captured properly.\n\nBy using these abstract concepts, we can design flexible and well-structured databases before deciding how to implement them in a specific DBMS.\n\n\nWhen designing a relational database, entities and their relationships are translated into tables and columns. The process follows these key steps:\n\nEach entity becomes a table\n\nThe entity name becomes the table name\n\nEach attribute becomes a column\n\n\n\n\nIn a one-to-many relationship, we structure the tables as follows:\n\nAdd a column to the table on the ‚Äúmany‚Äù side of the relationship\n\nStore the identifier of the ‚Äúone‚Äù side in this added column\n\nThis ensures proper linkage between related data while maintaining database integrity.\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nThe conceptual database model uses a parsimonious notation, meaning that extra attributes do not need to be explicitly modeled, as they can be inferred from the relationship.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEnsuring data integrity is crucial in relational databases. Entity integrity maintains the uniqueness and validity of primary keys, while referential integrity ensures that foreign keys correctly reference existing primary keys. These rules help prevent inconsistencies and maintain reliable relationships between tables.\n\n\n\nA primary key must be unique.\n\nPrimary keys can never have NULL values.\n\n\n\n\n\nFor every non-null value of a foreign key, there must be a matching primary key with that value.\n\nExample: For every value of chainID in the brand table, there must be a corresponding value of chainID in the lodgingChain table.\n\nA primary key must exist before a foreign key can be defined.\n\n##Implementable database model\nRemember these beatiful drawings?\n\n\n\n\n\n\n\n\nHand-drawn crowfoot model\n\n\n\n\n\n\n\nER diagram\n\n\n\n\n\n\nFigure¬†1\n\n\n\nSo far, we mainly focused on a conceptual database model. But there is also implementational (or logical) database model.\nThe conceptual database model focuses on the high-level structure of the data, emphasizing entities, relationships, and constraints without considering how the data will be physically stored. It serves as a blueprint for understanding data requirements and is independent of any specific database management system (DBMS). On the other hand, the implementational database model translates the conceptual design into a format that a DBMS can use, incorporating tables, columns, keys, and constraints based on a specific database system. While the conceptual model is abstract and business-oriented, the implementational model is detailed and technical, bridging the gap between design and actual database implementation.\nWe will learn how to design such implementational models in few weeks. First, let‚Äôs learn how to read them.\n\n\n\n\n\n\n\n\n\n\n\n\n\nAn implementational database model\n\n\n\n\n\n\n\n\n\n\n\nWorkbench symbolism\n\n\n\n\n\n\n\n\n\nIn database modeling, identifying and non-identifying relationships refer to how entities are related to one another. An identifying relationship occurs when the child entity‚Äôs existence depends on the parent entity, and the child entity‚Äôs primary key includes the parent‚Äôs primary key. This often happens in cases where the child cannot exist without the parent (e.g., an order item cannot exist without an order). In contrast, a non-identifying relationship occurs when the child entity can exist independently of the parent entity, and the child‚Äôs primary key does not include the parent‚Äôs primary key. Here, the relationship is more loosely coupled (e.g., a customer can exist without an address).\nIn the implementational model, the relationships will look slightly differnt.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nIn the conceptual model, we will have to add a small plus (+) over a relationship, to mark the identifying relationship."
  },
  {
    "objectID": "2-one-to-many-complete.html#aggregate-functions",
    "href": "2-one-to-many-complete.html#aggregate-functions",
    "title": "One-to-Many relationship",
    "section": "Aggregate functions",
    "text": "Aggregate functions\nIn SQL aggregate functions help you combine lots of data into one result. These are like math operations that work on whole columns of information instead of just single values.\nHere are the main aggregate functions:\n\nCOUNT(): Tells you how many items are in your data (like counting how many customers you have)\nSUM(): Adds up numbers (like finding your total sales for the month)\nAVG(): Calculates the average (like finding the typical price of products)\nMIN(): Finds the smallest value (like identifying your cheapest item)\nMAX(): Finds the largest value (like identifying your most expensive item)\n\nThese functions are super helpful when you want to get quick summaries from your database without looking at every single row of information. You simply add the to your query follwoing this pattern:\n\nSELECT FUNCTION(columnName) FROM tableName;\n\nLet‚Äôs test them in our brand table!\nFind the average hotel room square footage for all brands.\n\nSELECT AVG(brandMinSqFt) AS avgArea FROM brand;\n\nWhat is the area of the largest hotel room specification in the DB? Rename as ‚ÄúBiggest Room‚Äù\n\nSELECT MAX(brandMinSqFt) AS 'Biggest Room' FROM brand;\n\nHow many total brands do we have data for?\n\nSELECT COUNT(*)FROM brand;\n\n\n\n\n\n\n\nTip\n\n\n\nThe query below is an equivalent to the previous one. Can you explain why?\n\n\n\nSELECT COUNT(brandName)FROM brand;\n\nWhat is the total number of hotel rooms? - All rooms of all chains.\n\n\n\n\n\n\nTip\n\n\n\nThe solve this task, you will have to query different table‚Ä¶\n\n\n\nSELECT SUM(numRooms) FROM lodgingchain;"
  },
  {
    "objectID": "2-one-to-many-complete.html#joining-tables",
    "href": "2-one-to-many-complete.html#joining-tables",
    "title": "One-to-Many relationship",
    "section": "JOINing tables",
    "text": "JOINing tables\nJoining tables in SQL allows you to combine related data from different tables into a single result set. The simplest way to join tables is using the WHERE clause with the equals operator (which is great!ü§© because you already know how to use WHERE).\nHere‚Äôs how it works:\n\nBasic JOIN using WHERE: You list both tables in the FROM clause and use WHERE to match related columns\nExample syntax: SELECT * FROM brand, lodgingchain WHERE brand.chainID = lodgingchain.chainID;\nHow it works: This tells SQL to match each row from the first table with rows from the second table where the specified columns have the same value\nResult: Only rows where the join condition is true appear in your results\n\nThis approach creates what‚Äôs known as an ‚Äúinner join‚Äù - it only shows data where there are matches between both tables. We will explore more powerful ways to join tables in our next session.\nTry it yourself!\n\nSELECT * FROM brand, lodgingchain \n  WHERE brand.chainID = lodgingchain.chainID;\n\n\nExercise\nReport the headquarter location of each brand‚Äôs parent chain.Order by brand name.\n\nSELECT brandName, headquarters\n    FROM brand,lodgingchain\n    WHERE brand.chainID = lodgingchain.chainID\n    ORDER BY brandName;\n\n\n\n\n\n\n\nWatch out for cross-products\n\n\n\nA cross-product in SQL occurs when you join two tables without specifying a join condition. This creates a result set containing every possible combination of rows from both tables. For example, if you run SELECT * FROM brand, lodgingchain; without a WHERE clause, each row from the brand table will be paired with every row from the lodgingchain table. If your brand table has 100 rows and your lodgingchain table has 500 rows, you‚Äôll end up with 50,000 rows in your result set.\nCross-products are rarely useful in practical applications and can cause serious performance problems with large tables, which is why properly specifying join conditions with WHERE clauses is essential for efficient queries.\n\nSELECT * FROM brand, lodgingchain;\n\n\n\n\n\n\n\n\n\nThe risk of homonyms\n\n\n\nHomonyms in database design‚Äîparticularly columns with identical names across different tables‚Äîcreate risks. When fields like ‚Äúid‚Äù or ‚Äústatus‚Äù appear in multiple tables but represent different concepts, developers may mistakenly join these columns or apply incorrect business logic. This confusion leads to flawed queries, unpredictable results, and potential data corruption.\nTo prevent these issues, best practices include using descriptive, context-specific column names (e.g., ‚Äúcustomer_id‚Äù instead of just ‚Äúid‚Äù), implementing consistent naming conventions, and maintaining clear documentation of each column‚Äôs specific meaning and purpose.\nHowever, sometimes you may find a database with homonyms. Let‚Äôs take a look at our nation-stock database. Try to run the query below. What is the result? How would you change the query to get the correct result?\n\n\n\n\n\n\nSELECT * FROM stock, nation\n    WHERE stock.natcode = nation.natcode;"
  },
  {
    "objectID": "2-one-to-many-complete.html#grouping-the-results",
    "href": "2-one-to-many-complete.html#grouping-the-results",
    "title": "One-to-Many relationship",
    "section": "Grouping the results",
    "text": "Grouping the results\nThe GROUP BY clause in SQL allows you to organize similar data into groups and perform aggregate functions on each group separately rather than on the entire table.\nHere‚Äôs how it works:\n\nBasic purpose: Groups rows that have the same values in specified columns\nTypical usage: Used with aggregate functions (COUNT, SUM, AVG, etc.) to perform calculations on each group\nExample syntax: SELECT chainHQ, COUNT(*) FROM lodgingChaing GROUP BY chainHQ;\nResult: One row for each unique value in the grouped column(s)\nMultiple columns: You can group by multiple columns like GROUP BY department, job_title\nCommon requirement: Generally, columns in the SELECT list must either be part of the GROUP BY clause or used within an aggregate function\n\n\nSELECT headquarters, COUNT(*) FROM lodgingchain \n  GROUP BY headquarters;\n\nGROUP BY is essential for summarizing data and generating reports that show totals, averages, or counts for different categories within your data.\n\nExercise\nReport number of brands in each chain by chain name (not chainID).\n\nSELECT chainName, COUNT(brandName) AS NumBrands\n    FROM brand, lodgingchain \n    WHERE brand.chainID = lodgingchain.chainID\n    GROUP BY chainName;\n\n\n\nHAVING\nIn SQL, the HAVING clause is used to filter the results of a GROUP BY query. It is like WHERE clause for grouped results. However, HAVING allows you to filter groups based on aggregate functions (like COUNT(), SUM(), AVG(), etc.), which cannot be done using the WHERE clause.\n\n\n\n\n\n\nNote\n\n\n\nThe WHERE clause filters rows before they are grouped, while HAVING filters groups after the aggregation is done.\n\n\nConsider the previous example. We can easily filter the results and keep only, for example, countries with at least 3 headquarters.\n\nSELECT headquarters, COUNT(*) FROM lodgingchain \n  GROUP BY headquarters\n  HAVING COUNT(*) &gt;= 3;\n\n\nExercise\nReport the average room area and number of brands for all chains that own more than one brand\n\nSELECT chainName, AVG(brandMinSqFt) AS avgArea, COUNT(*) AS totalBrands\n    FROM brand, lodgingchain \n    WHERE lodgingchain.chainID = brand.chainID  \n    GROUP BY chainName \n    HAVING COUNT(*) &gt;= 2;"
  },
  {
    "objectID": "2-one-to-many-complete.html#subqueries",
    "href": "2-one-to-many-complete.html#subqueries",
    "title": "One-to-Many relationship",
    "section": "Subqueries",
    "text": "Subqueries\nA subquery is a query that is nested inside another query. It is used to retrieve data that will be used in the main query for filtering, selecting, or computing results. Subqueries can be placed in the SELECT, FROM, or WHERE clauses of a SQL query.\nThere are two main types of subqueries: 1. Scalar subqueries: Return a single value. 2. Table subqueries: Return multiple rows and columns.\nFor now, we will only focus on scalar subqueries.\nWhen to Use Subqueries:\n\nWhen you need to compare a value in a column with a result from another query.\nWhen you want to perform an operation on a subset of data before using it in the main query.\nWhen a join is not possible or too complex to use.\n\n\nExample of a Subquery in the WHERE Clause:\nReport the name of all brands headquartered in the same country as the Grand Hyatt.\n\nSELECT brandName FROM lodgingChain, brand \n  WHERE lodgingChain.chainID = brand.chainID \n  AND headquarters IN (SELECT headquarters \n                FROM lodgingChain, brand\n                WHERE lodgingChain.chainID = brand.chainID \n                AND brandName='Grand Hyatt');\n\nA subquery in the WHERE clause can be used to filter results based on data from another table. You can run the subquery as a separate query and see its results.\n\nSELECT headquarters FROM lodgingChain, brand\n  WHERE lodgingChain.chainID = brand.chainID \n  AND brandName='Grand Hyatt'\n\n\n\nExercise\nReport all data about the oldest chain with worldwide presence (i.e., founded earliest)\n\nSELECT * FROM lodgingchain \n  WHERE yearfounded = (\n    SELECT MIN(yearfounded) FROM lodgingchain);"
  },
  {
    "objectID": "2-one-to-many-complete.html#extra-practice-cell",
    "href": "2-one-to-many-complete.html#extra-practice-cell",
    "title": "One-to-Many relationship",
    "section": "Extra practice cell",
    "text": "Extra practice cell\n\n\n\n\n\n\n\n\n\n\nThat‚Äôs it for now, but this is just the beginning! üéâ\nThere‚Äôs so much more to explore. With each step, you‚Äôll unlock more powerful ways to interact with databases and make sense of data. Keep practicing, stay curious, and get ready for even more exciting topics ahead!\n\n\n\n\n\n\n\n\nImages and GIFs Disclaimer: Some of the images and GIFs used on this website are not owned by me. They are used for educational and illustrative purposes only. All rights belong to their respective owners. If you believe any content violates copyright, please contact me for prompt removal.\n\n\n\n\n\n\n  \n  \n    ¬© 2025. All Rights Reserved.\n  \n  \n\n  \n  \n    Enabled by Dr. Marcin Bartosiak"
  },
  {
    "objectID": "Homework2.html",
    "href": "Homework2.html",
    "title": "Homework2",
    "section": "",
    "text": "The following queries use the classicmodels schema.\n\n\n\nSource: https://www.richardtwatson.com/\n\n\n\nHow many unique products are in the table products?\n\n\n\n\n\nWhat is the total number of products and the total quantity of all products?\n\n\n  \n\n\nWhat are the minimum and maximum prices of products?\n\n\n    \n\n\nProvide the number of products by product line (hint: use group by)\n\n\n    \n\n\nReport the sales representative for each customer.\n\n\n    \n\n\nReport the total payments by date.\n\n\n    \n\n\nReport the products that have not been sold.\n\n\n    \n\n\nList the amount paid by each customer.\n\n\n    \n\n\nHow many orders have been placed by Herkku Gifts?\n\n\n    \n\n\nWho are the employees in Boston?\n\n\n    \n\n\nReport those payments greater than $100,000. Group the report by customer name. Sort the report so the customer who made the highest payment appears first.\n\n\n    \n\n\n\n\n  \n  \n    ¬© 2025. All Rights Reserved.\n  \n  \n\n  \n  \n    Enabled by Dr. Marcin Bartosiak"
  },
  {
    "objectID": "Homework2.html#sql---homework-2",
    "href": "Homework2.html#sql---homework-2",
    "title": "Homework2",
    "section": "",
    "text": "The following queries use the classicmodels schema.\n\n\n\nSource: https://www.richardtwatson.com/\n\n\n\nHow many unique products are in the table products?\n\n\n\n\n\nWhat is the total number of products and the total quantity of all products?\n\n\n  \n\n\nWhat are the minimum and maximum prices of products?\n\n\n    \n\n\nProvide the number of products by product line (hint: use group by)\n\n\n    \n\n\nReport the sales representative for each customer.\n\n\n    \n\n\nReport the total payments by date.\n\n\n    \n\n\nReport the products that have not been sold.\n\n\n    \n\n\nList the amount paid by each customer.\n\n\n    \n\n\nHow many orders have been placed by Herkku Gifts?\n\n\n    \n\n\nWho are the employees in Boston?\n\n\n    \n\n\nReport those payments greater than $100,000. Group the report by customer name. Sort the report so the customer who made the highest payment appears first.\n\n\n    \n\n\n\n\n  \n  \n    ¬© 2025. All Rights Reserved.\n  \n  \n\n  \n  \n    Enabled by Dr. Marcin Bartosiak"
  },
  {
    "objectID": "cdlibrary.html",
    "href": "cdlibrary.html",
    "title": "CD Library",
    "section": "",
    "text": "CD Library Challenge\n\n\n\n\n\n\nWelcome to the CD Library Database Challenge! In this exercise, you‚Äôll put your SQL skills to work by querying a database that manages a collection of music CDs. As future business analysts and decision-makers, you‚Äôll need to extract meaningful insights from company databases. This challenge simulates a real-world scenario where you‚Äôll help a music store manager understand their inventory and track popular artists. Your task is to craft SQL queries that answer specific business questions and provide actionable intelligence.\n\n\n\n\n\n\nThis is the database model. It is a bit messy, but you will have to deal with it. \n\nWhat are the titles of the recordings on which Asleep at the Wheel appear?\n\n\n\nList all CDs that have any tracks featuring Asleep at the Wheel.\n\n\n\nWho are the members of Manhattan Transfer?\n\n\n\nWhat CDs feature Manhattan Transfer?\n\n\n\nFor what songs has John Hendricks written the lyrics?\n\n\n\nReport all compositions and their composers where more than one person was involved in composing the music.\n\n\n\nList all CDs featuring more than one group.\n\n\n\nList the composers appearing on each CD.\n\n\n\n\n\n\n\n  \n  \n    ¬© 2025. All Rights Reserved.\n  \n  \n\n  \n  \n    Enabled by Dr. Marcin Bartosiak"
  },
  {
    "objectID": "cdlibrary.html#sql---homework-1",
    "href": "cdlibrary.html#sql---homework-1",
    "title": "CD Library",
    "section": "",
    "text": "Welcome to the CD Library Database Challenge! In this exercise, you‚Äôll put your SQL skills to work by querying a database that manages a collection of music CDs. As future business analysts and decision-makers, you‚Äôll need to extract meaningful insights from company databases. This challenge simulates a real-world scenario where you‚Äôll help a music store manager understand their inventory and track popular artists. Your task is to craft SQL queries that answer specific business questions and provide actionable intelligence.\n\n\n\n\n\n\nThis is the database model. It is a bit messy, but you will have to deal with it. \n\nPrepare a list of products sorted by product name in descending order.\n\nSELECT * FROM cd;\n\nList the product names and their quantity available from high to low?\n\n\n\nReport the MSRP for the products in ‚ÄúVintage Cars‚Äù category?\n\n\n\nReport the product(s) with the buy price of 48.81.\n\n\n\nReport those products with the price greater than 70.\n\n\n\nWhich products have product scale ratio 1:10 and 1:72?\n\n\n\nList the product names except the ones in the Planes and Ships category.\n\n\n\nReport the names of products excluding Motorcycles and Classic Cars.\n\n\n\nReport the products having MSRP greater than 110.\n\n\n\nList the product vendors in ascending alphabetical order.\n\n\n\n\n\n\n\n  \n  \n    ¬© 2025. All Rights Reserved.\n  \n  \n\n  \n  \n    Enabled by Dr. Marcin Bartosiak"
  },
  {
    "objectID": "cdlibrary-solution.html",
    "href": "cdlibrary-solution.html",
    "title": "CD Library",
    "section": "",
    "text": "CD Library Challenge\n\n\n\n\n\n\nWelcome to the CD Library Database Challenge! In this exercise, you‚Äôll put your SQL skills to work by querying a database that manages a collection of music CDs. As future business analysts and decision-makers, you‚Äôll need to extract meaningful insights from company databases. This challenge simulates a real-world scenario where you‚Äôll help a music store manager understand their inventory and track popular artists. Your task is to craft SQL queries that answer specific business questions and provide actionable intelligence.\n\n\n\n\n\n\nThis is the database model. It is a bit messy, but you will have to deal with it. \n\nWhat are the titles of the recordings on which Asleep at the Wheel appear?\n\nSELECT comptitle, grpcdrole\n   FROM composition JOIN recording\n  ON composition.compid = recording.compid\n  JOIN group_recording ON recording.rcdid = group_recording.rcdid\n  JOIN grp ON grp.grpid = group_recording.grpid\n  WHERE grpname = 'Asleep at the Wheel';\n\nList all CDs that have any tracks featuring Asleep at the Wheel.\n\nSELECT DISTINCT cd.cdid, cdtitle\n   FROM grp JOIN group_recording\n     ON grp.grpid = group_recording.grpid\n     JOIN recording ON  recording.rcdid = group_recording.rcdid\n    JOIN track ON recording.rcdid = track.rcdid\n    JOIN cd ON  cd.cdid = track.cdid \n    WHERE grpname = 'Asleep at the Wheel';\n\nWho are the members of Manhattan Transfer?\n\nSELECT psnfname, psnlname\n FROM grp JOIN person_group USING(grpid) JOIN person USING(psnid)\n WHERE grpname = 'Manhattan Transfer';\n\nWhat CDs feature Manhattan Transfer?\n\nSELECT cdtitle\n FROM grp JOIN group_cd USING(grpid) JOIN cd USING(cdid)\n WHERE grpname = 'Manhattan Transfer';\n\nFor what songs has John Hendricks written the lyrics?\n\nSELECT comptitle FROM person, person_composition, composition\n   WHERE person.psnid = person_composition.psnid\n   AND composition.compid = person_composition.compid\n   AND psnfname = 'John'\n   AND psnlname = 'Hendricks'\n   AND psncomprole = 'lyrics';\n\nReport all compositions and their composers where more than one person was involved in composing the music.\n\nSELECT comptitle, psnfname, psnlname, psncomprole\n   FROM composition, person_composition, person\n  WHERE person.psnid = person_composition.psnid\n  AND composition.compid = person_composition.compid\n  AND composition.compid IN\n     (SELECT compid FROM person_composition\n        GROUP BY compid HAVING COUNT(*) &gt; 1);\n\nList all CDs featuring more than one group.\n\nSELECT cdtitle\n   FROM cd, group_cd, grp\n  WHERE cd.cdid = group_cd.cdid\n  AND group_cd.grpid=grp.grpid\n  GROUP BY cdtitle\n  HAVING COUNT(*) &gt; 1;\n\nList the composers appearing on each CD.\n\nSELECT DISTINCT cdtitle, psnfname, psnlname \n FROM cd, person, person_composition, composition, recording, track\n  WHERE person.psnid = person_composition.psnid\n   AND composition.compid = person_composition.compid\n   AND composition.compid = recording.compid\n   AND recording.rcdid = track.rcdid\n   AND cd.cdid = track.cdid;\n\n\n\n\n\n  \n  \n    ¬© 2025. All Rights Reserved.\n  \n  \n\n  \n  \n    Enabled by Dr. Marcin Bartosiak"
  }
]