[
  {
    "objectID": "Readings.html",
    "href": "Readings.html",
    "title": "Readings",
    "section": "",
    "text": "Richard Watson Data Management: Databases and Organizations 6th Edition Prospect Press\nAvailable in the Department’s library and at\nData Management, Databases, and Analytics\n\n\n\n\n\n\n\n\n\n\n\n\nCoronel C. and Morris S. Database Systems: Design, Implementation and Management\n12th Edition, Cengage Learning.\nAvailable in the Department’s library.\n\n\n\n\n\n\n\n\n\n  \n  \n    © 2025. All Rights Reserved.\n  \n  \n\n  \n  \n    Enabled by Dr. Marcin Bartosiak"
  },
  {
    "objectID": "Readings.html#readings",
    "href": "Readings.html#readings",
    "title": "Readings",
    "section": "",
    "text": "Richard Watson Data Management: Databases and Organizations 6th Edition Prospect Press\nAvailable in the Department’s library and at\nData Management, Databases, and Analytics\n\n\n\n\n\n\n\n\n\n\n\n\nCoronel C. and Morris S. Database Systems: Design, Implementation and Management\n12th Edition, Cengage Learning.\nAvailable in the Department’s library.\n\n\n\n\n\n\n\n\n\n  \n  \n    © 2025. All Rights Reserved.\n  \n  \n\n  \n  \n    Enabled by Dr. Marcin Bartosiak"
  },
  {
    "objectID": "Introduction.html",
    "href": "Introduction.html",
    "title": "Database Management - Introduction",
    "section": "",
    "text": "“All the value of this company is in its people. If you burned down all our plants, and we just kept our people and our information files, we should soon be as strong as ever.”\n\n\n\n\n\nThomas Watson Jr, 2nd President of IBM\n\n\n\n\n\n\n\n\n\n\n\n“The most meaningful way to differentiate your company from your competitors, the best way to put distance between you and the crowd, is to do an outstanding job with information. How you can gather,manage and use information will determine whether you win or lose”\n\n\n\n\n\nBill Gates, Founder of Microsoft\n\n\n\n\n\nThe two quotes above show us a very important truth about managing organization. In the Information society, which is based on innovation, knowledge and services, the key determinant of success has shifted from product quality to decision quality. In the traditional industrial society, the better quality product you had, the better market position you had (which is still very true in some cases). Nowadays, Companies are very dependent on information systems to create value for their customers. In other words, the better information you have, the better is your position.\nIf you are not convinced, think about your own private life. In today’s fast-paced world, managing personal information effectively is essential. Tools like calendars and address books serve as crucial external memory systems, helping us stay organized and on top of our daily tasks.\n\n\n\n\n\n\nA calendar not only helps us track appointments, meetings, and deadlines but also organizes time in a structured way, often with features to quickly navigate to today’s date or upcoming events.\n\n\n\n\n\n\n\n\n\n\n\n\nSimilarly, address books store important contact details, such as phone numbers and email addresses, allowing for easy access to frequently contacted individuals.\n\n\n\n\n\n\nBoth systems are designed to reduce the mental burden of remembering every detail, providing an efficient means of storing and retrieving information, thus enabling us to focus on more important tasks.\nThere are some common features of all these systems:\n\nStorage medium\n\nElectronic / paper\n\nStructure for storing data\nData is organized for:\n\nEfficient data entry\nRapid data retrieval\n\nAny design requires trade-offs\n\n\n\nOrganizations, like people, need to remember many things. Deciding where and how to store data frequently involves a trade-off.\nOrganizational data are used by a variety of information systems.\n\n\n\nA simple Informaion Sysem\n\n\nThere are many types of Information Systems in organizations.\n\n\n\n\n\n\n\nType of IS\nSystem’s purpose\n\n\n\n\nTPS\nTransaction processing system: Collects and stores data from routine transactions\n\n\nMIS\nManagement information system: Converts data from a TPS into information for planning, controlling, and managing an organization\n\n\nDSS\nDecision support system: Supports managerial decision making by providing models for processing and analysing data\n\n\nEIS\nExecutive information system: Provides senior management with information necessary to monitor organizational performance, and develop and implement strategies\n\n\nOLAP\nOnline analytical processing: Presents a multidimensional, logical view of data\n\n\nData mining\nUses statistical analysis and artificial intelligence techniques to identify hidden relationships in data\n\n\nBI\nBusiness intelligence: Systems for gathering, storing, analyzing, and accessing data to improve decision-making\n\n\n\nAll of them may require some sort of data to work.\n\n\n\nThe IS cycle\n\n\n\n\nFor the data to be effectively fed into all these systems, data management systems must meet specific requirements:\n\n\n\n\n\n\n\nRequirement\nDescription\n\n\n\n\nShareable\nReadily accessible to multiple users (at the same time).\n\n\nTransportable\nEasily accessible by users in different locations (e.g., salesperson, decision-maker).\n\n\nSecure\nSafe from destruction or unauthorized use.\n\n\nAccurate\nReliable and trustworthy.\n\n\nTimely\nCurrent and up-to-date.\n\n\nRelevant\nValuable and appropriate for its intended use.\n\n\n\n\n\n\n\nSimilarly, there are challenges and problems that database management systems must overcome:\n\n\n\n\n\n\n\nChallenge\nDescription\n\n\n\n\nRedundancy\nThe same data is replicated in multiple locations.\n\n\nLack of Data Control\nData is not secure or effectively organized and managed.\n\n\nPoor Interface\nData is not accessible.\n\n\nDelays\nData is not timely.\n\n\nLack of Reality\nData is not relevant because it lacks fidelity to the real world it represents.\n\n\nLack of Data Integration\nRelated data is stored in separate, isolated locations."
  },
  {
    "objectID": "Introduction.html#organizational-data-management",
    "href": "Introduction.html#organizational-data-management",
    "title": "Database Management - Introduction",
    "section": "",
    "text": "Organizations, like people, need to remember many things. Deciding where and how to store data frequently involves a trade-off.\nOrganizational data are used by a variety of information systems.\n\n\n\nA simple Informaion Sysem\n\n\nThere are many types of Information Systems in organizations.\n\n\n\n\n\n\n\nType of IS\nSystem’s purpose\n\n\n\n\nTPS\nTransaction processing system: Collects and stores data from routine transactions\n\n\nMIS\nManagement information system: Converts data from a TPS into information for planning, controlling, and managing an organization\n\n\nDSS\nDecision support system: Supports managerial decision making by providing models for processing and analysing data\n\n\nEIS\nExecutive information system: Provides senior management with information necessary to monitor organizational performance, and develop and implement strategies\n\n\nOLAP\nOnline analytical processing: Presents a multidimensional, logical view of data\n\n\nData mining\nUses statistical analysis and artificial intelligence techniques to identify hidden relationships in data\n\n\nBI\nBusiness intelligence: Systems for gathering, storing, analyzing, and accessing data to improve decision-making\n\n\n\nAll of them may require some sort of data to work.\n\n\n\nThe IS cycle\n\n\n\n\nFor the data to be effectively fed into all these systems, data management systems must meet specific requirements:\n\n\n\n\n\n\n\nRequirement\nDescription\n\n\n\n\nShareable\nReadily accessible to multiple users (at the same time).\n\n\nTransportable\nEasily accessible by users in different locations (e.g., salesperson, decision-maker).\n\n\nSecure\nSafe from destruction or unauthorized use.\n\n\nAccurate\nReliable and trustworthy.\n\n\nTimely\nCurrent and up-to-date.\n\n\nRelevant\nValuable and appropriate for its intended use.\n\n\n\n\n\n\n\nSimilarly, there are challenges and problems that database management systems must overcome:\n\n\n\n\n\n\n\nChallenge\nDescription\n\n\n\n\nRedundancy\nThe same data is replicated in multiple locations.\n\n\nLack of Data Control\nData is not secure or effectively organized and managed.\n\n\nPoor Interface\nData is not accessible.\n\n\nDelays\nData is not timely.\n\n\nLack of Reality\nData is not relevant because it lacks fidelity to the real world it represents.\n\n\nLack of Data Integration\nRelated data is stored in separate, isolated locations."
  },
  {
    "objectID": "Introduction.html#data-vs.-information",
    "href": "Introduction.html#data-vs.-information",
    "title": "Database Management - Introduction",
    "section": "Data vs. Information",
    "text": "Data vs. Information\nBefore diving into databases, it’s crucial to grasp the distinction between data, information, and knowledge. Databases don’t just store raw data – they organize it into meaningful information that can be analyzed to generate knowledge.\nData consists of raw facts and figures without context, like individual numbers or words. Information emerges when data is organized and given context, making it meaningful and useful – for instance, when those numbers represent monthly sales figures. Knowledge goes further: it’s the understanding gained from analyzing and applying information, allowing us to make informed decisions and recognize patterns.\n\n\n\n\n\n\n\n\nCategory\nCharacteristics\nExample\n\n\n\n\nData\n• Raw facts• No context• Just numbers and text\nTemperature readings: 23, 25, 22, 24, 26\n\n\nInformation\n• Data with context• Processed data• Value added to data• Summarized• Organized• Analyzed\nDaily temperature readings in Celsius for Pavia, week of June 1-5, 2024, showing an average of 24°C with an upward trend\n\n\nKnowledge\n• Knowing what information is required• Knowing what the information means\nUnderstanding that the rising temperature trend in Pavia indicates the start of summer and knowing to adjust city services (like water supply) and public health advisories accordingly\n\n\n\nA database’s true value lies in its ability to transform raw data into actionable insights through structured organization and relationships."
  },
  {
    "objectID": "Introduction.html#database",
    "href": "Introduction.html#database",
    "title": "Database Management - Introduction",
    "section": "Database",
    "text": "Database\nA database is an organized collection of related files used to store and manage data efficiently. It serves as a single logical data repository, ensuring that data is structured, accessible, and self-describing. Databases contain both user data (actual stored information) and metadata (data about the data, such as structure and relationships).\nIn a relational database, data is organized into tables, where each row (record) represents a unit of interest, and each column (field) defines an attribute of that unit.\nThere are different types of databases based on usage and architecture:\n\nTypes of Databases Explained\n\n1. Single-User vs. Multi-User Databases\n\nSingle-User Database: Designed for one user at a time, typically used in personal applications or small-scale projects (e.g., Microsoft Access, SQLite).\n\nMulti-User Database: Supports multiple users accessing and modifying data simultaneously, often used in businesses and enterprise systems (e.g., MySQL, PostgreSQL).\n\n\n\n2. Operational (Transactional) vs. Analytical Databases\n\nOperational (Transactional) Database: Used for real-time operations, such as processing daily business transactions (e.g., banking systems, e-commerce platforms). These databases are optimized for fast inserts, updates, and deletes.\n\nAnalytical Database: Designed for reporting and decision-making, optimized for complex queries and data analysis rather than frequent transactions (e.g., data warehouses like Amazon Redshift or Google BigQuery).\n\n\n\n3. Centralized, Distributed, or Cloud Databases\n\nCentralized Database: All data is stored in a single location, often on a dedicated server. This setup simplifies management but can become a bottleneck as data scales.\n\nDistributed Database: Data is spread across multiple locations or servers, improving performance and reliability (e.g., Google Spanner, Apache Cassandra).\n\nCloud Database: Hosted on cloud platforms, allowing for scalable, flexible, and remotely accessible data storage (e.g., AWS RDS, Google Cloud SQL).\n\n\n\n4. Single-Tenant vs. Multi-Tenant Databases\n\nSingle-Tenant Database: Each customer (tenant) has their own dedicated database. This provides better security and customization but can be expensive (e.g., private database instances for enterprises).\n\nMulti-Tenant Database: A single database serves multiple customers, with data logically separated. This is commonly used in SaaS (Software as a Service) applications (e.g., Salesforce, Shopify).\n\n\n\n5. Relational vs. Non-Relational Databases\n\nRelational Database (RDBMS): Uses structured tables with predefined relationships and follows SQL for querying (e.g., MySQL, PostgreSQL, Oracle). Best for structured, consistent data.\n\nNon-Relational Database (NoSQL): Stores data in flexible formats like key-value pairs, documents, graphs, or columns (e.g., MongoDB, Redis, Cassandra). Ideal for big data, real-time applications, and unstructured data.\n\nEach database type is suited for different use cases depending on the scale, structure, and nature of the data being managed."
  },
  {
    "objectID": "Introduction.html#database-model",
    "href": "Introduction.html#database-model",
    "title": "Database Management - Introduction",
    "section": "Database Model",
    "text": "Database Model\nDatabase Model is the logical representation of the structure of the data.\n\n\n\nDatabase Model Example\n\n\nData Modelling\n\nThe technique for creating the logical structure of a database\n\nWhat files (tables) should be in the database?\nHow are these files related?\nWhat columns should describe each row in a table?\n\nData Modeling is an iterative process\nData Modeling is a communication tool\n\n\n\n\n\n\n\nNote\n\n\n\nData Modelling is a design process\n\n\nDESIGN: the specification of an object, intended to accomplish goals, in a particular environment, using a set of primitive components, satisfying a set of requirements, subject to constraints.\n\n\n\nDifferent requirements = different design\n\n\n\n\n\n\n\n\nNote\n\n\n\nData Modelling is an iterative process\n\n\n\n\n\n\n\n\nData modeling is a highly repetitive and cyclical process, requiring continuous refinement and improvement at every stage. It begins with an initial conceptual model, which is repeatedly reviewed, adjusted, and expanded based on new insights, stakeholder feedback, and evolving business needs. Each iteration involves revisiting assumptions, restructuring relationships, and optimizing performance to ensure the model remains accurate and efficient. As data requirements change, the process loops back, refining previous versions and incorporating necessary modifications. This ongoing cycle of evaluation and enhancement ensures that the final data model is robust, scalable, and aligned with organizational goals.\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nData Modelling is a communication process\n\n\nIt serves as a bridge between technical teams, business stakeholders, and end users. It translates complex data structures into understandable diagrams and definitions, ensuring that everyone involved has a clear understanding of how data is organized, stored, and utilized. Effective data modeling requires collaboration, as stakeholders provide input on business rules and requirements while data architects translate these needs into structured models. This shared understanding helps prevent misinterpretations, aligns expectations, and ensures that the final database or system supports business objectives efficiently."
  },
  {
    "objectID": "Introduction.html#wait-why-bother",
    "href": "Introduction.html#wait-why-bother",
    "title": "Database Management - Introduction",
    "section": "WAIT! WHY BOTHER?",
    "text": "WAIT! WHY BOTHER?\n\n\n\n\n\n\n\n\n\nWhy don’t we just use Excel like everyone else???\n\n\n\n\n\n\n\n\n\nWhile Excel is a powerful tool for organizing and analyzing data, it is not designed for managing large-scale, complex datasets that require consistency, security, and efficient querying. Databases offer structured storage, ensuring data integrity through constraints, relationships, and normalization, which Excel lacks. Additionally, databases handle concurrent access, scalability, automation, and advanced querying via SQL, making them the superior choice for robust and reliable data management.l\n\n\n\n\n\nBad things can happen, when you use Excel to store your data 😢\n\n\n\n\n\nOne major issue with using Excel for data management is the risk of anomalies—problems that arise due to poorly structured data.\n\n\n\n\n\n\nWarning\n\n\n\nAnomalies are problems that occur in a poorly designed database when inserting, updating, or deleting data. They happen because data is not organized properly, leading to inconsistencies, duplication, or unintended data loss.\n\n\nLet’s consider this table. It contains stock market data that is used by an investment firm dealing with international commodities and agricultural products. Think about the problems we may have with it\n\n\n\n\n\n\n\nStock market data\n\n\n\n\n\n\n\n\nWarning\n\n\n\nInsertion anomalies occur when adding new data is difficult due to missing dependencies.\n\n\nFor example n our table you cannot add a new nation exchange rate without creating a (fake) stock\n\n\n\n\n\n\nWarning\n\n\n\nUpdate anomalies lead to inconsistencies when changes must be made in multiple places.\n\n\nWhen the exchange rate in the UK changes you must update the rows for 10 shares. Likely to generate errors and/or inconsistencies\n\n\n\n\n\n\nWarning\n\n\n\nDeletion anomalies cause unintended data loss when removing a record also removes critical information.\n\n\nFor example, if you sell “Bombay Duck” you lose information about the Indian exchange rate.\nUnlike Excel, databases prevent these anomalies through normalization, ensuring data is stored efficiently and consistently."
  },
  {
    "objectID": "Homework5.html",
    "href": "Homework5.html",
    "title": "Homework5",
    "section": "",
    "text": "Warning\n\n\n\nYou have to run these queries in Workbench (or Python program).\n\n\nThe following queries use the classicmodels schema.\n\n\n\nSource: https://www.richardtwatson.com/\n\n\n\nReport the contact names for the customers having no sales representative. Try it with and without IS NULL.\nSelect the product code and name of all the products that have not been sold. [Try with IS NULL and without IS NULL]\nList the name, line and vendor of products in the ‘Classic Cars’ product line or from vendors that have ‘Gear’ in their name. [Try it with the UNION set operator]\nCount the total number of products in each product line. [Do not use an outer join]\nReport the total number of orders that shipped between 2003-06-06 and 2004-07-07. Meaningfully rename the output.\nIdentify all the products that were sold at a discount greater than 5% but less than 10%.\nReport name, cost, MSRP and margin (MSRP- buyPrice) for the 5 most expensive products (highest MSRP). Limit your reporting to the products that sold at least 300 units (cumulative in all orders). [perform this query using LIMIT]\nReport the 10 most expensive products by MSRP [use LIMIT].\nReport the 10th most expensive product by MSRP [use LIMIT and OFFSET].\nReport all product information about the products with the second highest MSRP.\n\nChallenge: Can you complete query 9 without using LIMIT?\n\n\n\n  \n  \n    © 2025. All Rights Reserved.\n  \n  \n\n  \n  \n    Enabled by Dr. Marcin Bartosiak"
  },
  {
    "objectID": "Homework5.html#sql---homework-5",
    "href": "Homework5.html#sql---homework-5",
    "title": "Homework5",
    "section": "",
    "text": "Warning\n\n\n\nYou have to run these queries in Workbench (or Python program).\n\n\nThe following queries use the classicmodels schema.\n\n\n\nSource: https://www.richardtwatson.com/\n\n\n\nReport the contact names for the customers having no sales representative. Try it with and without IS NULL.\nSelect the product code and name of all the products that have not been sold. [Try with IS NULL and without IS NULL]\nList the name, line and vendor of products in the ‘Classic Cars’ product line or from vendors that have ‘Gear’ in their name. [Try it with the UNION set operator]\nCount the total number of products in each product line. [Do not use an outer join]\nReport the total number of orders that shipped between 2003-06-06 and 2004-07-07. Meaningfully rename the output.\nIdentify all the products that were sold at a discount greater than 5% but less than 10%.\nReport name, cost, MSRP and margin (MSRP- buyPrice) for the 5 most expensive products (highest MSRP). Limit your reporting to the products that sold at least 300 units (cumulative in all orders). [perform this query using LIMIT]\nReport the 10 most expensive products by MSRP [use LIMIT].\nReport the 10th most expensive product by MSRP [use LIMIT and OFFSET].\nReport all product information about the products with the second highest MSRP.\n\nChallenge: Can you complete query 9 without using LIMIT?\n\n\n\n  \n  \n    © 2025. All Rights Reserved.\n  \n  \n\n  \n  \n    Enabled by Dr. Marcin Bartosiak"
  },
  {
    "objectID": "Homework4-solution.html",
    "href": "Homework4-solution.html",
    "title": "Homework4 solution",
    "section": "",
    "text": "Warning\n\n\n\nYou have to run these queries in Workbench (or Python program).\n\n\nThe following queries use the classicmodels schema.\n\n\n\nSource: https://www.richardtwatson.com/\n\n\n\nWho is at the top of organization?\n\nSELECT  DISTINCT boss.employeeNumber, boss.lastName, boss.firstName\n FROM employees as emp JOIN employees boss\n  ON emp.reportsTo = boss.employeeNumber\n WHERE boss.reportsTo IS NULL; \n\nWho reports to directly to William Patterson?\n\nSELECT emp.lastName, emp.firstName \n FROM employees as emp JOIN employees boss\n  ON emp.reportsTo = boss.employeeNumber\n WHERE boss.lastName = 'Patterson'\n AND boss.firstName = 'William';\n\nList the employees who report to those employees who report to Diane Murphy.\n\nSELECT emp.lastName, emp.firstName , emp.employeeNumber, emp.reportsTo\n FROM employees as emp JOIN employees as boss JOIN employees as bigboss\n  ON emp.reportsTo = boss.employeeNumber\n  AND boss.reportsTo = bigboss.employeeNumber\n WHERE bigboss.lastName = 'Murphy'\n AND bigboss.firstName = 'Diane';\n    \n\nHow many employees report to the Sales Manager that is employee named ‘Bow Anthony’? Rename the column as “Mr. Bow’s Direct Reports”\n\nSELECT  count(emp.reportsTo) AS 'Mr. Bows Direct Reports'\n FROM employees as emp JOIN employees boss\n  ON emp.reportsTo = boss.employeeNumber\n WHERE boss.employeeNumber IN (SELECT employeeNumber \n                                FROM employees \n                                WHERE firstName= 'Anthony' AND lastName= 'Bow');\n    \n\nFind the pair of customer that have the same credit limit. Omit the customers having no credit limit (That is creditlimit = 0): Report the customer name and credit limit for each pair and be sure to avoid unnecessary duplication.\n\nSELECT a.customerName, b.customerName, a.creditLimit, b.creditLimit\n FROM customers AS a JOIN customers AS b\n  ON a.customerName&gt; b.customerName\n WHERE a.creditLimit = b.creditLimit\n AND b.creditLimit !=0; \n\n\n\n  \n  \n    © 2025. All Rights Reserved.\n  \n  \n\n  \n  \n    Enabled by Dr. Marcin Bartosiak"
  },
  {
    "objectID": "Homework4-solution.html#sql---homework-4---solution",
    "href": "Homework4-solution.html#sql---homework-4---solution",
    "title": "Homework4 solution",
    "section": "",
    "text": "Warning\n\n\n\nYou have to run these queries in Workbench (or Python program).\n\n\nThe following queries use the classicmodels schema.\n\n\n\nSource: https://www.richardtwatson.com/\n\n\n\nWho is at the top of organization?\n\nSELECT  DISTINCT boss.employeeNumber, boss.lastName, boss.firstName\n FROM employees as emp JOIN employees boss\n  ON emp.reportsTo = boss.employeeNumber\n WHERE boss.reportsTo IS NULL; \n\nWho reports to directly to William Patterson?\n\nSELECT emp.lastName, emp.firstName \n FROM employees as emp JOIN employees boss\n  ON emp.reportsTo = boss.employeeNumber\n WHERE boss.lastName = 'Patterson'\n AND boss.firstName = 'William';\n\nList the employees who report to those employees who report to Diane Murphy.\n\nSELECT emp.lastName, emp.firstName , emp.employeeNumber, emp.reportsTo\n FROM employees as emp JOIN employees as boss JOIN employees as bigboss\n  ON emp.reportsTo = boss.employeeNumber\n  AND boss.reportsTo = bigboss.employeeNumber\n WHERE bigboss.lastName = 'Murphy'\n AND bigboss.firstName = 'Diane';\n    \n\nHow many employees report to the Sales Manager that is employee named ‘Bow Anthony’? Rename the column as “Mr. Bow’s Direct Reports”\n\nSELECT  count(emp.reportsTo) AS 'Mr. Bows Direct Reports'\n FROM employees as emp JOIN employees boss\n  ON emp.reportsTo = boss.employeeNumber\n WHERE boss.employeeNumber IN (SELECT employeeNumber \n                                FROM employees \n                                WHERE firstName= 'Anthony' AND lastName= 'Bow');\n    \n\nFind the pair of customer that have the same credit limit. Omit the customers having no credit limit (That is creditlimit = 0): Report the customer name and credit limit for each pair and be sure to avoid unnecessary duplication.\n\nSELECT a.customerName, b.customerName, a.creditLimit, b.creditLimit\n FROM customers AS a JOIN customers AS b\n  ON a.customerName&gt; b.customerName\n WHERE a.creditLimit = b.creditLimit\n AND b.creditLimit !=0; \n\n\n\n  \n  \n    © 2025. All Rights Reserved.\n  \n  \n\n  \n  \n    Enabled by Dr. Marcin Bartosiak"
  },
  {
    "objectID": "Homework3-solution.html",
    "href": "Homework3-solution.html",
    "title": "Homework3 solution",
    "section": "",
    "text": "The following queries use the classicmodels schema.\n\n\n\nSource: https://www.richardtwatson.com/\n\n\n\nReport product number, product name of products sold by order date. Order results by date (descending) and product code (ascending). Use both the USING and ON syntax for the join. Observe their different behavior.\n\n\nSELECT productCode, productName, orderDate\n FROM (orders JOIN orderdetails USING(orderNumber)) JOIN products USING (productCode) \n ORDER BY orderDate DESC, productCode; \n\n\nSELECT products.productCode, productName, orderDate\n FROM orders JOIN orderdetails JOIN products \n  ON orders.orderNumber = orderdetails.orderNumber\n  AND orderdetails.productCode = products.productCode\n ORDER BY orderDate DESC, productCode;\n\n\nList all the order number and status for all the orders containing the 1940 Ford Pickup Truck.\n\n\nSELECT orderNumber, status \nFROM orders JOIN orderdetails USING(orderNumber) JOIN products USING(productCode)\n WHERE productName = '1940 Ford Pickup Truck';  \n\n\nList the names of customers and the corresponding order numbers for those orders from that customer that have a total value greater than $25,000? Total value is obtained by adding the price times quantity sold of all products in the order.\n\n\nSELECT customerName, orderNumber\nFROM customers JOIN orders USING(customerNumber) JOIN orderdetails USING(orderNumber) \nGROUP BY customerName, orderNumber\nHAVING SUM(priceEach*quantityOrdered) &gt; 25000\nORDER BY SUM(priceEach*quantityOrdered);\n    \n\n\nSELECT customerName, orderNumber\n FROM customers JOIN orders USING(customerNumber)\n WHERE orderNumber IN (SELECT orderNumber \n                        FROM orders JOIN orderdetails USING(orderNumber)\n                        GROUP BY orderNumber\n                        HAVING SUM(priceEach * quantityOrdered) &gt; 25000);\n    \n\n\nAre there any products that appear on all orders? If so, list their product code and the total number of orders they appear in. Rename the columns as ‘Total Orders’.\n\n\nSELECT products.productCode, COUNT(*) as 'Total Orders'\n FROM products JOIN orderdetails ON products.productCode = orderdetails.productCode\n GROUP BY products.productCode\n HAVING COUNT(DISTINCT orderNumber) = (SELECT COUNT(DISTINCT orderNumber) FROM orders);\n\n\nReport those orders containing products sold at a discount (i.e., sold at a price less than the product’s MSRP). For these orders report the order number, the product code of the items sold at discount and both the price and the MSRP.\n\n\nSELECT orderNumber, productCode, priceEach, MSRP\n FROM orderdetails JOIN products USING(productCode)\n WHERE priceEach &lt; MSRP;    \n\n\nRepeat the above query but only return the order number for the orders containing products sold at a discount. Use a subquery.\n\n\nSELECT DISTINCT orderNumber\n FROM orderdetails\n WHERE priceEach &lt; (SELECT MSRP FROM products\n                    WHERE orderdetails.productCode = products.productCode); \n\n\nReport those products that have been sold with a markup of 100% or more (i.e., the priceEach is at least twice the buyPrice) on at least one sale. Provide the product code, the price at which it sold, the buy price and the MSRP. Be sure not to duplicate output unnecessarily.\n\n\nSELECT DISTINCT productCode, priceEach, buyPrice, MSRP\n FROM orderdetails JOIN products USING(productCode)\n WHERE priceEach &gt; 2 * buyPrice;    \n\n\nWhat is the total quantity on hand for products listed in orders with staus: ‘On Hold’? Rename the quantity ordered as ‘Total Ordered’ and the quantity in stock as ‘Total on Hand’. Use the ON syntax for the JOIN.\n\n\nSELECT products.productCode, SUM(quantityOrdered) AS 'Total Ordered', quantityInStock AS 'On Hand'\n FROM orders JOIN orderdetails JOIN products\n  ON orders.orderNumber = orderdetails.orderNumber\n  AND orderdetails.productCode = products.productCode\n WHERE status = 'On Hold'\n GROUP BY products.productCode;\n    \n\n\nReport product code, name and MSRP for all products that have not sold any units.\n\n\nSELECT productCode, productName, MSRP\n FROM products\n WHERE productCode NOT IN (SELECT DISTINCT productCode FROM orderdetails);  \n\n\n\n\n  \n  \n    © 2025. All Rights Reserved.\n  \n  \n\n  \n  \n    Enabled by Dr. Marcin Bartosiak"
  },
  {
    "objectID": "Homework3-solution.html#sql---homework-3---solution",
    "href": "Homework3-solution.html#sql---homework-3---solution",
    "title": "Homework3 solution",
    "section": "",
    "text": "The following queries use the classicmodels schema.\n\n\n\nSource: https://www.richardtwatson.com/\n\n\n\nReport product number, product name of products sold by order date. Order results by date (descending) and product code (ascending). Use both the USING and ON syntax for the join. Observe their different behavior.\n\n\nSELECT productCode, productName, orderDate\n FROM (orders JOIN orderdetails USING(orderNumber)) JOIN products USING (productCode) \n ORDER BY orderDate DESC, productCode; \n\n\nSELECT products.productCode, productName, orderDate\n FROM orders JOIN orderdetails JOIN products \n  ON orders.orderNumber = orderdetails.orderNumber\n  AND orderdetails.productCode = products.productCode\n ORDER BY orderDate DESC, productCode;\n\n\nList all the order number and status for all the orders containing the 1940 Ford Pickup Truck.\n\n\nSELECT orderNumber, status \nFROM orders JOIN orderdetails USING(orderNumber) JOIN products USING(productCode)\n WHERE productName = '1940 Ford Pickup Truck';  \n\n\nList the names of customers and the corresponding order numbers for those orders from that customer that have a total value greater than $25,000? Total value is obtained by adding the price times quantity sold of all products in the order.\n\n\nSELECT customerName, orderNumber\nFROM customers JOIN orders USING(customerNumber) JOIN orderdetails USING(orderNumber) \nGROUP BY customerName, orderNumber\nHAVING SUM(priceEach*quantityOrdered) &gt; 25000\nORDER BY SUM(priceEach*quantityOrdered);\n    \n\n\nSELECT customerName, orderNumber\n FROM customers JOIN orders USING(customerNumber)\n WHERE orderNumber IN (SELECT orderNumber \n                        FROM orders JOIN orderdetails USING(orderNumber)\n                        GROUP BY orderNumber\n                        HAVING SUM(priceEach * quantityOrdered) &gt; 25000);\n    \n\n\nAre there any products that appear on all orders? If so, list their product code and the total number of orders they appear in. Rename the columns as ‘Total Orders’.\n\n\nSELECT products.productCode, COUNT(*) as 'Total Orders'\n FROM products JOIN orderdetails ON products.productCode = orderdetails.productCode\n GROUP BY products.productCode\n HAVING COUNT(DISTINCT orderNumber) = (SELECT COUNT(DISTINCT orderNumber) FROM orders);\n\n\nReport those orders containing products sold at a discount (i.e., sold at a price less than the product’s MSRP). For these orders report the order number, the product code of the items sold at discount and both the price and the MSRP.\n\n\nSELECT orderNumber, productCode, priceEach, MSRP\n FROM orderdetails JOIN products USING(productCode)\n WHERE priceEach &lt; MSRP;    \n\n\nRepeat the above query but only return the order number for the orders containing products sold at a discount. Use a subquery.\n\n\nSELECT DISTINCT orderNumber\n FROM orderdetails\n WHERE priceEach &lt; (SELECT MSRP FROM products\n                    WHERE orderdetails.productCode = products.productCode); \n\n\nReport those products that have been sold with a markup of 100% or more (i.e., the priceEach is at least twice the buyPrice) on at least one sale. Provide the product code, the price at which it sold, the buy price and the MSRP. Be sure not to duplicate output unnecessarily.\n\n\nSELECT DISTINCT productCode, priceEach, buyPrice, MSRP\n FROM orderdetails JOIN products USING(productCode)\n WHERE priceEach &gt; 2 * buyPrice;    \n\n\nWhat is the total quantity on hand for products listed in orders with staus: ‘On Hold’? Rename the quantity ordered as ‘Total Ordered’ and the quantity in stock as ‘Total on Hand’. Use the ON syntax for the JOIN.\n\n\nSELECT products.productCode, SUM(quantityOrdered) AS 'Total Ordered', quantityInStock AS 'On Hand'\n FROM orders JOIN orderdetails JOIN products\n  ON orders.orderNumber = orderdetails.orderNumber\n  AND orderdetails.productCode = products.productCode\n WHERE status = 'On Hold'\n GROUP BY products.productCode;\n    \n\n\nReport product code, name and MSRP for all products that have not sold any units.\n\n\nSELECT productCode, productName, MSRP\n FROM products\n WHERE productCode NOT IN (SELECT DISTINCT productCode FROM orderdetails);  \n\n\n\n\n  \n  \n    © 2025. All Rights Reserved.\n  \n  \n\n  \n  \n    Enabled by Dr. Marcin Bartosiak"
  },
  {
    "objectID": "Homework2-solution.html",
    "href": "Homework2-solution.html",
    "title": "Homework2 solution",
    "section": "",
    "text": "The following queries use the classicmodels schema.\n\n\n\nSource: https://www.richardtwatson.com/\n\n\n\nHow many unique products are in the table products?\n\n\nSELECT COUNT(DISTINCT(productCode)) FROM products;\n\n\nWhat is the total number of products and the total quantity of all products?\n\n\nSELECT COUNT(productCode) AS TotalP, SUM(quantityInStock) AS TotalQ\nFROM products;\n  \n\n\nWhat are the minimum and maximum prices of products?\n\n\nSELECT MIN(buyPrice)AS minprice, MAX(buyPrice) AS maxprice FROM products;\n\n    \n\n\nProvide the number of products by product line (hint: use group by)\n\n\nSELECT COUNT(productCode) AS NumberOfProducts, productline \nFROM products \nGROUP BY productline;\n    \n\n\nReport the sales representative for each customer.\n\n\nSELECT customers.customerName, employees.lastName,employees.firstName\nFROM customers, employees \nWHERE customers.salesRepEmployeeNumber = employees.employeeNumber;\n\n\nReport the total payments by date.\n\n\nSELECT SUM(payments.amount) AS TotalP, paymentDate \nFROM payments \nGROUP BY paymentDate;\n    \n\n\nReport the products that have not been sold.\n\n\nSELECT  productName FROM products WHERE\nproductCode NOT IN\n (SELECT DISTINCT(productCode) FROM orderdetails);\n    \n\n\nList the amount paid by each customer.\n\n\nSELECT customers.customerName, SUM(payments.amount) AS Total \nFROM customers, payments\nWHERE customers.customerNumber = payments.customerNumber\nGROUP BY customers.customerNumber;\n    \n\n\nHow many orders have been placed by Herkku Gifts?\n\n\nSELECT COUNT(orderNumber) FROM orders WHERE customerNumber IN (\nSELECT customerNumber FROM customers WHERE customerName = 'Herkku Gifts');\n    \n\n\nWho are the employees in Boston?\n\n\nSELECT employees.firstName, employees.lastName FROM employees WHERE officeCode IN(\nSELECT officeCode FROM offices WHERE city = 'Boston');\n\n\nReport those payments greater than $100,000. Group the report by customer name. Sort the report so the customer who made the highest payment appears first.\n\n\nSELECT customers.customerName, SUM(payments.amount) AS Total\nFROM customers, payments \nWHERE customers.customerNumber = payments.customerNumber\nAND payments.amount &gt; 100000\nGROUP BY customerName\nORDER BY Total DESC;\n\n\n\n\n  \n  \n    © 2025. All Rights Reserved.\n  \n  \n\n  \n  \n    Enabled by Dr. Marcin Bartosiak"
  },
  {
    "objectID": "Homework2-solution.html#sql---homework-2---solution",
    "href": "Homework2-solution.html#sql---homework-2---solution",
    "title": "Homework2 solution",
    "section": "",
    "text": "The following queries use the classicmodels schema.\n\n\n\nSource: https://www.richardtwatson.com/\n\n\n\nHow many unique products are in the table products?\n\n\nSELECT COUNT(DISTINCT(productCode)) FROM products;\n\n\nWhat is the total number of products and the total quantity of all products?\n\n\nSELECT COUNT(productCode) AS TotalP, SUM(quantityInStock) AS TotalQ\nFROM products;\n  \n\n\nWhat are the minimum and maximum prices of products?\n\n\nSELECT MIN(buyPrice)AS minprice, MAX(buyPrice) AS maxprice FROM products;\n\n    \n\n\nProvide the number of products by product line (hint: use group by)\n\n\nSELECT COUNT(productCode) AS NumberOfProducts, productline \nFROM products \nGROUP BY productline;\n    \n\n\nReport the sales representative for each customer.\n\n\nSELECT customers.customerName, employees.lastName,employees.firstName\nFROM customers, employees \nWHERE customers.salesRepEmployeeNumber = employees.employeeNumber;\n\n\nReport the total payments by date.\n\n\nSELECT SUM(payments.amount) AS TotalP, paymentDate \nFROM payments \nGROUP BY paymentDate;\n    \n\n\nReport the products that have not been sold.\n\n\nSELECT  productName FROM products WHERE\nproductCode NOT IN\n (SELECT DISTINCT(productCode) FROM orderdetails);\n    \n\n\nList the amount paid by each customer.\n\n\nSELECT customers.customerName, SUM(payments.amount) AS Total \nFROM customers, payments\nWHERE customers.customerNumber = payments.customerNumber\nGROUP BY customers.customerNumber;\n    \n\n\nHow many orders have been placed by Herkku Gifts?\n\n\nSELECT COUNT(orderNumber) FROM orders WHERE customerNumber IN (\nSELECT customerNumber FROM customers WHERE customerName = 'Herkku Gifts');\n    \n\n\nWho are the employees in Boston?\n\n\nSELECT employees.firstName, employees.lastName FROM employees WHERE officeCode IN(\nSELECT officeCode FROM offices WHERE city = 'Boston');\n\n\nReport those payments greater than $100,000. Group the report by customer name. Sort the report so the customer who made the highest payment appears first.\n\n\nSELECT customers.customerName, SUM(payments.amount) AS Total\nFROM customers, payments \nWHERE customers.customerNumber = payments.customerNumber\nAND payments.amount &gt; 100000\nGROUP BY customerName\nORDER BY Total DESC;\n\n\n\n\n  \n  \n    © 2025. All Rights Reserved.\n  \n  \n\n  \n  \n    Enabled by Dr. Marcin Bartosiak"
  },
  {
    "objectID": "Homework1-solution.html",
    "href": "Homework1-solution.html",
    "title": "Homework 1 solution",
    "section": "",
    "text": "The following queries use the classicmodels schema. All queries use the products table.\n\n\n\n\n\n\n\nPrepare a list of products sorted by product name in descending order.\n\nSELECT * FROM products \n ORDER BY productName DESC;\n\nList the product names and their quantity available from high to low?\n\nSELECT productName, quantityInStock FROM products\n ORDER BY quantityInStock DESC;\n\nReport the MSRP for the products in “Vintage Cars” category?\n\nSELECT MSRP FROM products\n WHERE productLine = 'Vintage Cars';    \n\nReport the product(s) with the buy price of 48.81.\n\nSELECT * FROM products\n WHERE buyPrice = 48.81;   \n\nReport those products with the price greater than 70.\n\nSELECT * FROM products\n WHERE buyPrice &gt; 70;    \n\nWhich products have product scale ratio 1:10 and 1:72?\n\nSELECT * FROM products\n WHERE productScale IN ('1:10', '1:72');    \n\nList the product names except the ones in the Planes and Ships category.\n\nSELECT productName FROM products\n WHERE productLine NOT IN ('Planes', 'Ships');   \n\nReport the names of products excluding Motorcycles and Classic Cars.\n\nSELECT productName FROM products\n WHERE productLine NOT IN ('Motorcycles', 'Classic Cars');    \n\nReport the products having MSRP greater than 110.\n\nSELECT * FROM products\n WHERE MSRP &gt; 110;\n\nList the product vendors in ascending alphabetical order.\n\nSELECT DISTINCT productVendor FROM products\n ORDER BY productVendor ASC; \n\n\n\n\n\n\n\n\nTip\n\n\n\nASC is not obligatory. By default ORDER BY is asceding.\n\n\n\n\n\n  \n  \n    © 2025. All Rights Reserved.\n  \n  \n\n  \n  \n    Enabled by Dr. Marcin Bartosiak"
  },
  {
    "objectID": "Homework1-solution.html#sql---homework-1---solution",
    "href": "Homework1-solution.html#sql---homework-1---solution",
    "title": "Homework 1 solution",
    "section": "",
    "text": "The following queries use the classicmodels schema. All queries use the products table.\n\n\n\n\n\n\n\nPrepare a list of products sorted by product name in descending order.\n\nSELECT * FROM products \n ORDER BY productName DESC;\n\nList the product names and their quantity available from high to low?\n\nSELECT productName, quantityInStock FROM products\n ORDER BY quantityInStock DESC;\n\nReport the MSRP for the products in “Vintage Cars” category?\n\nSELECT MSRP FROM products\n WHERE productLine = 'Vintage Cars';    \n\nReport the product(s) with the buy price of 48.81.\n\nSELECT * FROM products\n WHERE buyPrice = 48.81;   \n\nReport those products with the price greater than 70.\n\nSELECT * FROM products\n WHERE buyPrice &gt; 70;    \n\nWhich products have product scale ratio 1:10 and 1:72?\n\nSELECT * FROM products\n WHERE productScale IN ('1:10', '1:72');    \n\nList the product names except the ones in the Planes and Ships category.\n\nSELECT productName FROM products\n WHERE productLine NOT IN ('Planes', 'Ships');   \n\nReport the names of products excluding Motorcycles and Classic Cars.\n\nSELECT productName FROM products\n WHERE productLine NOT IN ('Motorcycles', 'Classic Cars');    \n\nReport the products having MSRP greater than 110.\n\nSELECT * FROM products\n WHERE MSRP &gt; 110;\n\nList the product vendors in ascending alphabetical order.\n\nSELECT DISTINCT productVendor FROM products\n ORDER BY productVendor ASC; \n\n\n\n\n\n\n\n\nTip\n\n\n\nASC is not obligatory. By default ORDER BY is asceding.\n\n\n\n\n\n  \n  \n    © 2025. All Rights Reserved.\n  \n  \n\n  \n  \n    Enabled by Dr. Marcin Bartosiak"
  },
  {
    "objectID": "cdlibrary-solution.html",
    "href": "cdlibrary-solution.html",
    "title": "CD Library",
    "section": "",
    "text": "CD Library Challenge\n\n\n\n\n\n\nWelcome to the CD Library Database Challenge! In this exercise, you’ll put your SQL skills to work by querying a database that manages a collection of music CDs. As future business analysts and decision-makers, you’ll need to extract meaningful insights from company databases. This challenge simulates a real-world scenario where you’ll help a music store manager understand their inventory and track popular artists. Your task is to craft SQL queries that answer specific business questions and provide actionable intelligence.\n\n\n\n\n\n\nThis is the database model. It is a bit messy, but you will have to deal with it. \n\nWhat are the titles of the recordings on which Asleep at the Wheel appear?\n\nSELECT comptitle, grpcdrole\n   FROM composition JOIN recording\n  ON composition.compid = recording.compid\n  JOIN group_recording ON recording.rcdid = group_recording.rcdid\n  JOIN grp ON grp.grpid = group_recording.grpid\n  WHERE grpname = 'Asleep at the Wheel';\n\nList all CDs that have any tracks featuring Asleep at the Wheel.\n\nSELECT DISTINCT cd.cdid, cdtitle\n   FROM grp JOIN group_recording\n     ON grp.grpid = group_recording.grpid\n     JOIN recording ON  recording.rcdid = group_recording.rcdid\n    JOIN track ON recording.rcdid = track.rcdid\n    JOIN cd ON  cd.cdid = track.cdid \n    WHERE grpname = 'Asleep at the Wheel';\n\nWho are the members of Manhattan Transfer?\n\nSELECT psnfname, psnlname\n FROM grp JOIN person_group USING(grpid) JOIN person USING(psnid)\n WHERE grpname = 'Manhattan Transfer';\n\nWhat CDs feature Manhattan Transfer?\n\nSELECT cdtitle\n FROM grp JOIN group_cd USING(grpid) JOIN cd USING(cdid)\n WHERE grpname = 'Manhattan Transfer';\n\nFor what songs has John Hendricks written the lyrics?\n\nSELECT comptitle FROM person, person_composition, composition\n   WHERE person.psnid = person_composition.psnid\n   AND composition.compid = person_composition.compid\n   AND psnfname = 'John'\n   AND psnlname = 'Hendricks'\n   AND psncomprole = 'lyrics';\n\nReport all compositions and their composers where more than one person was involved in composing the music.\n\nSELECT comptitle, psnfname, psnlname, psncomprole\n   FROM composition, person_composition, person\n  WHERE person.psnid = person_composition.psnid\n  AND composition.compid = person_composition.compid\n  AND composition.compid IN\n     (SELECT compid FROM person_composition\n        GROUP BY compid HAVING COUNT(*) &gt; 1);\n\nList all CDs featuring more than one group.\n\nSELECT cdtitle\n   FROM cd, group_cd, grp\n  WHERE cd.cdid = group_cd.cdid\n  AND group_cd.grpid=grp.grpid\n  GROUP BY cdtitle\n  HAVING COUNT(*) &gt; 1;\n\nList the composers appearing on each CD.\n\nSELECT DISTINCT cdtitle, psnfname, psnlname \n FROM cd, person, person_composition, composition, recording, track\n  WHERE person.psnid = person_composition.psnid\n   AND composition.compid = person_composition.compid\n   AND composition.compid = recording.compid\n   AND recording.rcdid = track.rcdid\n   AND cd.cdid = track.cdid;\n\n\n\n\n\n  \n  \n    © 2025. All Rights Reserved.\n  \n  \n\n  \n  \n    Enabled by Dr. Marcin Bartosiak"
  },
  {
    "objectID": "6-many-to-many-recursive.html",
    "href": "6-many-to-many-recursive.html",
    "title": "One-to-One and Recursive relationship",
    "section": "",
    "text": "Warning\n\n\n\nTo try queries in this section, we will use Workbench.\nYou can also run them in your Python program."
  },
  {
    "objectID": "6-many-to-many-recursive.html#many-to-many-recursive-relationship",
    "href": "6-many-to-many-recursive.html#many-to-many-recursive-relationship",
    "title": "One-to-One and Recursive relationship",
    "section": "Many-to-Many Recursive Relationship",
    "text": "Many-to-Many Recursive Relationship\nA many-to-many recursive relationship occurs when an entity in a table has a relationship with itself. In this type of relationship, each record in the table can be associated with multiple records of the same table. This recursive structure is common when modeling hierarchical data or relationships where entities are interlinked in a complex, self-referential way.\nFor example, consider a company with employees, where each employee can have multiple managers, and each manager can also manage multiple employees. In this case, the relationship is between the same entity (employees), but each record can be connected to many other records of the same type.\nIn a relational database, this is typically represented by a table with a foreign key that references the primary key of the same table. This creates the recursive relationship, where one row can link to another row within the same table.\nA common example of this is a Bill of Materials (BOM) in manufacturing. In a BOM, an item can be made up of multiple components, and those components can also be composed of other sub-components. This creates a recursive relationship where each part (or component) is related to other parts within the same table.\n\n\n\n\n\n\n\n\n\nBy Thorsten Hartmann - Own work, CC BY-SA 3.0, https://commons.wikimedia.org/w/index.php?curid=735359\n\n\n\n\n\n\n\n\nThis allows us to model complex structures, such as corporate hierarchies, family trees, or organizational charts."
  },
  {
    "objectID": "6-many-to-many-recursive.html#subordinate-entity",
    "href": "6-many-to-many-recursive.html#subordinate-entity",
    "title": "One-to-One and Recursive relationship",
    "section": "Subordinate entity",
    "text": "Subordinate entity\nA subordinate entity refers to an entity in a database that depends on another entity (the primary entity) for its existence. The subordinate entity typically cannot exist without the primary entity and is linked by a one-to-one identifying relationship.\nFor example, imagine an animal entity that contains information about various animals like sheep and horses. The sheep and horse entities could both be considered subordinate to the animal entity, as they depend on it to define their shared characteristics (like species, ID, etc.).\n\nExample:\n\nA sheep entity might include attributes like fleeceweight (because a sheep is famous for its wool) to indicate how much wool it produces.\nA horse entity might include furlongspeed (the speed at which a horse can gallop a furlong — approximately 1/8th of a mile).\n\nNow, we typically do not collect fleece from horses. We are, most often, not interested in sheep’s speed (with some notable exceptions that are way baaayond the topic of this session…).\n\nIf we wanted to keep all these attributes in one table, we would have to deal with many NULL values.\n\nIn this case, the sheep and horse entities depend on the animal entity for classification and characteristics, but they also contain unique attributes like fleeceweight and furlongspeed to describe specific details about each species.\n\nBy modeling animals as subordinate entities, we ensure that every sheep and horse record has proper context and detailed attributes while keeping them organized under the broader animal category."
  },
  {
    "objectID": "6-many-to-many-recursive.html#regexp",
    "href": "6-many-to-many-recursive.html#regexp",
    "title": "One-to-One and Recursive relationship",
    "section": "REGEXP",
    "text": "REGEXP\nIn SQL, REGEXP (short for regular expression) is used to match a string against a pattern. It allows you to search for complex patterns in text data. It is often used to perform advanced searches, such as matching substrings, validating formats, or finding specific patterns in a column.\nIn your syntax, you write REGEXP in the WHERE clause instead of =.\n\nExample:\nSELECT name\nFROM employees\nWHERE name REGEXP '^A';  -- Finds names starting with the letter 'A'\nCommon Regular Expression Syntax:\n^ : Matches the start of a string.\n\n$ : Matches the end of a string.\n\n. : Matches any single character.\n\n* : Matches 0 or more occurrences of the preceding element.\n\n+ : Matches 1 or more occurrences of the preceding element.\n\n[] : Matches any character within the brackets.\n\nExamples\nList all brands containing ‘Hotel’ in their name.\n\nReport chains with ‘resort’ or ‘resorts’ in the chain name"
  },
  {
    "objectID": "6-many-to-many-recursive.html#set-operations---union-and-union-all",
    "href": "6-many-to-many-recursive.html#set-operations---union-and-union-all",
    "title": "One-to-One and Recursive relationship",
    "section": "Set operations - UNION and UNION ALL",
    "text": "Set operations - UNION and UNION ALL\nSet operations in SQL are used to combine the results of two or more SELECT queries into a single result set. These operations allow you to perform tasks like merging data, comparing results, or finding common elements between queries.\n\nUNION\nThe UNION operator combines the results of two or more SELECT queries into one result set, eliminating duplicates. It ensures that each row in the result set is unique, even if the same data appears in both queries.\nSELECT column1, column2, ...\nFROM table1\nUNION\nSELECT column1, column2, ...\nFROM table2;\n\nExample\nList all the hotel name, city and star rating of hotels in Dallas or hotels that have ‘Palace’ in their name.\n\nYou can do the same with OR. UNION very often will return similar results.\nSELECT DISTINCT hotelName, hotelStarRating, hotelCity\n FROM hotel\n WHERE hotelCity = 'Dallas'\n OR hotelName REGEXP 'Palace';\n\n\n\nUNION ALL\nUNION ALL is similar to UNION, but it does not eliminate duplicates. It will combine the results of both queries, including duplicates.\nSELECT column1, column2, ...\nFROM table1\nUNION ALL\nSELECT column1, column2, ...\nFROM table2;\n\nExample\nFor all reviews of the hotel Id = 73242 merge room and cleanliness ratings. Rename the field as ‘Merged Reviews’.\n\n\n\nChallenge\nCount the number of brands each lodging chain owns. Rename the count as Total Brands. DO NOT USE OUTER JOIN\nThis is how you could try to write this query with OUTER JOIN\nSELECT chainName, COUNT(brandId) AS `Total Brands`\n FROM lodgingchain LEFT JOIN brand USING(chainId)\n GROUP BY chainName\n ORDER BY COUNT(brandId);\nThis is the solution withou OUTER JOIN\n\n\n\n\nImages and GIFs Disclaimer: Some of the images and GIFs used on this website are not owned by me. They are used for educational and illustrative purposes only. All rights belong to their respective owners. If you believe any content violates copyright, please contact me for prompt removal.\n\n\n\n\n\n\n  \n  \n    © 2025. All Rights Reserved.\n  \n  \n\n  \n  \n    Enabled by Dr. Marcin Bartosiak"
  },
  {
    "objectID": "5-one-to-one-and-recursive.html",
    "href": "5-one-to-one-and-recursive.html",
    "title": "One-to-One and Recursive relationship",
    "section": "",
    "text": "Warning\n\n\n\nRecursive relationship is a bit more complex and it won’t work on the website. To try queries in this section, we will use Workbench.\nYou can also run them in your Python program."
  },
  {
    "objectID": "5-one-to-one-and-recursive.html#modelling-one-to-one-relationship",
    "href": "5-one-to-one-and-recursive.html#modelling-one-to-one-relationship",
    "title": "One-to-One and Recursive relationship",
    "section": "Modelling one-to-one relationship",
    "text": "Modelling one-to-one relationship\nLet’s consider this organizational chart. We can clarely see that each (one) department has a (one) head.\n\n\n1:1 relationship is labeled\n\nA relationship descriptor\n\nObvious relationships are not labeled"
  },
  {
    "objectID": "5-one-to-one-and-recursive.html#querying-one-to-one-relationship",
    "href": "5-one-to-one-and-recursive.html#querying-one-to-one-relationship",
    "title": "One-to-One and Recursive relationship",
    "section": "Querying One-to-One Relationship",
    "text": "Querying One-to-One Relationship\nGOOD NEWS! Querying one-to-one relationship works EXACTLY like the queries you already know :D .\nWe will use these new tables:\n\nList the hotel name, first name and title of each hotel’s contact employee.\n\nFor reviews with a response, find the total number of reviews posted and their average response time in days for all reviews posted on Valentine’s day (2011-02-14). ((DATEDIFF(date2, date1) – calculates the difference between two dates)"
  },
  {
    "objectID": "5-one-to-one-and-recursive.html#modelling-recursive-relationship",
    "href": "5-one-to-one-and-recursive.html#modelling-recursive-relationship",
    "title": "One-to-One and Recursive relationship",
    "section": "Modelling recursive relationship",
    "text": "Modelling recursive relationship\nLet’s go back to our organizational chart. There is more here…\n\n\nA recursive relationship relates an entity to itself\nLabel recursive relationships"
  },
  {
    "objectID": "5-one-to-one-and-recursive.html#querying-recursive-relationship",
    "href": "5-one-to-one-and-recursive.html#querying-recursive-relationship",
    "title": "One-to-One and Recursive relationship",
    "section": "Querying recursive relationship",
    "text": "Querying recursive relationship\nA recursive relationship in a database, also known as a self-join, is when a table is joined with itself to represent relationships within the same entity. This technique is often used to model hierarchical or parent-child relationships, such as employees managing other employees. To perform a self-join, table aliasing is required so that the same table can be referenced multiple times in a query. For instance, using the alias boss in:\nFROM employee AS boss\nallows the query to distinguish between the employee acting as the manager and the one being managed. This approach is essential for querying and understanding internal relationships within a single table.\nOpen your Workbench and find the name of Leo Lee’s boss."
  },
  {
    "objectID": "4-server-conn.html",
    "href": "4-server-conn.html",
    "title": "Server Connections",
    "section": "",
    "text": "In many business applications, databases are stored on a server rather than on your local machine or a website. A database server is a specialized system designed to store, manage, and process large amounts of data efficiently. Instead of accessing a file directly, we need to connect to the database server to send queries and retrieve data.\n\n\n\nCentralized Data Storage: The database is stored in one place and can be accessed by multiple users.\n\nSecurity & Access Control: Connections require authentication (e.g., username, password) to ensure only authorized users can access the data.\n\nPerformance Optimization: Server-based databases handle large-scale queries more efficiently than local databases.\n\nRemote Access: You can connect to a database server from different locations, allowing for flexible data management.\n\n\n\n\n\nTo connect to a MySQL database server using Python, we use the mysql-connector library. We will run this code in Colab.\nFirst, we need to import a library that will allow us to connect to the server. If you have never used it, you may need to install that library first.\n\n!pip install mysql-connector-python\n\nimport mysql.connector\n\nOnce we have our library loaded, we can establish the connection specyfing the host, user, password, and database name. You can get the credentials from the instructor.\n\n# Establish connection\nconn = mysql.connector.connect(\n    host=\"\",\n    user=\"\",\n    password=\"\",\n    database=\"\"\n)\n\nCreating a Cursor\nA cursor in SQL is a special database object used to retrieve, manipulate, and navigate through query results row by row. When executing a SQL query, the result is typically returned as a set of rows. A cursor allows you to process each row individually, making it useful for scenarios where you need fine-grained control over query results.\nIn Python, when connecting to a database, we use a cursor object to execute SQL queries and retrieve results.\nNotice how the cursor uses the conncetion you created in the previous cell.\n\ncursor = conn.cursor()\n\nOnce you have the cursor ready, you can run a simple query.\n\ncursor.execute(\"SELECT * FROM brand;\")\n\nIn Python, just running a query is not enough. We have sent a request to the server, but now we want the server to fetch (return) the results and store them in a Python variable.\n\nresults = cursor.fetchall()\n\nOnce we have the results, we can write a simple loop to read them, line by line.\n\nresults = cursor.fetchall()\nfor row in results:\n    print(row)\n\nFinally, we ALWAYS close the cursor and the connection after getting the results.\n\ncursor.close()\nconn.close()\n\n\n\n\nConnect to the database server by specifying the host, user, password, and database name.\nUse a cursor to execute SQL queries.\nFetch and display results.\nAlways close the connection to free up resources.\n\n\n\n\nNow, I think we can agree that these results look ugly. We can easily transform them into a nicely looking data frame using pandas library.\nPandas is a powerful and popular Python library used for data analysis and manipulation. It provides data structures and functions that make it easy to work with structured data, such as tables and spreadsheets. Pandas is commonly used in data science, business analytics, and machine learning.\n\nimport pandas as pd\ndf = pd.DataFrame(results, columns=[\"id\", \"hotelName\", \"segment\", \"minSqFeet\", \"chainName\"]) \n\n\n\n\n\nCopy the code and try to run in Colab.\n\n!pip install mysql-connector-python\nimport mysql.connector\nimport pandas as pd\n\n# Establish connection\nconn = mysql.connector.connect(\n    host=\"your_server_address\",\n    user=\"your_username\",\n    password=\"your_password\",\n    database=\"your_database\"\n)\n\n# Create a cursor to execute SQL queries\ncursor = conn.cursor()\n\n# Run a simple query\ncursor.execute(\"SELECT * FROM employees;\")\n\n# Fetch results\nresults = cursor.fetchall()\nfor row in results:\n    print(row)\n\n# Close the connection\ncursor.close()\nconn.close()\n\n# Create a data frame\ndf = pd.DataFrame(results, columns=[\"id\", \"hotelName\", \"segment\", \"minSqFeet\", \"chainName\"]) \n\n\n\n\nWe can do the same thing in a slightly more efficient way using sqlalchemy library.\nSQLAlchemy is a popular Python library used for working with relational databases. It provides an Object-Relational Mapping (ORM) system, which allows you to map Python objects to database tables, making it easier to interact with databases without writing raw SQL queries.\nWe will run this code in Colab.\nFirst, we install and import all needed libraries.\n\n!pip install PyMySQL\n\nfrom sqlalchemy import create_engine\nimport pandas as pd\n\nSecond, we create a connection string using the same values as before. This string may seem more complex, because it’s written in one line. However, if you pay attention, these are the same elements as before.\n\ndb_connection_str = 'mysql+pymysql://user:password@host/database'\n\nThen, we create a connection engine - this is an equivalent our cursor in the previous example.\n\ndb_connection = create_engine(db_connection_str)\n\nFinally, we can run our query and store it in a dataframe. Notice, that we do it in just one line of code, thanks to compatybility of pandas with sqlalchemy.\n\ndf = pd.read_sql('SELECT * FROM brand', con=db_connection)\n\n\n\n\nMySQL Workbench provides a graphical interface to connect to a database server and run queries without writing code.\n\n\n\nOpen MySQL Workbench.\n\nClick on + (New Connection) to create a new database connection.\n\nEnter the following details:\n\nConnection Name: Any descriptive name (e.g., “BusinessDB Connection”)\n\nHostname: The database server address (e.g., localhost or 192.168.1.10)\n\nPort: Default MySQL port is 3306.\n\nUsername: Your MySQL username.\n\nPassword: Click “Store in Vault” to save your password securely.\n\n\nClick Test Connection to verify if the credentials are correct.\n\nOnce connected, go to the SQL Editor to run queries.\n\n\n\n\n\nAfter connecting, open a new SQL query tab.\n\nType your SQL query, such as:\n```sql SELECT * FROM employees;\nClick the Execute (▶️) button to run the query.\nView the results in the output panel.\n\nUsing MySQL Workbench makes it easy to visually interact with your database, manage connections, and execute queries efficiently. 🚀\n\n\n\nImages and GIFs Disclaimer: Some of the images and GIFs used on this website are not owned by me. They are used for educational and illustrative purposes only. All rights belong to their respective owners. If you believe any content violates copyright, please contact me for prompt removal.\n\n\n\n\n\n\n  \n  \n    © 2025. All Rights Reserved.\n  \n  \n\n  \n  \n    Enabled by Dr. Marcin Bartosiak"
  },
  {
    "objectID": "4-server-conn.html#why-do-we-need-to-connect-to-a-database-server",
    "href": "4-server-conn.html#why-do-we-need-to-connect-to-a-database-server",
    "title": "Server Connections",
    "section": "",
    "text": "Centralized Data Storage: The database is stored in one place and can be accessed by multiple users.\n\nSecurity & Access Control: Connections require authentication (e.g., username, password) to ensure only authorized users can access the data.\n\nPerformance Optimization: Server-based databases handle large-scale queries more efficiently than local databases.\n\nRemote Access: You can connect to a database server from different locations, allowing for flexible data management."
  },
  {
    "objectID": "4-server-conn.html#connecting-to-a-mysql-database-in-python-with-mysql-connector",
    "href": "4-server-conn.html#connecting-to-a-mysql-database-in-python-with-mysql-connector",
    "title": "Server Connections",
    "section": "",
    "text": "To connect to a MySQL database server using Python, we use the mysql-connector library. We will run this code in Colab.\nFirst, we need to import a library that will allow us to connect to the server. If you have never used it, you may need to install that library first.\n\n!pip install mysql-connector-python\n\nimport mysql.connector\n\nOnce we have our library loaded, we can establish the connection specyfing the host, user, password, and database name. You can get the credentials from the instructor.\n\n# Establish connection\nconn = mysql.connector.connect(\n    host=\"\",\n    user=\"\",\n    password=\"\",\n    database=\"\"\n)\n\nCreating a Cursor\nA cursor in SQL is a special database object used to retrieve, manipulate, and navigate through query results row by row. When executing a SQL query, the result is typically returned as a set of rows. A cursor allows you to process each row individually, making it useful for scenarios where you need fine-grained control over query results.\nIn Python, when connecting to a database, we use a cursor object to execute SQL queries and retrieve results.\nNotice how the cursor uses the conncetion you created in the previous cell.\n\ncursor = conn.cursor()\n\nOnce you have the cursor ready, you can run a simple query.\n\ncursor.execute(\"SELECT * FROM brand;\")\n\nIn Python, just running a query is not enough. We have sent a request to the server, but now we want the server to fetch (return) the results and store them in a Python variable.\n\nresults = cursor.fetchall()\n\nOnce we have the results, we can write a simple loop to read them, line by line.\n\nresults = cursor.fetchall()\nfor row in results:\n    print(row)\n\nFinally, we ALWAYS close the cursor and the connection after getting the results.\n\ncursor.close()\nconn.close()\n\n\n\n\nConnect to the database server by specifying the host, user, password, and database name.\nUse a cursor to execute SQL queries.\nFetch and display results.\nAlways close the connection to free up resources.\n\n\n\n\nNow, I think we can agree that these results look ugly. We can easily transform them into a nicely looking data frame using pandas library.\nPandas is a powerful and popular Python library used for data analysis and manipulation. It provides data structures and functions that make it easy to work with structured data, such as tables and spreadsheets. Pandas is commonly used in data science, business analytics, and machine learning.\n\nimport pandas as pd\ndf = pd.DataFrame(results, columns=[\"id\", \"hotelName\", \"segment\", \"minSqFeet\", \"chainName\"])"
  },
  {
    "objectID": "4-server-conn.html#full-code",
    "href": "4-server-conn.html#full-code",
    "title": "Server Connections",
    "section": "",
    "text": "Copy the code and try to run in Colab.\n\n!pip install mysql-connector-python\nimport mysql.connector\nimport pandas as pd\n\n# Establish connection\nconn = mysql.connector.connect(\n    host=\"your_server_address\",\n    user=\"your_username\",\n    password=\"your_password\",\n    database=\"your_database\"\n)\n\n# Create a cursor to execute SQL queries\ncursor = conn.cursor()\n\n# Run a simple query\ncursor.execute(\"SELECT * FROM employees;\")\n\n# Fetch results\nresults = cursor.fetchall()\nfor row in results:\n    print(row)\n\n# Close the connection\ncursor.close()\nconn.close()\n\n# Create a data frame\ndf = pd.DataFrame(results, columns=[\"id\", \"hotelName\", \"segment\", \"minSqFeet\", \"chainName\"])"
  },
  {
    "objectID": "4-server-conn.html#connecting-to-a-mysql-database-in-python-with-sqlalchemy",
    "href": "4-server-conn.html#connecting-to-a-mysql-database-in-python-with-sqlalchemy",
    "title": "Server Connections",
    "section": "",
    "text": "We can do the same thing in a slightly more efficient way using sqlalchemy library.\nSQLAlchemy is a popular Python library used for working with relational databases. It provides an Object-Relational Mapping (ORM) system, which allows you to map Python objects to database tables, making it easier to interact with databases without writing raw SQL queries.\nWe will run this code in Colab.\nFirst, we install and import all needed libraries.\n\n!pip install PyMySQL\n\nfrom sqlalchemy import create_engine\nimport pandas as pd\n\nSecond, we create a connection string using the same values as before. This string may seem more complex, because it’s written in one line. However, if you pay attention, these are the same elements as before.\n\ndb_connection_str = 'mysql+pymysql://user:password@host/database'\n\nThen, we create a connection engine - this is an equivalent our cursor in the previous example.\n\ndb_connection = create_engine(db_connection_str)\n\nFinally, we can run our query and store it in a dataframe. Notice, that we do it in just one line of code, thanks to compatybility of pandas with sqlalchemy.\n\ndf = pd.read_sql('SELECT * FROM brand', con=db_connection)"
  },
  {
    "objectID": "4-server-conn.html#connecting-to-mysql-using-mysql-workbench",
    "href": "4-server-conn.html#connecting-to-mysql-using-mysql-workbench",
    "title": "Server Connections",
    "section": "",
    "text": "MySQL Workbench provides a graphical interface to connect to a database server and run queries without writing code.\n\n\n\nOpen MySQL Workbench.\n\nClick on + (New Connection) to create a new database connection.\n\nEnter the following details:\n\nConnection Name: Any descriptive name (e.g., “BusinessDB Connection”)\n\nHostname: The database server address (e.g., localhost or 192.168.1.10)\n\nPort: Default MySQL port is 3306.\n\nUsername: Your MySQL username.\n\nPassword: Click “Store in Vault” to save your password securely.\n\n\nClick Test Connection to verify if the credentials are correct.\n\nOnce connected, go to the SQL Editor to run queries.\n\n\n\n\n\nAfter connecting, open a new SQL query tab.\n\nType your SQL query, such as:\n```sql SELECT * FROM employees;\nClick the Execute (▶️) button to run the query.\nView the results in the output panel.\n\nUsing MySQL Workbench makes it easy to visually interact with your database, manage connections, and execute queries efficiently. 🚀\n\n\n\nImages and GIFs Disclaimer: Some of the images and GIFs used on this website are not owned by me. They are used for educational and illustrative purposes only. All rights belong to their respective owners. If you believe any content violates copyright, please contact me for prompt removal.\n\n\n\n\n\n\n  \n  \n    © 2025. All Rights Reserved.\n  \n  \n\n  \n  \n    Enabled by Dr. Marcin Bartosiak"
  },
  {
    "objectID": "3-many-to-many.html",
    "href": "3-many-to-many.html",
    "title": "Many-to-Many relationship",
    "section": "",
    "text": "One-to-many relationship will not always be enough to represent all the situations in real life.\n\n\nA sales form is a document or (digital) record that captures details of a sale, including the products sold, the quantities, the price, the date, and the customer information.\n\nIf you think about it, it would be hard to design a one-to-many relationship for a sales form:\n\nYou can sell (conceptually) the same item many times. (E.g. Yesterday you sold two IPhones. Today you also sold an IPhone.)\nIn one sale, you can sell various products. (E.g. A client bought an Iphone and an IPad.)\n\nTo represent this situation in database modeling, we would need a many-to-many relationship between sales and products. This is because a single sale can include multiple products, and the same product can be sold in multiple sales. To model this relationship, a junction table (often called sales_details or order_items) is used, linking the sales table (which stores each transaction) with the products table. This table typically includes fields such as sale_id, product_id, quantity, and price. The many-to-many nature of this relationship allows for flexibility in tracking sales history and inventory management.\n\n\n\nIn a many-to-many (m:m) relationship, a third entity is required to properly map the connection between the two related entities. This third entity, known as an associative entity, acts as a bridge between them.\n\nIn database modeling, the associative table includes two foreign keys, one for each of the entities in the m:m relationship, ensuring that each instance of the relationship is properly recorded. Additionally, a foreign key can also be part of the primary key of the associative entity.\n\nFor example, in a sales database, a LINEITEM table is used to associate SALE and PRODUCT. The LINEITEM table is identified by concatenating lineno and saleno, as indicated by the + on the crow’s foot notation. This structure ensures data integrity and enforces the same relational rules as any other table in the database.\nAs you already know the concepts related to the implementable model, let’s take a look at many-to-many model:\n\n\n\nLet’s go back to our hotel database. So far it was a fairly simple database. However, its’ main purpose is not to track hotels. It stores data about hotel reviews, scraped from the Internet.\n\nHow would you model the following scenario? - An author can write reviews about many hotels. - A hotel can have reviews written by many authors.\n\n\n\n\nSo far, we’ve learned how to join tables using the WHERE clause—this is known as an implicit join.\n\n\n\n\n\n\nNote\n\n\n\nImplicit JOIN (OR “Comma syntax” JOIN)\nSELECT ... FROM ..., ... WHERE fk = pk;\nSELECT * FROM table1, table2 WHERE table1.id = table2.id;\n\n\nWhile implicit joins work, SQL also provides a more structured way to combine tables: explicit joins using keywords like JOIN ... ON.\nThe key difference is that implicit joins mix filtering (WHERE) with table relationships, making queries harder to read as they grow. Explicit joins, on the other hand, separate the logic of joining tables from filtering rows, improving readability and maintainability.\n\n\n\n\n\n\nNote\n\n\n\nExplicit JOIN\nSELECT ... FROM ... JOIN ... ON fk = pk;\nSELECT * FROM table1 JOIN table2 ON table1.id = table2.id;\n\n\nDifferent join syntaxes exist because SQL is designed to be flexible. In some cases, explicit joins provide better performance and clarity, especially when dealing with complex queries or different types of joins (we will see them later).\nThere many ways to JOIN tbles in SQL. All these methods are called Equijoin.\nCompare These queries:\n\nSELECT * FROM brand, lodgingchain WHERE brand.chainId = lodgingchain.chainId;\n\n\nSELECT * FROM brand JOIN lodgingchain ON brand.chainId = lodgingchain.chainId;\n\n\nSELECT * FROM brand NATURAL JOIN lodgingchain;\n\n\nSELECT * FROM brand JOIN lodgingchain USING(chainId);\n\n\n\nList the authors that have reviewed hotels. Report the author name, the hotel ID and the name of the hotels. Order the output by author name.\nUse all four methods\nimplicit JOIN (WHERE)\n\n\n\nNATURAL JOIN\n\n\n\nJOIN … USING\n\n\n\nJOIN … ON\n\n\n\n\n\nNATURAL JOIN\n\nJoin on “same” column (name and data type)\nRisky: the condition is implicit\n\nUSING()\n\nExplicitly specifies columns in the equijoin\nAllows multiple (comma separated) columns\n\nON\n\nThe ON clause enables multiple conditions\nLogical operator can be used to combine condition\nON and USING are mutually exclusive\nON enables inequality joins (Theta JOIN – more later)\n\n\n\n\n\nSo far, you’ve learner about INNER JOIN, which is the JOIN that returns only the rows that have matching values in both tables based on a specified condition. It eliminates unmatched rows from both tables, ensuring that only records with a relationship between them appear in the result set.\nHowever, there are different JOINS too. An OUTER JOIN is a powerful SQL feature used when you want to retain “dangling tuples”—rows that don’t have a match in the other table. Unlike inner joins, which only return matching records, outer joins ensure that unmatched rows from one or both tables are included in the results. These missing values are padded with NULLs based on the type of outer join used.\n\nA LEFT OUTER JOIN returns all rows from the left table, along with matching rows from the right table. If there’s no match, NULLs are used for the right table’s columns.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSELECT * FROM t1 LEFT OUTER JOIN t2 USING (id);\n\n\n\n\nA RIGHT OUTER JOIN does the opposite—it keeps all rows from the right table and includes matching rows from the left table, filling in NULLs when no match is found.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSELECT * FROM t1 RIGHT OUTER JOIN t2 USING (id);\n\n\n\n\nA FULL OUTER JOIN includes all rows from both tables, ensuring that even non-matching rows from either table appear, with NULLs where data is missing.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSELECT * FROM t1 RIGHT OUTER JOIN t2 USING (id);\n\n\n\nOuter joins are especially useful for analyzing incomplete data, maintaining records even when relationships are not fully established, and ensuring that no important information is lost in queries.\n\n\n\nProvide a list of all chain names and their respective brands. Order the list by chain name.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThat’s it for this lesson on SQL joins! Understanding how to combine data from multiple tables is a crucial skill for making informed business decisions. Whether you’re analyzing sales trends, tracking customer behavior, or managing inventory, SQL joins help you unlock valuable insights from your data. As you continue learning, you’ll discover even more ways to refine and optimize your queries. Keep practicing, and soon, you’ll be confidently using SQL to drive smarter business strategies! 🚀\n\n\n\n\n\n\n\n\n\nImages and GIFs Disclaimer: Some of the images and GIFs used on this website are not owned by me. They are used for educational and illustrative purposes only. All rights belong to their respective owners. If you believe any content violates copyright, please contact me for prompt removal.\n\n\n\n\n\n\n  \n  \n    © 2025. All Rights Reserved.\n  \n  \n\n  \n  \n    Enabled by Dr. Marcin Bartosiak"
  },
  {
    "objectID": "3-many-to-many.html#a-sales-form-example",
    "href": "3-many-to-many.html#a-sales-form-example",
    "title": "Many-to-Many relationship",
    "section": "",
    "text": "A sales form is a document or (digital) record that captures details of a sale, including the products sold, the quantities, the price, the date, and the customer information.\n\nIf you think about it, it would be hard to design a one-to-many relationship for a sales form:\n\nYou can sell (conceptually) the same item many times. (E.g. Yesterday you sold two IPhones. Today you also sold an IPhone.)\nIn one sale, you can sell various products. (E.g. A client bought an Iphone and an IPad.)\n\nTo represent this situation in database modeling, we would need a many-to-many relationship between sales and products. This is because a single sale can include multiple products, and the same product can be sold in multiple sales. To model this relationship, a junction table (often called sales_details or order_items) is used, linking the sales table (which stores each transaction) with the products table. This table typically includes fields such as sale_id, product_id, quantity, and price. The many-to-many nature of this relationship allows for flexibility in tracking sales history and inventory management."
  },
  {
    "objectID": "3-many-to-many.html#implementing-many-to-many",
    "href": "3-many-to-many.html#implementing-many-to-many",
    "title": "Many-to-Many relationship",
    "section": "",
    "text": "In a many-to-many (m:m) relationship, a third entity is required to properly map the connection between the two related entities. This third entity, known as an associative entity, acts as a bridge between them.\n\nIn database modeling, the associative table includes two foreign keys, one for each of the entities in the m:m relationship, ensuring that each instance of the relationship is properly recorded. Additionally, a foreign key can also be part of the primary key of the associative entity.\n\nFor example, in a sales database, a LINEITEM table is used to associate SALE and PRODUCT. The LINEITEM table is identified by concatenating lineno and saleno, as indicated by the + on the crow’s foot notation. This structure ensures data integrity and enforces the same relational rules as any other table in the database.\nAs you already know the concepts related to the implementable model, let’s take a look at many-to-many model:\n\n\n\nLet’s go back to our hotel database. So far it was a fairly simple database. However, its’ main purpose is not to track hotels. It stores data about hotel reviews, scraped from the Internet.\n\nHow would you model the following scenario? - An author can write reviews about many hotels. - A hotel can have reviews written by many authors."
  },
  {
    "objectID": "3-many-to-many.html#database-manipulation",
    "href": "3-many-to-many.html#database-manipulation",
    "title": "Many-to-Many relationship",
    "section": "",
    "text": "So far, we’ve learned how to join tables using the WHERE clause—this is known as an implicit join.\n\n\n\n\n\n\nNote\n\n\n\nImplicit JOIN (OR “Comma syntax” JOIN)\nSELECT ... FROM ..., ... WHERE fk = pk;\nSELECT * FROM table1, table2 WHERE table1.id = table2.id;\n\n\nWhile implicit joins work, SQL also provides a more structured way to combine tables: explicit joins using keywords like JOIN ... ON.\nThe key difference is that implicit joins mix filtering (WHERE) with table relationships, making queries harder to read as they grow. Explicit joins, on the other hand, separate the logic of joining tables from filtering rows, improving readability and maintainability.\n\n\n\n\n\n\nNote\n\n\n\nExplicit JOIN\nSELECT ... FROM ... JOIN ... ON fk = pk;\nSELECT * FROM table1 JOIN table2 ON table1.id = table2.id;\n\n\nDifferent join syntaxes exist because SQL is designed to be flexible. In some cases, explicit joins provide better performance and clarity, especially when dealing with complex queries or different types of joins (we will see them later).\nThere many ways to JOIN tbles in SQL. All these methods are called Equijoin.\nCompare These queries:\n\nSELECT * FROM brand, lodgingchain WHERE brand.chainId = lodgingchain.chainId;\n\n\nSELECT * FROM brand JOIN lodgingchain ON brand.chainId = lodgingchain.chainId;\n\n\nSELECT * FROM brand NATURAL JOIN lodgingchain;\n\n\nSELECT * FROM brand JOIN lodgingchain USING(chainId);\n\n\n\nList the authors that have reviewed hotels. Report the author name, the hotel ID and the name of the hotels. Order the output by author name.\nUse all four methods\nimplicit JOIN (WHERE)\n\n\n\nNATURAL JOIN\n\n\n\nJOIN … USING\n\n\n\nJOIN … ON\n\n\n\n\n\nNATURAL JOIN\n\nJoin on “same” column (name and data type)\nRisky: the condition is implicit\n\nUSING()\n\nExplicitly specifies columns in the equijoin\nAllows multiple (comma separated) columns\n\nON\n\nThe ON clause enables multiple conditions\nLogical operator can be used to combine condition\nON and USING are mutually exclusive\nON enables inequality joins (Theta JOIN – more later)\n\n\n\n\n\nSo far, you’ve learner about INNER JOIN, which is the JOIN that returns only the rows that have matching values in both tables based on a specified condition. It eliminates unmatched rows from both tables, ensuring that only records with a relationship between them appear in the result set.\nHowever, there are different JOINS too. An OUTER JOIN is a powerful SQL feature used when you want to retain “dangling tuples”—rows that don’t have a match in the other table. Unlike inner joins, which only return matching records, outer joins ensure that unmatched rows from one or both tables are included in the results. These missing values are padded with NULLs based on the type of outer join used.\n\nA LEFT OUTER JOIN returns all rows from the left table, along with matching rows from the right table. If there’s no match, NULLs are used for the right table’s columns.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSELECT * FROM t1 LEFT OUTER JOIN t2 USING (id);\n\n\n\n\nA RIGHT OUTER JOIN does the opposite—it keeps all rows from the right table and includes matching rows from the left table, filling in NULLs when no match is found.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSELECT * FROM t1 RIGHT OUTER JOIN t2 USING (id);\n\n\n\n\nA FULL OUTER JOIN includes all rows from both tables, ensuring that even non-matching rows from either table appear, with NULLs where data is missing.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSELECT * FROM t1 RIGHT OUTER JOIN t2 USING (id);\n\n\n\nOuter joins are especially useful for analyzing incomplete data, maintaining records even when relationships are not fully established, and ensuring that no important information is lost in queries.\n\n\n\nProvide a list of all chain names and their respective brands. Order the list by chain name."
  },
  {
    "objectID": "3-many-to-many.html#extra-practice-cell",
    "href": "3-many-to-many.html#extra-practice-cell",
    "title": "Many-to-Many relationship",
    "section": "",
    "text": "That’s it for this lesson on SQL joins! Understanding how to combine data from multiple tables is a crucial skill for making informed business decisions. Whether you’re analyzing sales trends, tracking customer behavior, or managing inventory, SQL joins help you unlock valuable insights from your data. As you continue learning, you’ll discover even more ways to refine and optimize your queries. Keep practicing, and soon, you’ll be confidently using SQL to drive smarter business strategies! 🚀\n\n\n\n\n\n\n\n\n\nImages and GIFs Disclaimer: Some of the images and GIFs used on this website are not owned by me. They are used for educational and illustrative purposes only. All rights belong to their respective owners. If you believe any content violates copyright, please contact me for prompt removal.\n\n\n\n\n\n\n  \n  \n    © 2025. All Rights Reserved.\n  \n  \n\n  \n  \n    Enabled by Dr. Marcin Bartosiak"
  },
  {
    "objectID": "2-one-to-many.html",
    "href": "2-one-to-many.html",
    "title": "One-to-Many relationship",
    "section": "",
    "text": "Now that you’ve learned how to model a basic, single-entity database, let’s explore attributes, which define the characteristics of an entity.\n\n\nAttributes store important details about each record in a table, helping to describe and organize data effectively.\nIn a database, attributes can be classified based on whether they require a value. A required attribute must always have a value and cannot be left empty, while an optional attribute can be left empty (NULL).\n\n\n\n\n\n\nWarning\n\n\n\nWe use NULL to indicate missing values. Missing values can occur for different reasons, such as an existing attribute without data (e.g., a middle name) or an inapplicable condition (e.g., an apartment number for a house address).\nDon’t confuse NULL values with blank or zero.\nMultiple meanings:\n\nUnknown data\nInapplicable data\nNo value supplied\nValue undefined\n\nWe will come back to NULL values later.\n\n\nEach attribute has a domain, which defines the set of possible values it can take.\n\n\n\n\n\n\nTip\n\n\n\nA domain is the set of possible values that an attribute can have. Think of it like a rule that defines what kind of data is allowed in a column. For example, if you have an attribute “Age,” its domain might be whole numbers between 0 and 120. If you have a “Country” attribute, its domain would be a list of valid country names. Domains help keep data consistent and prevent errors, like entering text in a column meant for numbers.\n\n\nTo uniquely identify each record, identifiers are used—these are attributes that hold unique values for each instance. In relational databases, the primary key serves as this unique identifier.\nSometimes, a composite identifier is needed, which combines two or more attributes to uniquely identify a record (e.g., a combination of Course ID and Student ID to track enrollments).\nAttributes can be classified into different types:\n\nComposite attribute: Attribute that can be subdivided to yield additional attributes\nSimple attribute: Attribute that cannot be subdivided\nDerived attribute: Attribute whose value is calculated from other attributes\n\nDerived using an algorithm (i.e., Yield = Dividend * Quantity)\nSometimes called ‘calculated fields’\n\nSingle-valued attribute: Attribute that holds only a single value\nMultivalued attributes: Attributes that hold many values\n\nUnderstanding these attribute types is essential for designing efficient databases that accurately represent real-world scenarios.\n\n\n\nThink of the data scientists database we modeled last week.\n\n\n\n\n\nHow would the model change, if our data scientist could get a second degree? Or multiple certificates?\nA multivalued attribute is an attribute that can have multiple values for a single entity. For example, an employee might have multiple phone numbers or an author might write multiple books. In database design, multivalued attributes should be handled properly to maintain data consistency. One approach is to create separate attributes for each component of the multivalued attribute (e.g., Phone_1, Phone_2). A better approach is to create a new entity that holds the multiple values, linking it to the original entity through a relationship (e.g., an Employee_Phone table linked to an Employee table). This ensures better organization, eliminates redundancy, and improves data integrity.\nNow, try to apply that knowledge to our data scientists database.\n\n\n\nThere is one more new thing in the model above. Habe you noticed that the entities are “linked”. These are entity relationships.\nIn database design, relationships define how different entities (tables) are associated with one another. These relationships follow business rules, which describe how entities interact based on real-world scenarios. For example:\n\na customer can place many orders\na team can have many players.\n\nThese relationships help ensure that data is properly structured and connected.\nA key characteristic of relationships is that they are bi-directional, meaning they should always be read both ways. For example, while a customer can place many orders, each order is placed by only one customer. Understanding relationships in both directions is crucial for designing a clear and logical database structure.\nProperly defining entity relationships improves data integrity, reduces redundancy, and enhances query efficiency. By embedding relationships directly into the database design, businesses can enforce rules and constraints that reflect real-world operations, making data retrieval and management more efficient.\nConsider our brand table from last week. Let’s say we want to track also info about lodging chains.\n\n\n\n\n\nSince we have multiple hotels owned by the same chain, storing this information in one table would create redundancies.\nIt is better to create a new entity, and specify the relationship beween the two.\n\n\n\n\n\n\n\n\nThis particular case of relationship is called one-to-many relationship.\nA one-to-many relationship means that one record in a table is linked to many records in another table. Like in our case, one lodging chain can own many hotels, but each hotel belongs to only one chain. See the example of Hilton Hotels:\n\n\n\n\n\nThis type of relationship helps organize data efficiently, avoiding duplication and ensuring consistency.\nLet’s go back to our stock portfolio table for a second. Remember that it contains stock market data that is used by an investment firm dealing with international commodities and agricultural products.\n\n\n\n\n\n\n\nStock market data\n\n\nWe said that there might be several problems (called anomalies) with it:\n\nInsertion anomalies occur when adding new data is difficult due to missing dependencies.\nUpdate anomalies lead to inconsistencies when changes must be made in multiple places.\nDeletion anomalies cause unintended data loss when removing a record also removes critical information.\n\nLet’s try to design a database to store our stock portfolio data!\n\n\nDevelop a data model for Marriott International to keep track of relevant information about its portfolio of hotels\nFocus on the assets, not on customers, employees, or transactions\n\n\n\n\n\n\n\n\nHierarchical relationships occur frequently in databases and follow a one-to-many structure, where one entity has multiple related entities beneath it. This structure is similar to a tree, where a parent node can have multiple child nodes, but each child has only one parent. For example, in a company database, one manager oversees many employees, but each employee has only one direct manager. Similarly, a firm can have many divisions, a division can have many departments, and a department can have many sections (see the example below).\nThese relationships help organize data logically and efficiently, making it easier to navigate and retrieve information.\n\n\n\n\n\n\n\n\n\nSo far, we covered a lot of abstract terms like entity, instances, attributes etc. As you correctly notice, we could simply say table, row, and columns instead. However, there is a good reason for using these abstract terms.\nUnderstanding entities, instances, and attributes rather than just tables, rows, and columns is important because it helps us focus on the conceptual meaning of the data rather than just its storage format.\n\nEntity vs. Table: An entity represents a real-world object or concept (like a “Customer” or “Product”), while a table is just how we store data in a database. Thinking in terms of entities helps us design better database models before deciding how to implement them.\n\nInstance vs. Row: An instance is a specific example of an entity (e.g., a particular customer, “John Doe”). A row is how that instance is stored in a table. Thinking in terms of instances makes it easier to understand relationships between data.\n\nAttribute vs. Column: An attribute describes a characteristic of an entity (e.g., a customer’s “Name” or “Email”). A column is just where this data is stored. By focusing on attributes first, we ensure that all necessary information is captured properly.\n\nBy using these abstract concepts, we can design flexible and well-structured databases before deciding how to implement them in a specific DBMS.\n\n\nWhen designing a relational database, entities and their relationships are translated into tables and columns. The process follows these key steps:\n\nEach entity becomes a table\n\nThe entity name becomes the table name\n\nEach attribute becomes a column\n\n\n\n\nIn a one-to-many relationship, we structure the tables as follows:\n\nAdd a column to the table on the “many” side of the relationship\n\nStore the identifier of the “one” side in this added column\n\nThis ensures proper linkage between related data while maintaining database integrity.\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nThe conceptual database model uses a parsimonious notation, meaning that extra attributes do not need to be explicitly modeled, as they can be inferred from the relationship.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEnsuring data integrity is crucial in relational databases. Entity integrity maintains the uniqueness and validity of primary keys, while referential integrity ensures that foreign keys correctly reference existing primary keys. These rules help prevent inconsistencies and maintain reliable relationships between tables.\n\n\n\nA primary key must be unique.\n\nPrimary keys can never have NULL values.\n\n\n\n\n\nFor every non-null value of a foreign key, there must be a matching primary key with that value.\n\nExample: For every value of chainID in the brand table, there must be a corresponding value of chainID in the lodgingChain table.\n\nA primary key must exist before a foreign key can be defined.\n\n##Implementable database model\nRemember these beatiful drawings?\n\n\n\n\n\n\n\n\nHand-drawn crowfoot model\n\n\n\n\n\n\n\nER diagram\n\n\n\n\n\n\nFigure 1\n\n\n\nSo far, we mainly focused on a conceptual database model. But there is also implementational (or logical) database model.\nThe conceptual database model focuses on the high-level structure of the data, emphasizing entities, relationships, and constraints without considering how the data will be physically stored. It serves as a blueprint for understanding data requirements and is independent of any specific database management system (DBMS). On the other hand, the implementational database model translates the conceptual design into a format that a DBMS can use, incorporating tables, columns, keys, and constraints based on a specific database system. While the conceptual model is abstract and business-oriented, the implementational model is detailed and technical, bridging the gap between design and actual database implementation.\nWe will learn how to design such implementational models in few weeks. First, let’s learn how to read them.\n\n\n\n\n\n\n\n\n\n\n\n\n\nAn implementational database model\n\n\n\n\n\n\n\n\n\n\n\nWorkbench symbolism\n\n\n\n\n\n\n\n\n\nIn database modeling, identifying and non-identifying relationships refer to how entities are related to one another. An identifying relationship occurs when the child entity’s existence depends on the parent entity, and the child entity’s primary key includes the parent’s primary key. This often happens in cases where the child cannot exist without the parent (e.g., an order item cannot exist without an order). In contrast, a non-identifying relationship occurs when the child entity can exist independently of the parent entity, and the child’s primary key does not include the parent’s primary key. Here, the relationship is more loosely coupled (e.g., a customer can exist without an address).\nIn the implementational model, the relationships will look slightly differnt.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nIn the conceptual model, we will have to add a small plus (+) over a relationship, to mark the identifying relationship."
  },
  {
    "objectID": "2-one-to-many.html#attributes",
    "href": "2-one-to-many.html#attributes",
    "title": "One-to-Many relationship",
    "section": "",
    "text": "Attributes store important details about each record in a table, helping to describe and organize data effectively.\nIn a database, attributes can be classified based on whether they require a value. A required attribute must always have a value and cannot be left empty, while an optional attribute can be left empty (NULL).\n\n\n\n\n\n\nWarning\n\n\n\nWe use NULL to indicate missing values. Missing values can occur for different reasons, such as an existing attribute without data (e.g., a middle name) or an inapplicable condition (e.g., an apartment number for a house address).\nDon’t confuse NULL values with blank or zero.\nMultiple meanings:\n\nUnknown data\nInapplicable data\nNo value supplied\nValue undefined\n\nWe will come back to NULL values later.\n\n\nEach attribute has a domain, which defines the set of possible values it can take.\n\n\n\n\n\n\nTip\n\n\n\nA domain is the set of possible values that an attribute can have. Think of it like a rule that defines what kind of data is allowed in a column. For example, if you have an attribute “Age,” its domain might be whole numbers between 0 and 120. If you have a “Country” attribute, its domain would be a list of valid country names. Domains help keep data consistent and prevent errors, like entering text in a column meant for numbers.\n\n\nTo uniquely identify each record, identifiers are used—these are attributes that hold unique values for each instance. In relational databases, the primary key serves as this unique identifier.\nSometimes, a composite identifier is needed, which combines two or more attributes to uniquely identify a record (e.g., a combination of Course ID and Student ID to track enrollments).\nAttributes can be classified into different types:\n\nComposite attribute: Attribute that can be subdivided to yield additional attributes\nSimple attribute: Attribute that cannot be subdivided\nDerived attribute: Attribute whose value is calculated from other attributes\n\nDerived using an algorithm (i.e., Yield = Dividend * Quantity)\nSometimes called ‘calculated fields’\n\nSingle-valued attribute: Attribute that holds only a single value\nMultivalued attributes: Attributes that hold many values\n\nUnderstanding these attribute types is essential for designing efficient databases that accurately represent real-world scenarios."
  },
  {
    "objectID": "2-one-to-many.html#multivalued-attributes",
    "href": "2-one-to-many.html#multivalued-attributes",
    "title": "One-to-Many relationship",
    "section": "",
    "text": "Think of the data scientists database we modeled last week.\n\n\n\n\n\nHow would the model change, if our data scientist could get a second degree? Or multiple certificates?\nA multivalued attribute is an attribute that can have multiple values for a single entity. For example, an employee might have multiple phone numbers or an author might write multiple books. In database design, multivalued attributes should be handled properly to maintain data consistency. One approach is to create separate attributes for each component of the multivalued attribute (e.g., Phone_1, Phone_2). A better approach is to create a new entity that holds the multiple values, linking it to the original entity through a relationship (e.g., an Employee_Phone table linked to an Employee table). This ensures better organization, eliminates redundancy, and improves data integrity.\nNow, try to apply that knowledge to our data scientists database."
  },
  {
    "objectID": "2-one-to-many.html#entity-relaionship",
    "href": "2-one-to-many.html#entity-relaionship",
    "title": "One-to-Many relationship",
    "section": "",
    "text": "There is one more new thing in the model above. Habe you noticed that the entities are “linked”. These are entity relationships.\nIn database design, relationships define how different entities (tables) are associated with one another. These relationships follow business rules, which describe how entities interact based on real-world scenarios. For example:\n\na customer can place many orders\na team can have many players.\n\nThese relationships help ensure that data is properly structured and connected.\nA key characteristic of relationships is that they are bi-directional, meaning they should always be read both ways. For example, while a customer can place many orders, each order is placed by only one customer. Understanding relationships in both directions is crucial for designing a clear and logical database structure.\nProperly defining entity relationships improves data integrity, reduces redundancy, and enhances query efficiency. By embedding relationships directly into the database design, businesses can enforce rules and constraints that reflect real-world operations, making data retrieval and management more efficient.\nConsider our brand table from last week. Let’s say we want to track also info about lodging chains.\n\n\n\n\n\nSince we have multiple hotels owned by the same chain, storing this information in one table would create redundancies.\nIt is better to create a new entity, and specify the relationship beween the two."
  },
  {
    "objectID": "2-one-to-many.html#one-to-many-relationship",
    "href": "2-one-to-many.html#one-to-many-relationship",
    "title": "One-to-Many relationship",
    "section": "",
    "text": "This particular case of relationship is called one-to-many relationship.\nA one-to-many relationship means that one record in a table is linked to many records in another table. Like in our case, one lodging chain can own many hotels, but each hotel belongs to only one chain. See the example of Hilton Hotels:\n\n\n\n\n\nThis type of relationship helps organize data efficiently, avoiding duplication and ensuring consistency.\nLet’s go back to our stock portfolio table for a second. Remember that it contains stock market data that is used by an investment firm dealing with international commodities and agricultural products.\n\n\n\n\n\n\n\nStock market data\n\n\nWe said that there might be several problems (called anomalies) with it:\n\nInsertion anomalies occur when adding new data is difficult due to missing dependencies.\nUpdate anomalies lead to inconsistencies when changes must be made in multiple places.\nDeletion anomalies cause unintended data loss when removing a record also removes critical information.\n\nLet’s try to design a database to store our stock portfolio data!\n\n\nDevelop a data model for Marriott International to keep track of relevant information about its portfolio of hotels\nFocus on the assets, not on customers, employees, or transactions\n\n\n\n\n\n\n\n\nHierarchical relationships occur frequently in databases and follow a one-to-many structure, where one entity has multiple related entities beneath it. This structure is similar to a tree, where a parent node can have multiple child nodes, but each child has only one parent. For example, in a company database, one manager oversees many employees, but each employee has only one direct manager. Similarly, a firm can have many divisions, a division can have many departments, and a department can have many sections (see the example below).\nThese relationships help organize data logically and efficiently, making it easier to navigate and retrieve information."
  },
  {
    "objectID": "2-one-to-many.html#mapping-to-a-relational-database",
    "href": "2-one-to-many.html#mapping-to-a-relational-database",
    "title": "One-to-Many relationship",
    "section": "",
    "text": "So far, we covered a lot of abstract terms like entity, instances, attributes etc. As you correctly notice, we could simply say table, row, and columns instead. However, there is a good reason for using these abstract terms.\nUnderstanding entities, instances, and attributes rather than just tables, rows, and columns is important because it helps us focus on the conceptual meaning of the data rather than just its storage format.\n\nEntity vs. Table: An entity represents a real-world object or concept (like a “Customer” or “Product”), while a table is just how we store data in a database. Thinking in terms of entities helps us design better database models before deciding how to implement them.\n\nInstance vs. Row: An instance is a specific example of an entity (e.g., a particular customer, “John Doe”). A row is how that instance is stored in a table. Thinking in terms of instances makes it easier to understand relationships between data.\n\nAttribute vs. Column: An attribute describes a characteristic of an entity (e.g., a customer’s “Name” or “Email”). A column is just where this data is stored. By focusing on attributes first, we ensure that all necessary information is captured properly.\n\nBy using these abstract concepts, we can design flexible and well-structured databases before deciding how to implement them in a specific DBMS.\n\n\nWhen designing a relational database, entities and their relationships are translated into tables and columns. The process follows these key steps:\n\nEach entity becomes a table\n\nThe entity name becomes the table name\n\nEach attribute becomes a column\n\n\n\n\nIn a one-to-many relationship, we structure the tables as follows:\n\nAdd a column to the table on the “many” side of the relationship\n\nStore the identifier of the “one” side in this added column\n\nThis ensures proper linkage between related data while maintaining database integrity.\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nThe conceptual database model uses a parsimonious notation, meaning that extra attributes do not need to be explicitly modeled, as they can be inferred from the relationship.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEnsuring data integrity is crucial in relational databases. Entity integrity maintains the uniqueness and validity of primary keys, while referential integrity ensures that foreign keys correctly reference existing primary keys. These rules help prevent inconsistencies and maintain reliable relationships between tables.\n\n\n\nA primary key must be unique.\n\nPrimary keys can never have NULL values.\n\n\n\n\n\nFor every non-null value of a foreign key, there must be a matching primary key with that value.\n\nExample: For every value of chainID in the brand table, there must be a corresponding value of chainID in the lodgingChain table.\n\nA primary key must exist before a foreign key can be defined.\n\n##Implementable database model\nRemember these beatiful drawings?\n\n\n\n\n\n\n\n\nHand-drawn crowfoot model\n\n\n\n\n\n\n\nER diagram\n\n\n\n\n\n\nFigure 1\n\n\n\nSo far, we mainly focused on a conceptual database model. But there is also implementational (or logical) database model.\nThe conceptual database model focuses on the high-level structure of the data, emphasizing entities, relationships, and constraints without considering how the data will be physically stored. It serves as a blueprint for understanding data requirements and is independent of any specific database management system (DBMS). On the other hand, the implementational database model translates the conceptual design into a format that a DBMS can use, incorporating tables, columns, keys, and constraints based on a specific database system. While the conceptual model is abstract and business-oriented, the implementational model is detailed and technical, bridging the gap between design and actual database implementation.\nWe will learn how to design such implementational models in few weeks. First, let’s learn how to read them.\n\n\n\n\n\n\n\n\n\n\n\n\n\nAn implementational database model\n\n\n\n\n\n\n\n\n\n\n\nWorkbench symbolism\n\n\n\n\n\n\n\n\n\nIn database modeling, identifying and non-identifying relationships refer to how entities are related to one another. An identifying relationship occurs when the child entity’s existence depends on the parent entity, and the child entity’s primary key includes the parent’s primary key. This often happens in cases where the child cannot exist without the parent (e.g., an order item cannot exist without an order). In contrast, a non-identifying relationship occurs when the child entity can exist independently of the parent entity, and the child’s primary key does not include the parent’s primary key. Here, the relationship is more loosely coupled (e.g., a customer can exist without an address).\nIn the implementational model, the relationships will look slightly differnt.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nIn the conceptual model, we will have to add a small plus (+) over a relationship, to mark the identifying relationship."
  },
  {
    "objectID": "2-one-to-many.html#aggregate-functions",
    "href": "2-one-to-many.html#aggregate-functions",
    "title": "One-to-Many relationship",
    "section": "Aggregate functions",
    "text": "Aggregate functions\nIn SQL aggregate functions help you combine lots of data into one result. These are like math operations that work on whole columns of information instead of just single values.\nHere are the main aggregate functions:\n\nCOUNT(): Tells you how many items are in your data (like counting how many customers you have)\nSUM(): Adds up numbers (like finding your total sales for the month)\nAVG(): Calculates the average (like finding the typical price of products)\nMIN(): Finds the smallest value (like identifying your cheapest item)\nMAX(): Finds the largest value (like identifying your most expensive item)\n\nThese functions are super helpful when you want to get quick summaries from your database without looking at every single row of information. You simply add the to your query follwoing this pattern:\n\nSELECT FUNCTION(columnName) FROM tableName;\n\nLet’s test them in our brand table!\nFind the average hotel room square footage for all brands.\n\n\n\nWhat is the area of the largest hotel room specification in the DB? Rename as “Biggest Room”\n\n\n\nHow many total brands do we have data for?\n\n\n\nWhat is the total number of hotel rooms? - All rooms of all chains.\n\n\n\n\n\n\nTip\n\n\n\nThe solve this task, you will have to query different table…"
  },
  {
    "objectID": "2-one-to-many.html#joining-tables",
    "href": "2-one-to-many.html#joining-tables",
    "title": "One-to-Many relationship",
    "section": "JOINing tables",
    "text": "JOINing tables\nJoining tables in SQL allows you to combine related data from different tables into a single result set. The simplest way to join tables is using the WHERE clause with the equals operator (which is great!🤩 because you already know how to use WHERE).\nHere’s how it works:\n\nBasic JOIN using WHERE: You list both tables in the FROM clause and use WHERE to match related columns\nExample syntax: SELECT * FROM brand, lodgingchain WHERE brand.chainID = lodgingchain.chainID;\nHow it works: This tells SQL to match each row from the first table with rows from the second table where the specified columns have the same value\nResult: Only rows where the join condition is true appear in your results\n\nThis approach creates what’s known as an “inner join” - it only shows data where there are matches between both tables. We will explore more powerful ways to join tables in our next session.\nTry it yourself!\n\nSELECT * FROM brand, lodgingchain \n  WHERE brand.chainID = lodgingchain.chainID;\n\n\nExercise\nReport the headquarter location of each brand’s parent chain.Order by brand name.\n\n\n\n\n\n\n\n\n\nWatch out for cross-products\n\n\n\nA cross-product in SQL occurs when you join two tables without specifying a join condition. This creates a result set containing every possible combination of rows from both tables. For example, if you run SELECT * FROM brand, lodgingchain; without a WHERE clause, each row from the brand table will be paired with every row from the lodgingchain table. If your brand table has 100 rows and your lodgingchain table has 500 rows, you’ll end up with 50,000 rows in your result set.\nCross-products are rarely useful in practical applications and can cause serious performance problems with large tables, which is why properly specifying join conditions with WHERE clauses is essential for efficient queries.\n\nSELECT * FROM brand, lodgingchain;\n\n\n\n\n\n\n\n\n\nThe risk of homonyms\n\n\n\nHomonyms in database design—particularly columns with identical names across different tables—create risks. When fields like “id” or “status” appear in multiple tables but represent different concepts, developers may mistakenly join these columns or apply incorrect business logic. This confusion leads to flawed queries, unpredictable results, and potential data corruption.\nTo prevent these issues, best practices include using descriptive, context-specific column names (e.g., “customer_id” instead of just “id”), implementing consistent naming conventions, and maintaining clear documentation of each column’s specific meaning and purpose.\nHowever, sometimes you may find a database with homonyms. Let’s take a look at our nation-stock database. Try to run the query below. What is the result? How would you change the query to get the correct result?\n\n\n\n\n\n\nSELECT * FROM stock, nation\n    WHERE natcode = natcode;"
  },
  {
    "objectID": "2-one-to-many.html#grouping-the-results",
    "href": "2-one-to-many.html#grouping-the-results",
    "title": "One-to-Many relationship",
    "section": "Grouping the results",
    "text": "Grouping the results\nThe GROUP BY clause in SQL allows you to organize similar data into groups and perform aggregate functions on each group separately rather than on the entire table.\nHere’s how it works:\n\nBasic purpose: Groups rows that have the same values in specified columns\nTypical usage: Used with aggregate functions (COUNT, SUM, AVG, etc.) to perform calculations on each group\nExample syntax: SELECT chainHQ, COUNT(*) FROM lodgingChaing GROUP BY chainHQ;\nResult: One row for each unique value in the grouped column(s)\nMultiple columns: You can group by multiple columns like GROUP BY department, job_title\nCommon requirement: Generally, columns in the SELECT list must either be part of the GROUP BY clause or used within an aggregate function\n\n\nSELECT headquarters, COUNT(*) FROM lodgingchain \n  GROUP BY headquarters;\n\nGROUP BY is essential for summarizing data and generating reports that show totals, averages, or counts for different categories within your data.\n\nExercise\nReport number of brands in each chain by chain name (not chainID).\n\n\n\n\n\nHAVING\nIn SQL, the HAVING clause is used to filter the results of a GROUP BY query. It is like WHERE clause for grouped results. However, HAVING allows you to filter groups based on aggregate functions (like COUNT(), SUM(), AVG(), etc.), which cannot be done using the WHERE clause.\n\n\n\n\n\n\nNote\n\n\n\nThe WHERE clause filters rows before they are grouped, while HAVING filters groups after the aggregation is done.\n\n\nConsider the previous example. We can easily filter the results and keep only, for example, countries with at least 3 headquarters.\n\nSELECT headquarters, COUNT(*) FROM lodgingchain \n  GROUP BY headquarters\n  HAVING COUNT(*) &gt;= 3;\n\n\nExercise\nReport the average room area and number of brands for all chains that own more than one brand"
  },
  {
    "objectID": "2-one-to-many.html#subqueries",
    "href": "2-one-to-many.html#subqueries",
    "title": "One-to-Many relationship",
    "section": "Subqueries",
    "text": "Subqueries\nA subquery is a query that is nested inside another query. It is used to retrieve data that will be used in the main query for filtering, selecting, or computing results. Subqueries can be placed in the SELECT, FROM, or WHERE clauses of a SQL query.\nThere are two main types of subqueries: 1. Scalar subqueries: Return a single value. 2. Table subqueries: Return multiple rows and columns.\nFor now, we will only focus on scalar subqueries.\nWhen to Use Subqueries:\n\nWhen you need to compare a value in a column with a result from another query.\nWhen you want to perform an operation on a subset of data before using it in the main query.\nWhen a join is not possible or too complex to use.\n\n\nExample of a Subquery in the WHERE Clause:\nReport the name of all brands headquartered in the same country as the Grand Hyatt.\n\nSELECT brandName FROM lodgingChain, brand \n  WHERE lodgingChain.chainID = brand.chainID \n  AND headquarters IN (SELECT headquarters \n                FROM lodgingChain, brand\n                WHERE lodgingChain.chainID = brand.chainID \n                AND brandName='Grand Hyatt');\n\nA subquery in the WHERE clause can be used to filter results based on data from another table. You can run the subquery as a separate query and see its results.\n\nSELECT headquarters FROM lodgingChain, brand\n  WHERE lodgingChain.chainID = brand.chainID \n  AND brandName='Grand Hyatt'\n\n\n\nExercise\nReport all data about the oldest chain with worldwide presence (i.e., founded earliest)"
  },
  {
    "objectID": "2-one-to-many.html#extra-practice-cell",
    "href": "2-one-to-many.html#extra-practice-cell",
    "title": "One-to-Many relationship",
    "section": "Extra practice cell",
    "text": "Extra practice cell\n\n\n\n\n\n\n\n\n\n\nThat’s it for now, but this is just the beginning! 🎉\nThere’s so much more to explore. With each step, you’ll unlock more powerful ways to interact with databases and make sense of data. Keep practicing, stay curious, and get ready for even more exciting topics ahead!\n\n\n\n\n\n\n\n\nImages and GIFs Disclaimer: Some of the images and GIFs used on this website are not owned by me. They are used for educational and illustrative purposes only. All rights belong to their respective owners. If you believe any content violates copyright, please contact me for prompt removal.\n\n\n\n\n\n\n  \n  \n    © 2025. All Rights Reserved.\n  \n  \n\n  \n  \n    Enabled by Dr. Marcin Bartosiak"
  },
  {
    "objectID": "1-single-entity.html",
    "href": "1-single-entity.html",
    "title": "Introduction to SQL. Single entity",
    "section": "",
    "text": "Database Model is the logical representation of the structure of the data.\n\n\n\nDatabase Model Example\n\n\nIn general, there are two types of database models:\n\nConceptual Data Model\n\nThe logical representation of the structure of the data (conceptual metadata)\nUsing a specific modelling notation (e.g., ER diagramming, crow-foot notation, UML)\n\n\n\n\n\n\n\n\n\n\nHand-drawn crowfoot model\n\n\n\n\n\n\n\nER diagram\n\n\n\n\n\n\nFigure 1\n\n\n\n\nImplementable Data Model\n\nProduced in specialized software\nReady to launch on a server\nConceptual design\nData dictionary\n\n\n\n\n\nImplementable Model\n\n\nModelling is Designing\nA database must model the real world\n\nTo model means:\n\nTo represent faithfully\nGiven the database design objectives\nWithin scope and under given constraints\n\n\nObjective: Storing and retrieving data about the real world\nData modelling is a design technique for capturing data reality\n\n\nThe relational model is a way of organizing data into tables (called relations).\nThe Relational Model represents data and their relationships through a collection of tables. Each table also known as a relation consists of rows and columns. Every column has a unique name and corresponds to a specific attribute, while each row contains a set of related data values representing a real-world entity or relationship.\nThe relational model represents how data is stored in Relational Databases. A relational database consists of a collection of tables each of which is assigned a unique name.\n\n\n\nRelational Model\n\n\nRelation or table: * Matrix of intersecting tuples and attributes + Tuples: Rows + Attributes: Columns\n\n\n\nAn entity is some thing in the environment. It can be a physical entity (e.g., student) or an abstraction (e.g., marriage). You can think of an entity as a class of objects (or phenomena). An instance is a particular occurrence of an entity.\n\n\n\n\n\nNo worries! It will get easier with the examples below 😅\n\n\n\nEntity: “Car” is an entity because it represents a general category of objects that share common characteristics, such as having wheels, an engine, and the ability to transport people.\n\nInstance: A specific car, like a red 2015 Volkswagen Beetle with license plate ABC123, is an instance of the “Car” entity. It is a particular example with unique attributes.\n\n\n\n\n\n\n\n\n\n\nEntity: “Tree” is an entity because it represents a general type of object that has roots, a trunk, and leaves.\n\nInstance: A specific tree in a forest, such as the 50-year-old oak tree standing near the river in Amazon Rainforest, is an instance of the “Tree” entity. It is a unique example of the general concept.\n\n\n\n\n\n\n\n\n\nFirst, we need to draw an entity.\nRemember, an entity is:\n\nSome thing in the environment\nA physical entity (e.g., student) or an abstraction (e.g., marriage)\nAn entity is a class (or entity set)\nAn instance is a particular occurrence of an entity\n\n\n\n\n\n\n\nNote\n\n\n\nAn entity is represented by a rectangle in modelling notation\n\n\n\n\n\n\n\n\n\nAn entity\n\n\nSecond, let’s think about attributes.\nAn attribute is a discrete data element that describes an entity.\n\nAttributes must be conceptually unique\n\nHomonym: Same name is used to label different attributes\nSynonym: Different names are used to describe the same attribute\n\n\n\n\n\n\n\n\nNote\n\n\n\nAttribute names must be unique within a data model\nAttribute names should be meaningful\n\n\n\n\n\n\n\n\n\nAttributes\n\n\nThere is one more step before we have our model ready. We need to add identifiers.\nEvery instance of an entity must be uniquely identified.\nAn identifier can be an attribute or collection of attributes.\nAn identifier can be created if there is no obvious attribute (surrogate).\n\n\n\n\n\n\nNote\n\n\n\nA leading asterisk denotes an identifier in our entity.\n\n\n\n\n\n\n\n\n\nIdentifier (*)\n\n\nThat’s it! You’ve created your first database model. It’s a simple one—just a single table. But soon, we’ll be designing much more complex databases, all built on these few basic steps.\n\n\n\n\nCreate a data model for recording details of the herd of cows that you manage"
  },
  {
    "objectID": "1-single-entity.html#the-relational-model",
    "href": "1-single-entity.html#the-relational-model",
    "title": "Introduction to SQL. Single entity",
    "section": "",
    "text": "The relational model is a way of organizing data into tables (called relations).\nThe Relational Model represents data and their relationships through a collection of tables. Each table also known as a relation consists of rows and columns. Every column has a unique name and corresponds to a specific attribute, while each row contains a set of related data values representing a real-world entity or relationship.\nThe relational model represents how data is stored in Relational Databases. A relational database consists of a collection of tables each of which is assigned a unique name.\n\n\n\nRelational Model\n\n\nRelation or table: * Matrix of intersecting tuples and attributes + Tuples: Rows + Attributes: Columns"
  },
  {
    "objectID": "1-single-entity.html#single-entity",
    "href": "1-single-entity.html#single-entity",
    "title": "Introduction to SQL. Single entity",
    "section": "",
    "text": "An entity is some thing in the environment. It can be a physical entity (e.g., student) or an abstraction (e.g., marriage). You can think of an entity as a class of objects (or phenomena). An instance is a particular occurrence of an entity.\n\n\n\n\n\nNo worries! It will get easier with the examples below 😅\n\n\n\nEntity: “Car” is an entity because it represents a general category of objects that share common characteristics, such as having wheels, an engine, and the ability to transport people.\n\nInstance: A specific car, like a red 2015 Volkswagen Beetle with license plate ABC123, is an instance of the “Car” entity. It is a particular example with unique attributes.\n\n\n\n\n\n\n\n\n\n\nEntity: “Tree” is an entity because it represents a general type of object that has roots, a trunk, and leaves.\n\nInstance: A specific tree in a forest, such as the 50-year-old oak tree standing near the river in Amazon Rainforest, is an instance of the “Tree” entity. It is a unique example of the general concept.\n\n\n\n\n\n\n\n\n\nFirst, we need to draw an entity.\nRemember, an entity is:\n\nSome thing in the environment\nA physical entity (e.g., student) or an abstraction (e.g., marriage)\nAn entity is a class (or entity set)\nAn instance is a particular occurrence of an entity\n\n\n\n\n\n\n\nNote\n\n\n\nAn entity is represented by a rectangle in modelling notation\n\n\n\n\n\n\n\n\n\nAn entity\n\n\nSecond, let’s think about attributes.\nAn attribute is a discrete data element that describes an entity.\n\nAttributes must be conceptually unique\n\nHomonym: Same name is used to label different attributes\nSynonym: Different names are used to describe the same attribute\n\n\n\n\n\n\n\n\nNote\n\n\n\nAttribute names must be unique within a data model\nAttribute names should be meaningful\n\n\n\n\n\n\n\n\n\nAttributes\n\n\nThere is one more step before we have our model ready. We need to add identifiers.\nEvery instance of an entity must be uniquely identified.\nAn identifier can be an attribute or collection of attributes.\nAn identifier can be created if there is no obvious attribute (surrogate).\n\n\n\n\n\n\nNote\n\n\n\nA leading asterisk denotes an identifier in our entity.\n\n\n\n\n\n\n\n\n\nIdentifier (*)\n\n\nThat’s it! You’ve created your first database model. It’s a simple one—just a single table. But soon, we’ll be designing much more complex databases, all built on these few basic steps."
  },
  {
    "objectID": "1-single-entity.html#exercise",
    "href": "1-single-entity.html#exercise",
    "title": "Introduction to SQL. Single entity",
    "section": "",
    "text": "Create a data model for recording details of the herd of cows that you manage"
  },
  {
    "objectID": "1-single-entity.html#querying-a-table",
    "href": "1-single-entity.html#querying-a-table",
    "title": "Introduction to SQL. Single entity",
    "section": "Querying a Table",
    "text": "Querying a Table\nIn SQL, the simplest way to retrieve data is by using SELECT * FROM tableName;. This command asks the database to return everything in the table. Think of it as saying, “Hey, server, show me (SELECT) all the data (*) in this table (FROM)!”\nOf course, tableName is just a placeholder. We will have to replace it with the real name. In our case, the table is called brand.\nTry it yourself with our brand table:\n\nSELECT * FROM tableName;\n\n\n\n\n\n\n\nNote\n\n\n\nHave you noticed the small detail at the end of line? Every query has to end with ;. It tells the server that your query ends here. Everything after this sign is a new code. This will be important when we run more than one query at a time."
  },
  {
    "objectID": "1-single-entity.html#projection-choosing-columns",
    "href": "1-single-entity.html#projection-choosing-columns",
    "title": "Introduction to SQL. Single entity",
    "section": "Projection: Choosing Columns",
    "text": "Projection: Choosing Columns\nSometimes, you don’t need all the data—just specific columns.\n\n\n\n\n\nYou can request only what you need by listing column names:\n\nSELECT brandName, brandChain FROM brand; \n\nThis is like asking, “Tell me just the brand name and chain, please.”"
  },
  {
    "objectID": "1-single-entity.html#restriction-choosing-rows",
    "href": "1-single-entity.html#restriction-choosing-rows",
    "title": "Introduction to SQL. Single entity",
    "section": "Restriction: Choosing Rows",
    "text": "Restriction: Choosing Rows\nIf you only want certain rows, use WHERE to filter results.\n\n\n\n\n\nTry yourself and report all brands owned by Hilton Worldwide.\n\nSELECT * FROM brand \n  WHERE ... ;\n\nThis is like telling the server, “Only show me brands owned by Hilton.”\nYou can choose any other lodging chain instead of ‘Hilton Worldwide’. For example, try with ‘Accor’ and see how the results change.\n\n\n\n\n\n\nWarning\n\n\n\nHilton or Accor are values, not attributes. Unlike column names or table name, you always have to wrap text values with quotation marks ('...' or \"...\").\n\n\n\n\n\n\n\n\nTip\n\n\n\nFollowing the same logic, you can exclude a value from the results. You have to replace = with != or &lt;&gt; (they both mean the same thing).\n\n\nTry yourself and report all brands but Hilton Worldwide. Edit the query to try it with &lt;&gt; too.\n\nSELECT * FROM brand \n  WHERE brandChain != 'Hilton Worldwide';"
  },
  {
    "objectID": "1-single-entity.html#projection-and-restriction-together",
    "href": "1-single-entity.html#projection-and-restriction-together",
    "title": "Introduction to SQL. Single entity",
    "section": "Projection and Restriction Together",
    "text": "Projection and Restriction Together\nCombining both techniques, you can select specific columns and filter rows. List the brand name and segment of all brands owned by Hilton Worldwide:\n\nSELECT ... FROM ... \n  WHERE ...;\n\nNow you’re asking, “Show me just the names and segments of Hilton brands.”"
  },
  {
    "objectID": "1-single-entity.html#primary-key-retrieval",
    "href": "1-single-entity.html#primary-key-retrieval",
    "title": "Introduction to SQL. Single entity",
    "section": "Primary Key Retrieval",
    "text": "Primary Key Retrieval\nA primary key uniquely identifies a row. If you query by it, you get at most one result:\n\nSELECT * FROM brand \n  WHERE brandID = 10;\n\nThis is like saying, “Give me all details about the brand with ID 10.”\nImportant Notice that numerical values do not have to be wrapped with quotation marks."
  },
  {
    "objectID": "1-single-entity.html#queries-without-primary-key",
    "href": "1-single-entity.html#queries-without-primary-key",
    "title": "Introduction to SQL. Single entity",
    "section": "Queries Without Primary Key",
    "text": "Queries Without Primary Key\nWithout a primary key, multiple rows can be returned:\n\nSELECT * FROM brand \n  WHERE brandChain = 'Accor';"
  },
  {
    "objectID": "1-single-entity.html#the-in-operator",
    "href": "1-single-entity.html#the-in-operator",
    "title": "Introduction to SQL. Single entity",
    "section": "The IN Operator",
    "text": "The IN Operator\nIf you want to filter by multiple values, IN operator will come handy:\n\nSELECT * FROM brand \n  WHERE brandSegment IN ('Luxury', 'Economy');\n\nThis is the equivalent of saying, “Give me brands that are either Luxury or Economy.”\nYou could get the same results by using WHERE with OR:\n\nSELECT * FROM brand \n    WHERE brandSegment = 'Luxury'\n        OR brandSegment = 'Economy';\n\nDo you see how much more efficient it is with IN?"
  },
  {
    "objectID": "1-single-entity.html#the-not-in-operator",
    "href": "1-single-entity.html#the-not-in-operator",
    "title": "Introduction to SQL. Single entity",
    "section": "The NOT IN Operator",
    "text": "The NOT IN Operator\nTo exclude more than one value, use NOT IN:\n\nSELECT * FROM brand \n  WHERE brandName NOT IN ('Sofitel', 'Thalassa', 'Curio', 'Conrad');\n\nThis means, “Show me everything except these brands.”"
  },
  {
    "objectID": "1-single-entity.html#ordering-columns",
    "href": "1-single-entity.html#ordering-columns",
    "title": "Introduction to SQL. Single entity",
    "section": "Ordering Columns",
    "text": "Ordering Columns\nThe order of selected columns in your query defines how results appear. This just structures the results the way you prefer.\nCompare these two queries\n\nSELECT brandName, brandSegment FROM brand WHERE brandChain = 'Accor';\n\n\nSELECT brandSegment, brandName FROM brand WHERE brandChain = 'Accor';"
  },
  {
    "objectID": "1-single-entity.html#ordering-rows",
    "href": "1-single-entity.html#ordering-rows",
    "title": "Introduction to SQL. Single entity",
    "section": "Ordering Rows",
    "text": "Ordering Rows\nIf you need to sort the results, you can use ORDER BY.\n\n\n\n\n\nList all brands with rooms smaller than 350 square feet with largest first:\n\nSELECT * FROM brand WHERE brandMinSqFt &lt; 350 ORDER BY brandMinSqFt DESC;\n\nThis means, “Show me brands with rooms under 350 sqft, biggest first, and if sizes match, sort alphabetically.”\n\n\n\n\n\n\nTip\n\n\n\nDESC means descending order (biggest first). If you need ascending order (smallest first), you can replace it with ASC or simply remove it (ascending order is default in SQL).\n\n\n\n\n\n\n\n\nNote\n\n\n\nHave you noticed that there are many brands with the same value? We can order results by two columns. If the results in the first column are identical, the second column will be used to sort them. Let’s add brandName to our ORDER BY clause.\n\n\nList all brands with rooms smaller than 350 square feet with largest first. Where areas are identical, list brands in alphabetical order.\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nNotice that our results are ordered by brandMinSqFt in descending order (DESC), and alphabetically by brandName (you can add ASC after brandName to get the same results).\n\n\n\n\n\n\n\n\nTip\n\n\n\nLast one more thing. Notice that we use &lt; in this query. WHERE condition can take all the comparison operators: =, !=, &lt;, &gt;, &lt;=, and &gt;=."
  },
  {
    "objectID": "1-single-entity.html#calculated-fields",
    "href": "1-single-entity.html#calculated-fields",
    "title": "Introduction to SQL. Single entity",
    "section": "Calculated Fields",
    "text": "Calculated Fields\nSQL allows calculations directly in queries. Let’s say we want to convert square feet to square meters in the results (m² = f² / 10.764)."
  },
  {
    "objectID": "1-single-entity.html#renaming-output-fields",
    "href": "1-single-entity.html#renaming-output-fields",
    "title": "Introduction to SQL. Single entity",
    "section": "Renaming Output Fields",
    "text": "Renaming Output Fields\nThe column name for our calculated field in the results above doesn’t look nice. To make results clearer, use AS to rename calculated fields (or any other column in your query).\nGet minimum room area in square meters for each brand. Rename the output\n\n\n\nNow the result column will be labeled brandSqMt instead of an anonymous calculation. This new name is called alias."
  },
  {
    "objectID": "1-single-entity.html#eliminating-duplicates",
    "href": "1-single-entity.html#eliminating-duplicates",
    "title": "Introduction to SQL. Single entity",
    "section": "Eliminating Duplicates",
    "text": "Eliminating Duplicates\nThe DISTINCT keyword in SQL is used to eliminate duplicate rows from query results, ensuring that only unique values are displayed. This is particularly useful when reporting different possible values for a specific column, such as brand segments.\nRun this query first. Then, modify it to retrieve a list of all unique brand segments without repetition.\n\nSELECT brandSegment FROM brand;"
  },
  {
    "objectID": "1-single-entity.html#extra-practice-cell",
    "href": "1-single-entity.html#extra-practice-cell",
    "title": "Introduction to SQL. Single entity",
    "section": "Extra practice cell",
    "text": "Extra practice cell\n\n\n\n\nThat’s it for now! 🎉\nEven if it seems like just a little, learning this is already a great achievement!\n\n\n\n\n\n\nRemember, SQL is like having a conversation in English with the database:\n\n“Show me everything” → SELECT * FROM table;\n\n“Give me only what I need” → SELECT column FROM table;\n\n“Filter the results” → WHERE = condition\n\n“Sort them” → ORDER BY column\n\nWith these basics, you’re already on your way to mastering SQL!\n\n\n\n\n\n\n\n\n\nImages and GIFs Disclaimer: Some of the images and GIFs used on this website are not owned by me. They are used for educational and illustrative purposes only. All rights belong to their respective owners. If you believe any content violates copyright, please contact me for prompt removal.\n\n\n\n\n\n\n  \n  \n    © 2025. All Rights Reserved.\n  \n  \n\n  \n  \n    Enabled by Dr. Marcin Bartosiak"
  },
  {
    "objectID": "1-single-entity-complete.html",
    "href": "1-single-entity-complete.html",
    "title": "Introduction to SQL. Single entity",
    "section": "",
    "text": "Database Model is the logical representation of the structure of the data.\n\n\n\nDatabase Model Example\n\n\nIn general, there are two types of database models:\n\nConceptual Data Model\n\nThe logical representation of the structure of the data (conceptual metadata)\nUsing a specific modelling notation (e.g., ER diagramming, crow-foot notation, UML)\n\n\n\n\n\n\n\n\n\n\nHand-drawn crowfoot model\n\n\n\n\n\n\n\nER diagram\n\n\n\n\n\n\nFigure 1\n\n\n\n\nImplementable Data Model\n\nProduced in specialized software\nReady to launch on a server\nConceptual design\nData dictionary\n\n\n\n\n\nImplementable Model\n\n\nModelling is Designing\nA database must model the real world\n\nTo model means:\n\nTo represent faithfully\nGiven the database design objectives\nWithin scope and under given constraints\n\n\nObjective: Storing and retrieving data about the real world\nData modelling is a design technique for capturing data reality\n\n\nThe relational model is a way of organizing data into tables (called relations).\nThe Relational Model represents data and their relationships through a collection of tables. Each table also known as a relation consists of rows and columns. Every column has a unique name and corresponds to a specific attribute, while each row contains a set of related data values representing a real-world entity or relationship.\nThe relational model represents how data is stored in Relational Databases. A relational database consists of a collection of tables each of which is assigned a unique name.\n\n\n\nRelational Model\n\n\nRelation or table: * Matrix of intersecting tuples and attributes + Tuples: Rows + Attributes: Columns\n\n\n\nAn entity is some thing in the environment. It can be a physical entity (e.g., student) or an abstraction (e.g., marriage). You can think of an entity as a class of objects (or phenomena). An instance is a particular occurrence of an entity.\n\n\n\n\n\nNo worries! It will get easier with the examples below 😅\n\n\n\nEntity: “Car” is an entity because it represents a general category of objects that share common characteristics, such as having wheels, an engine, and the ability to transport people.\n\nInstance: A specific car, like a red 2015 Volkswagen Beetle with license plate ABC123, is an instance of the “Car” entity. It is a particular example with unique attributes.\n\n\n\n\n\n\n\n\n\n\nEntity: “Tree” is an entity because it represents a general type of object that has roots, a trunk, and leaves.\n\nInstance: A specific tree in a forest, such as the 50-year-old oak tree standing near the river in Amazon Rainforest, is an instance of the “Tree” entity. It is a unique example of the general concept.\n\n\n\n\n\n\n\n\n\nFirst, we need to draw an entity.\nRemember, an entity is:\n\nSome thing in the environment\nA physical entity (e.g., student) or an abstraction (e.g., marriage)\nAn entity is a class (or entity set)\nAn instance is a particular occurrence of an entity\n\n\n\n\n\n\n\nNote\n\n\n\nAn entity is represented by a rectangle in modelling notation\n\n\n\n\n\n\n\n\n\nAn entity\n\n\nSecond, let’s think about attributes.\nAn attribute is a discrete data element that describes an entity.\n\nAttributes must be conceptually unique\n\nHomonym: Same name is used to label different attributes\nSynonym: Different names are used to describe the same attribute\n\n\n\n\n\n\n\n\nNote\n\n\n\nAttribute names must be unique within a data model\nAttribute names should be meaningful\n\n\n\n\n\n\n\n\n\nAttributes\n\n\nThere is one more step before we have our model ready. We need to add identifiers.\nEvery instance of an entity must be uniquely identified.\nAn identifier can be an attribute or collection of attributes.\nAn identifier can be created if there is no obvious attribute (surrogate).\n\n\n\n\n\n\nNote\n\n\n\nA leading asterisk denotes an identifier in our entity.\n\n\n\n\n\n\n\n\n\nIdentifier (*)\n\n\nThat’s it! You’ve created your first database model. It’s a simple one—just a single table. But soon, we’ll be designing much more complex databases, all built on these few basic steps.\n\n\n\n\nCreate a data model for recording details of the herd of cows that you manage"
  },
  {
    "objectID": "1-single-entity-complete.html#the-relational-model",
    "href": "1-single-entity-complete.html#the-relational-model",
    "title": "Introduction to SQL. Single entity",
    "section": "",
    "text": "The relational model is a way of organizing data into tables (called relations).\nThe Relational Model represents data and their relationships through a collection of tables. Each table also known as a relation consists of rows and columns. Every column has a unique name and corresponds to a specific attribute, while each row contains a set of related data values representing a real-world entity or relationship.\nThe relational model represents how data is stored in Relational Databases. A relational database consists of a collection of tables each of which is assigned a unique name.\n\n\n\nRelational Model\n\n\nRelation or table: * Matrix of intersecting tuples and attributes + Tuples: Rows + Attributes: Columns"
  },
  {
    "objectID": "1-single-entity-complete.html#single-entity",
    "href": "1-single-entity-complete.html#single-entity",
    "title": "Introduction to SQL. Single entity",
    "section": "",
    "text": "An entity is some thing in the environment. It can be a physical entity (e.g., student) or an abstraction (e.g., marriage). You can think of an entity as a class of objects (or phenomena). An instance is a particular occurrence of an entity.\n\n\n\n\n\nNo worries! It will get easier with the examples below 😅\n\n\n\nEntity: “Car” is an entity because it represents a general category of objects that share common characteristics, such as having wheels, an engine, and the ability to transport people.\n\nInstance: A specific car, like a red 2015 Volkswagen Beetle with license plate ABC123, is an instance of the “Car” entity. It is a particular example with unique attributes.\n\n\n\n\n\n\n\n\n\n\nEntity: “Tree” is an entity because it represents a general type of object that has roots, a trunk, and leaves.\n\nInstance: A specific tree in a forest, such as the 50-year-old oak tree standing near the river in Amazon Rainforest, is an instance of the “Tree” entity. It is a unique example of the general concept.\n\n\n\n\n\n\n\n\n\nFirst, we need to draw an entity.\nRemember, an entity is:\n\nSome thing in the environment\nA physical entity (e.g., student) or an abstraction (e.g., marriage)\nAn entity is a class (or entity set)\nAn instance is a particular occurrence of an entity\n\n\n\n\n\n\n\nNote\n\n\n\nAn entity is represented by a rectangle in modelling notation\n\n\n\n\n\n\n\n\n\nAn entity\n\n\nSecond, let’s think about attributes.\nAn attribute is a discrete data element that describes an entity.\n\nAttributes must be conceptually unique\n\nHomonym: Same name is used to label different attributes\nSynonym: Different names are used to describe the same attribute\n\n\n\n\n\n\n\n\nNote\n\n\n\nAttribute names must be unique within a data model\nAttribute names should be meaningful\n\n\n\n\n\n\n\n\n\nAttributes\n\n\nThere is one more step before we have our model ready. We need to add identifiers.\nEvery instance of an entity must be uniquely identified.\nAn identifier can be an attribute or collection of attributes.\nAn identifier can be created if there is no obvious attribute (surrogate).\n\n\n\n\n\n\nNote\n\n\n\nA leading asterisk denotes an identifier in our entity.\n\n\n\n\n\n\n\n\n\nIdentifier (*)\n\n\nThat’s it! You’ve created your first database model. It’s a simple one—just a single table. But soon, we’ll be designing much more complex databases, all built on these few basic steps."
  },
  {
    "objectID": "1-single-entity-complete.html#exercise",
    "href": "1-single-entity-complete.html#exercise",
    "title": "Introduction to SQL. Single entity",
    "section": "",
    "text": "Create a data model for recording details of the herd of cows that you manage"
  },
  {
    "objectID": "1-single-entity-complete.html#querying-a-table",
    "href": "1-single-entity-complete.html#querying-a-table",
    "title": "Introduction to SQL. Single entity",
    "section": "Querying a Table",
    "text": "Querying a Table\nIn SQL, the simplest way to retrieve data is by using SELECT * FROM tableName;. This command asks the database to return everything in the table. Think of it as saying, “Hey, server, show me (SELECT) all the data (*) in this table (FROM)!”\nOf course, tableName is just a placeholder. We will have to replace it with the real name. In our case, the table is called brand.\nTry it yourself with our brand table:\n\nSELECT * FROM brand;\n\n\n\n\n\n\n\nNote\n\n\n\nHave you noticed the small detail at the end of line? Every query has to end with ;. It tells the server that your query ends here. Everything after this sign is a new code. This will be important when we run more than one query at a time."
  },
  {
    "objectID": "1-single-entity-complete.html#projection-choosing-columns",
    "href": "1-single-entity-complete.html#projection-choosing-columns",
    "title": "Introduction to SQL. Single entity",
    "section": "Projection: Choosing Columns",
    "text": "Projection: Choosing Columns\nSometimes, you don’t need all the data—just specific columns.\n\n\n\n\n\nYou can request only what you need by listing column names:\n\nSELECT brandName, brandChain FROM brand; \n\nThis is like asking, “Tell me just the brand name and chain, please.”"
  },
  {
    "objectID": "1-single-entity-complete.html#restriction-choosing-rows",
    "href": "1-single-entity-complete.html#restriction-choosing-rows",
    "title": "Introduction to SQL. Single entity",
    "section": "Restriction: Choosing Rows",
    "text": "Restriction: Choosing Rows\nIf you only want certain rows, use WHERE to filter results.\n\n\n\n\n\nTry yourself and report all brands owned by Hilton Worldwide.\n\nSELECT * FROM brand \n  WHERE brandChain = 'Hilton Worldwide';\n\nThis is like telling the server, “Only show me brands owned by Hilton.”\nYou can choose any other lodging chain instead of ‘Hilton Worldwide’. For example, try with ‘Accor’ and see how the results change.\n\n\n\n\n\n\nWarning\n\n\n\nHilton or Accor are values, not attributes. Unlike column names or table name, you always have to wrap text values with quotation marks ('...' or \"...\").\n\n\n\n\n\n\n\n\nTip\n\n\n\nFollowing the same logic, you can exclude a value from the results. You have to replace = with != or &lt;&gt; (they both mean the same thing).\n\n\nTry yourself and report all brands but Hilton Worldwide. Edit the query to try it with &lt;&gt; too.\n\nSELECT * FROM brand \n  WHERE brandChain &lt;&gt; 'Hilton Worldwide';"
  },
  {
    "objectID": "1-single-entity-complete.html#projection-and-restriction-together",
    "href": "1-single-entity-complete.html#projection-and-restriction-together",
    "title": "Introduction to SQL. Single entity",
    "section": "Projection and Restriction Together",
    "text": "Projection and Restriction Together\nCombining both techniques, you can select specific columns and filter rows. List the brand name and segment of all brands owned by Hilton Worldwide:\n\nSELECT brandName, brandSegment FROM brand \n  WHERE brandChain = 'Hilton Worldwide';\n\nNow you’re asking, “Show me just the names and segments of Hilton brands.”"
  },
  {
    "objectID": "1-single-entity-complete.html#primary-key-retrieval",
    "href": "1-single-entity-complete.html#primary-key-retrieval",
    "title": "Introduction to SQL. Single entity",
    "section": "Primary Key Retrieval",
    "text": "Primary Key Retrieval\nA primary key uniquely identifies a row. If you query by it, you get at most one result:\n\nSELECT * FROM brand \n  WHERE brandID = 10;\n\nThis is like saying, “Give me all details about the brand with ID 10.”\nImportant Notice that numerical values do not have to be wrapped with quotation marks."
  },
  {
    "objectID": "1-single-entity-complete.html#queries-without-primary-key",
    "href": "1-single-entity-complete.html#queries-without-primary-key",
    "title": "Introduction to SQL. Single entity",
    "section": "Queries Without Primary Key",
    "text": "Queries Without Primary Key\nWithout a primary key, multiple rows can be returned:\n\nSELECT * FROM brand \n  WHERE brandChain = 'Accor';"
  },
  {
    "objectID": "1-single-entity-complete.html#the-in-operator",
    "href": "1-single-entity-complete.html#the-in-operator",
    "title": "Introduction to SQL. Single entity",
    "section": "The IN Operator",
    "text": "The IN Operator\nIf you want to filter by multiple values, IN operator will come handy:\n\nSELECT * FROM brand \n  WHERE brandSegment IN ('Luxury', 'Economy');\n\nThis is the equivalent of saying, “Give me brands that are either Luxury or Economy.”\nYou could get the same results by using WHERE with OR:\n\nSELECT * FROM brand \n    WHERE brandSegment = 'Luxury'\n        OR brandSegment = 'Economy';\n\nDo you see how much more efficient it is with IN?"
  },
  {
    "objectID": "1-single-entity-complete.html#the-not-in-operator",
    "href": "1-single-entity-complete.html#the-not-in-operator",
    "title": "Introduction to SQL. Single entity",
    "section": "The NOT IN Operator",
    "text": "The NOT IN Operator\nTo exclude more than one value, use NOT IN:\n\nSELECT * FROM brand \n  WHERE brandName NOT IN ('Sofitel', 'Thalassa', 'Curio', 'Conrad');\n\nThis means, “Show me everything except these brands.”"
  },
  {
    "objectID": "1-single-entity-complete.html#ordering-columns",
    "href": "1-single-entity-complete.html#ordering-columns",
    "title": "Introduction to SQL. Single entity",
    "section": "Ordering Columns",
    "text": "Ordering Columns\nThe order of selected columns in your query defines how results appear. This just structures the results the way you prefer.\nCompare these two queries\n\nSELECT brandName, brandSegment FROM brand WHERE brandChain = 'Accor';\n\n\nSELECT brandSegment, brandName FROM brand WHERE brandChain = 'Accor';"
  },
  {
    "objectID": "1-single-entity-complete.html#ordering-rows",
    "href": "1-single-entity-complete.html#ordering-rows",
    "title": "Introduction to SQL. Single entity",
    "section": "Ordering Rows",
    "text": "Ordering Rows\nIf you need to sort the results, you can use ORDER BY.\n\n\n\n\n\nList all brands with rooms smaller than 350 square feet with largest first:\n\nSELECT * FROM brand WHERE brandMinSqFt &lt; 350 ORDER BY brandMinSqFt DESC;\n\nThis means, “Show me brands with rooms under 350 sqft, biggest first, and if sizes match, sort alphabetically.”\n\n\n\n\n\n\nTip\n\n\n\nDESC means descending order (biggest first). If you need ascending order (smallest first), you can replace it with ASC or simply remove it (ascending order is default in SQL).\n\n\n\n\n\n\n\n\nNote\n\n\n\nHave you noticed that there are many brands with the same value? We can order results by two columns. If the results in the first column are identical, the second column will be used to sort them. Let’s add brandName to our ORDER BY clause.\n\n\nList all brands with rooms smaller than 350 square feet with largest first. Where areas are identical, list brands in alphabetical order.\n\nSELECT * FROM brand WHERE brandMinSqFt &lt; 350 ORDER BY brandMinSqFt DESC, brandName;\n\n\n\n\n\n\n\nNote\n\n\n\nNotice that our results are ordered by brandMinSqFt in descending order (DESC), and alphabetically by brandName (you can add ASC after brandName to get the same results).\n\n\n\n\n\n\n\n\nTip\n\n\n\nLast one more thing. Notice that we use &lt; in this query. WHERE condition can take all the comparison operators: =, !=, &lt;, &gt;, &lt;=, and &gt;=."
  },
  {
    "objectID": "1-single-entity-complete.html#calculated-fields",
    "href": "1-single-entity-complete.html#calculated-fields",
    "title": "Introduction to SQL. Single entity",
    "section": "Calculated Fields",
    "text": "Calculated Fields\nSQL allows calculations directly in queries. Let’s say we want to convert square feet to square meters in the results (m² = f² / 10.764).\n\nSELECT brandName, brandMinSqFt / 10.764 FROM brand;"
  },
  {
    "objectID": "1-single-entity-complete.html#renaming-output-fields",
    "href": "1-single-entity-complete.html#renaming-output-fields",
    "title": "Introduction to SQL. Single entity",
    "section": "Renaming Output Fields",
    "text": "Renaming Output Fields\nThe column name for our calculated field in the results above doesn’t look nice. To make results clearer, use AS to rename calculated fields (or any other column in your query).\nGet minimum room area in square meters for each brand. Rename the output\n\nSELECT brandName, brandMinSqFt / 10.764 AS brandSqMt FROM brand;\n\nNow the result column will be labeled brandSqMt instead of an anonymous calculation. This new name is called alias."
  },
  {
    "objectID": "1-single-entity-complete.html#eliminating-duplicates",
    "href": "1-single-entity-complete.html#eliminating-duplicates",
    "title": "Introduction to SQL. Single entity",
    "section": "Eliminating Duplicates",
    "text": "Eliminating Duplicates\nThe DISTINCT keyword in SQL is used to eliminate duplicate rows from query results, ensuring that only unique values are displayed. This is particularly useful when reporting different possible values for a specific column, such as brand segments.\nRun this query first. Then, modify it to retrieve a list of all unique brand segments without repetition.\n\nSELECT DISTINCT brandSegment FROM brand;"
  },
  {
    "objectID": "1-single-entity-complete.html#extra-practice-cell",
    "href": "1-single-entity-complete.html#extra-practice-cell",
    "title": "Introduction to SQL. Single entity",
    "section": "Extra practice cell",
    "text": "Extra practice cell\n\n\n\n\nThat’s it for now! 🎉\nEven if it seems like just a little, learning this is already a great achievement!\n\n\n\n\n\n\nRemember, SQL is like having a conversation in English with the database:\n\n“Show me everything” → SELECT * FROM table;\n\n“Give me only what I need” → SELECT column FROM table;\n\n“Filter the results” → WHERE = condition\n\n“Sort them” → ORDER BY column\n\nWith these basics, you’re already on your way to mastering SQL!\n\n\n\n\n\n\n\n\n\nImages and GIFs Disclaimer: Some of the images and GIFs used on this website are not owned by me. They are used for educational and illustrative purposes only. All rights belong to their respective owners. If you believe any content violates copyright, please contact me for prompt removal.\n\n\n\n\n\n\n  \n  \n    © 2025. All Rights Reserved.\n  \n  \n\n  \n  \n    Enabled by Dr. Marcin Bartosiak"
  },
  {
    "objectID": "2-one-to-many-complete.html",
    "href": "2-one-to-many-complete.html",
    "title": "One-to-Many relationship",
    "section": "",
    "text": "Now that you’ve learned how to model a basic, single-entity database, let’s explore attributes, which define the characteristics of an entity.\n\n\nAttributes store important details about each record in a table, helping to describe and organize data effectively.\nIn a database, attributes can be classified based on whether they require a value. A required attribute must always have a value and cannot be left empty, while an optional attribute can be left empty (NULL).\n\n\n\n\n\n\nWarning\n\n\n\nWe use NULL to indicate missing values. Missing values can occur for different reasons, such as an existing attribute without data (e.g., a middle name) or an inapplicable condition (e.g., an apartment number for a house address).\nDon’t confuse NULL values with blank or zero.\nMultiple meanings:\n\nUnknown data\nInapplicable data\nNo value supplied\nValue undefined\n\nWe will come back to NULL values later.\n\n\nEach attribute has a domain, which defines the set of possible values it can take.\n\n\n\n\n\n\nTip\n\n\n\nA domain is the set of possible values that an attribute can have. Think of it like a rule that defines what kind of data is allowed in a column. For example, if you have an attribute “Age,” its domain might be whole numbers between 0 and 120. If you have a “Country” attribute, its domain would be a list of valid country names. Domains help keep data consistent and prevent errors, like entering text in a column meant for numbers.\n\n\nTo uniquely identify each record, identifiers are used—these are attributes that hold unique values for each instance. In relational databases, the primary key serves as this unique identifier.\nSometimes, a composite identifier is needed, which combines two or more attributes to uniquely identify a record (e.g., a combination of Course ID and Student ID to track enrollments).\nAttributes can be classified into different types:\n\nComposite attribute: Attribute that can be subdivided to yield additional attributes\nSimple attribute: Attribute that cannot be subdivided\nDerived attribute: Attribute whose value is calculated from other attributes\n\nDerived using an algorithm (i.e., Yield = Dividend * Quantity)\nSometimes called ‘calculated fields’\n\nSingle-valued attribute: Attribute that holds only a single value\nMultivalued attributes: Attributes that hold many values\n\nUnderstanding these attribute types is essential for designing efficient databases that accurately represent real-world scenarios.\n\n\n\nThink of the data scientists database we modeled last week.\n\n\n\n\n\nHow would the model change, if our data scientist could get a second degree? Or multiple certificates?\n\n\n\n\n\n\nNote\n\n\n\n\n\n\n\n\n\n\n\n\n\nA multivalued attribute is an attribute that can have multiple values for a single entity. For example, an employee might have multiple phone numbers or an author might write multiple books. In database design, multivalued attributes should be handled properly to maintain data consistency. One approach is to create separate attributes for each component of the multivalued attribute (e.g., Phone_1, Phone_2). A better approach is to create a new entity that holds the multiple values, linking it to the original entity through a relationship (e.g., an Employee_Phone table linked to an Employee table). This ensures better organization, eliminates redundancy, and improves data integrity.\nNow, try to apply that knowledge to our data scientists database.\n\n\n\n\n\n\nNote\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThere is one more new thing in the model above. Habe you noticed that the entities are “linked”. These are entity relationships.\nIn database design, relationships define how different entities (tables) are associated with one another. These relationships follow business rules, which describe how entities interact based on real-world scenarios. For example:\n\na customer can place many orders\na team can have many players.\n\nThese relationships help ensure that data is properly structured and connected.\nA key characteristic of relationships is that they are bi-directional, meaning they should always be read both ways. For example, while a customer can place many orders, each order is placed by only one customer. Understanding relationships in both directions is crucial for designing a clear and logical database structure.\nProperly defining entity relationships improves data integrity, reduces redundancy, and enhances query efficiency. By embedding relationships directly into the database design, businesses can enforce rules and constraints that reflect real-world operations, making data retrieval and management more efficient.\nConsider our brand table from last week. Let’s say we want to track also info about lodging chains.\n\n\n\n\n\nSince we have multiple hotels owned by the same chain, storing this information in one table would create redundancies.\nIt is better to create a new entity, and specify the relationship beween the two.\n\n\n\n\n\n\n\n\nThis particular case of relationship is called one-to-many relationship.\nA one-to-many relationship means that one record in a table is linked to many records in another table. Like in our case, one lodging chain can own many hotels, but each hotel belongs to only one chain. See the example of Hilton Hotels:\n\n\n\n\n\nThis type of relationship helps organize data efficiently, avoiding duplication and ensuring consistency.\nLet’s go back to our stock portfolio table for a second. Remember that it contains stock market data that is used by an investment firm dealing with international commodities and agricultural products.\n\n\n\n\n\n\n\nStock market data\n\n\nWe said that there might be several problems (called anomalies) with it:\n\nInsertion anomalies occur when adding new data is difficult due to missing dependencies.\nUpdate anomalies lead to inconsistencies when changes must be made in multiple places.\nDeletion anomalies cause unintended data loss when removing a record also removes critical information.\n\nLet’s try to design a database to store our stock portfolio data!\n\n\n\n\n\n\nNote\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDevelop a data model for Marriott International to keep track of relevant information about its portfolio of hotels\nFocus on the assets, not on customers, employees, or transactions\n\n\n\n\n\n\n\n\nHierarchical relationships occur frequently in databases and follow a one-to-many structure, where one entity has multiple related entities beneath it. This structure is similar to a tree, where a parent node can have multiple child nodes, but each child has only one parent. For example, in a company database, one manager oversees many employees, but each employee has only one direct manager. Similarly, a firm can have many divisions, a division can have many departments, and a department can have many sections (see the example below).\nThese relationships help organize data logically and efficiently, making it easier to navigate and retrieve information.\n\n\n\n\n\n\n\n\n\nSo far, we covered a lot of abstract terms like entity, instances, attributes etc. As you correctly notice, we could simply say table, row, and columns instead. However, there is a good reason for using these abstract terms.\nUnderstanding entities, instances, and attributes rather than just tables, rows, and columns is important because it helps us focus on the conceptual meaning of the data rather than just its storage format.\n\nEntity vs. Table: An entity represents a real-world object or concept (like a “Customer” or “Product”), while a table is just how we store data in a database. Thinking in terms of entities helps us design better database models before deciding how to implement them.\n\nInstance vs. Row: An instance is a specific example of an entity (e.g., a particular customer, “John Doe”). A row is how that instance is stored in a table. Thinking in terms of instances makes it easier to understand relationships between data.\n\nAttribute vs. Column: An attribute describes a characteristic of an entity (e.g., a customer’s “Name” or “Email”). A column is just where this data is stored. By focusing on attributes first, we ensure that all necessary information is captured properly.\n\nBy using these abstract concepts, we can design flexible and well-structured databases before deciding how to implement them in a specific DBMS.\n\n\nWhen designing a relational database, entities and their relationships are translated into tables and columns. The process follows these key steps:\n\nEach entity becomes a table\n\nThe entity name becomes the table name\n\nEach attribute becomes a column\n\n\n\n\nIn a one-to-many relationship, we structure the tables as follows:\n\nAdd a column to the table on the “many” side of the relationship\n\nStore the identifier of the “one” side in this added column\n\nThis ensures proper linkage between related data while maintaining database integrity.\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nThe conceptual database model uses a parsimonious notation, meaning that extra attributes do not need to be explicitly modeled, as they can be inferred from the relationship.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEnsuring data integrity is crucial in relational databases. Entity integrity maintains the uniqueness and validity of primary keys, while referential integrity ensures that foreign keys correctly reference existing primary keys. These rules help prevent inconsistencies and maintain reliable relationships between tables.\n\n\n\nA primary key must be unique.\n\nPrimary keys can never have NULL values.\n\n\n\n\n\nFor every non-null value of a foreign key, there must be a matching primary key with that value.\n\nExample: For every value of chainID in the brand table, there must be a corresponding value of chainID in the lodgingChain table.\n\nA primary key must exist before a foreign key can be defined.\n\n##Implementable database model\nRemember these beatiful drawings?\n\n\n\n\n\n\n\n\nHand-drawn crowfoot model\n\n\n\n\n\n\n\nER diagram\n\n\n\n\n\n\nFigure 1\n\n\n\nSo far, we mainly focused on a conceptual database model. But there is also implementational (or logical) database model.\nThe conceptual database model focuses on the high-level structure of the data, emphasizing entities, relationships, and constraints without considering how the data will be physically stored. It serves as a blueprint for understanding data requirements and is independent of any specific database management system (DBMS). On the other hand, the implementational database model translates the conceptual design into a format that a DBMS can use, incorporating tables, columns, keys, and constraints based on a specific database system. While the conceptual model is abstract and business-oriented, the implementational model is detailed and technical, bridging the gap between design and actual database implementation.\nWe will learn how to design such implementational models in few weeks. First, let’s learn how to read them.\n\n\n\n\n\n\n\n\n\n\n\n\n\nAn implementational database model\n\n\n\n\n\n\n\n\n\n\n\nWorkbench symbolism\n\n\n\n\n\n\n\n\n\nIn database modeling, identifying and non-identifying relationships refer to how entities are related to one another. An identifying relationship occurs when the child entity’s existence depends on the parent entity, and the child entity’s primary key includes the parent’s primary key. This often happens in cases where the child cannot exist without the parent (e.g., an order item cannot exist without an order). In contrast, a non-identifying relationship occurs when the child entity can exist independently of the parent entity, and the child’s primary key does not include the parent’s primary key. Here, the relationship is more loosely coupled (e.g., a customer can exist without an address).\nIn the implementational model, the relationships will look slightly differnt.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nIn the conceptual model, we will have to add a small plus (+) over a relationship, to mark the identifying relationship."
  },
  {
    "objectID": "2-one-to-many-complete.html#attributes",
    "href": "2-one-to-many-complete.html#attributes",
    "title": "One-to-Many relationship",
    "section": "",
    "text": "Attributes store important details about each record in a table, helping to describe and organize data effectively.\nIn a database, attributes can be classified based on whether they require a value. A required attribute must always have a value and cannot be left empty, while an optional attribute can be left empty (NULL).\n\n\n\n\n\n\nWarning\n\n\n\nWe use NULL to indicate missing values. Missing values can occur for different reasons, such as an existing attribute without data (e.g., a middle name) or an inapplicable condition (e.g., an apartment number for a house address).\nDon’t confuse NULL values with blank or zero.\nMultiple meanings:\n\nUnknown data\nInapplicable data\nNo value supplied\nValue undefined\n\nWe will come back to NULL values later.\n\n\nEach attribute has a domain, which defines the set of possible values it can take.\n\n\n\n\n\n\nTip\n\n\n\nA domain is the set of possible values that an attribute can have. Think of it like a rule that defines what kind of data is allowed in a column. For example, if you have an attribute “Age,” its domain might be whole numbers between 0 and 120. If you have a “Country” attribute, its domain would be a list of valid country names. Domains help keep data consistent and prevent errors, like entering text in a column meant for numbers.\n\n\nTo uniquely identify each record, identifiers are used—these are attributes that hold unique values for each instance. In relational databases, the primary key serves as this unique identifier.\nSometimes, a composite identifier is needed, which combines two or more attributes to uniquely identify a record (e.g., a combination of Course ID and Student ID to track enrollments).\nAttributes can be classified into different types:\n\nComposite attribute: Attribute that can be subdivided to yield additional attributes\nSimple attribute: Attribute that cannot be subdivided\nDerived attribute: Attribute whose value is calculated from other attributes\n\nDerived using an algorithm (i.e., Yield = Dividend * Quantity)\nSometimes called ‘calculated fields’\n\nSingle-valued attribute: Attribute that holds only a single value\nMultivalued attributes: Attributes that hold many values\n\nUnderstanding these attribute types is essential for designing efficient databases that accurately represent real-world scenarios."
  },
  {
    "objectID": "2-one-to-many-complete.html#multivalued-attributes",
    "href": "2-one-to-many-complete.html#multivalued-attributes",
    "title": "One-to-Many relationship",
    "section": "",
    "text": "Think of the data scientists database we modeled last week.\n\n\n\n\n\nHow would the model change, if our data scientist could get a second degree? Or multiple certificates?\n\n\n\n\n\n\nNote\n\n\n\n\n\n\n\n\n\n\n\n\n\nA multivalued attribute is an attribute that can have multiple values for a single entity. For example, an employee might have multiple phone numbers or an author might write multiple books. In database design, multivalued attributes should be handled properly to maintain data consistency. One approach is to create separate attributes for each component of the multivalued attribute (e.g., Phone_1, Phone_2). A better approach is to create a new entity that holds the multiple values, linking it to the original entity through a relationship (e.g., an Employee_Phone table linked to an Employee table). This ensures better organization, eliminates redundancy, and improves data integrity.\nNow, try to apply that knowledge to our data scientists database.\n\n\n\n\n\n\nNote"
  },
  {
    "objectID": "2-one-to-many-complete.html#entity-relaionship",
    "href": "2-one-to-many-complete.html#entity-relaionship",
    "title": "One-to-Many relationship",
    "section": "",
    "text": "There is one more new thing in the model above. Habe you noticed that the entities are “linked”. These are entity relationships.\nIn database design, relationships define how different entities (tables) are associated with one another. These relationships follow business rules, which describe how entities interact based on real-world scenarios. For example:\n\na customer can place many orders\na team can have many players.\n\nThese relationships help ensure that data is properly structured and connected.\nA key characteristic of relationships is that they are bi-directional, meaning they should always be read both ways. For example, while a customer can place many orders, each order is placed by only one customer. Understanding relationships in both directions is crucial for designing a clear and logical database structure.\nProperly defining entity relationships improves data integrity, reduces redundancy, and enhances query efficiency. By embedding relationships directly into the database design, businesses can enforce rules and constraints that reflect real-world operations, making data retrieval and management more efficient.\nConsider our brand table from last week. Let’s say we want to track also info about lodging chains.\n\n\n\n\n\nSince we have multiple hotels owned by the same chain, storing this information in one table would create redundancies.\nIt is better to create a new entity, and specify the relationship beween the two."
  },
  {
    "objectID": "2-one-to-many-complete.html#one-to-many-relationship",
    "href": "2-one-to-many-complete.html#one-to-many-relationship",
    "title": "One-to-Many relationship",
    "section": "",
    "text": "This particular case of relationship is called one-to-many relationship.\nA one-to-many relationship means that one record in a table is linked to many records in another table. Like in our case, one lodging chain can own many hotels, but each hotel belongs to only one chain. See the example of Hilton Hotels:\n\n\n\n\n\nThis type of relationship helps organize data efficiently, avoiding duplication and ensuring consistency.\nLet’s go back to our stock portfolio table for a second. Remember that it contains stock market data that is used by an investment firm dealing with international commodities and agricultural products.\n\n\n\n\n\n\n\nStock market data\n\n\nWe said that there might be several problems (called anomalies) with it:\n\nInsertion anomalies occur when adding new data is difficult due to missing dependencies.\nUpdate anomalies lead to inconsistencies when changes must be made in multiple places.\nDeletion anomalies cause unintended data loss when removing a record also removes critical information.\n\nLet’s try to design a database to store our stock portfolio data!\n\n\n\n\n\n\nNote\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDevelop a data model for Marriott International to keep track of relevant information about its portfolio of hotels\nFocus on the assets, not on customers, employees, or transactions\n\n\n\n\n\n\n\n\nHierarchical relationships occur frequently in databases and follow a one-to-many structure, where one entity has multiple related entities beneath it. This structure is similar to a tree, where a parent node can have multiple child nodes, but each child has only one parent. For example, in a company database, one manager oversees many employees, but each employee has only one direct manager. Similarly, a firm can have many divisions, a division can have many departments, and a department can have many sections (see the example below).\nThese relationships help organize data logically and efficiently, making it easier to navigate and retrieve information."
  },
  {
    "objectID": "2-one-to-many-complete.html#mapping-to-a-relational-database",
    "href": "2-one-to-many-complete.html#mapping-to-a-relational-database",
    "title": "One-to-Many relationship",
    "section": "",
    "text": "So far, we covered a lot of abstract terms like entity, instances, attributes etc. As you correctly notice, we could simply say table, row, and columns instead. However, there is a good reason for using these abstract terms.\nUnderstanding entities, instances, and attributes rather than just tables, rows, and columns is important because it helps us focus on the conceptual meaning of the data rather than just its storage format.\n\nEntity vs. Table: An entity represents a real-world object or concept (like a “Customer” or “Product”), while a table is just how we store data in a database. Thinking in terms of entities helps us design better database models before deciding how to implement them.\n\nInstance vs. Row: An instance is a specific example of an entity (e.g., a particular customer, “John Doe”). A row is how that instance is stored in a table. Thinking in terms of instances makes it easier to understand relationships between data.\n\nAttribute vs. Column: An attribute describes a characteristic of an entity (e.g., a customer’s “Name” or “Email”). A column is just where this data is stored. By focusing on attributes first, we ensure that all necessary information is captured properly.\n\nBy using these abstract concepts, we can design flexible and well-structured databases before deciding how to implement them in a specific DBMS.\n\n\nWhen designing a relational database, entities and their relationships are translated into tables and columns. The process follows these key steps:\n\nEach entity becomes a table\n\nThe entity name becomes the table name\n\nEach attribute becomes a column\n\n\n\n\nIn a one-to-many relationship, we structure the tables as follows:\n\nAdd a column to the table on the “many” side of the relationship\n\nStore the identifier of the “one” side in this added column\n\nThis ensures proper linkage between related data while maintaining database integrity.\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nThe conceptual database model uses a parsimonious notation, meaning that extra attributes do not need to be explicitly modeled, as they can be inferred from the relationship.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEnsuring data integrity is crucial in relational databases. Entity integrity maintains the uniqueness and validity of primary keys, while referential integrity ensures that foreign keys correctly reference existing primary keys. These rules help prevent inconsistencies and maintain reliable relationships between tables.\n\n\n\nA primary key must be unique.\n\nPrimary keys can never have NULL values.\n\n\n\n\n\nFor every non-null value of a foreign key, there must be a matching primary key with that value.\n\nExample: For every value of chainID in the brand table, there must be a corresponding value of chainID in the lodgingChain table.\n\nA primary key must exist before a foreign key can be defined.\n\n##Implementable database model\nRemember these beatiful drawings?\n\n\n\n\n\n\n\n\nHand-drawn crowfoot model\n\n\n\n\n\n\n\nER diagram\n\n\n\n\n\n\nFigure 1\n\n\n\nSo far, we mainly focused on a conceptual database model. But there is also implementational (or logical) database model.\nThe conceptual database model focuses on the high-level structure of the data, emphasizing entities, relationships, and constraints without considering how the data will be physically stored. It serves as a blueprint for understanding data requirements and is independent of any specific database management system (DBMS). On the other hand, the implementational database model translates the conceptual design into a format that a DBMS can use, incorporating tables, columns, keys, and constraints based on a specific database system. While the conceptual model is abstract and business-oriented, the implementational model is detailed and technical, bridging the gap between design and actual database implementation.\nWe will learn how to design such implementational models in few weeks. First, let’s learn how to read them.\n\n\n\n\n\n\n\n\n\n\n\n\n\nAn implementational database model\n\n\n\n\n\n\n\n\n\n\n\nWorkbench symbolism\n\n\n\n\n\n\n\n\n\nIn database modeling, identifying and non-identifying relationships refer to how entities are related to one another. An identifying relationship occurs when the child entity’s existence depends on the parent entity, and the child entity’s primary key includes the parent’s primary key. This often happens in cases where the child cannot exist without the parent (e.g., an order item cannot exist without an order). In contrast, a non-identifying relationship occurs when the child entity can exist independently of the parent entity, and the child’s primary key does not include the parent’s primary key. Here, the relationship is more loosely coupled (e.g., a customer can exist without an address).\nIn the implementational model, the relationships will look slightly differnt.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nIn the conceptual model, we will have to add a small plus (+) over a relationship, to mark the identifying relationship."
  },
  {
    "objectID": "2-one-to-many-complete.html#aggregate-functions",
    "href": "2-one-to-many-complete.html#aggregate-functions",
    "title": "One-to-Many relationship",
    "section": "Aggregate functions",
    "text": "Aggregate functions\nIn SQL aggregate functions help you combine lots of data into one result. These are like math operations that work on whole columns of information instead of just single values.\nHere are the main aggregate functions:\n\nCOUNT(): Tells you how many items are in your data (like counting how many customers you have)\nSUM(): Adds up numbers (like finding your total sales for the month)\nAVG(): Calculates the average (like finding the typical price of products)\nMIN(): Finds the smallest value (like identifying your cheapest item)\nMAX(): Finds the largest value (like identifying your most expensive item)\n\nThese functions are super helpful when you want to get quick summaries from your database without looking at every single row of information. You simply add the to your query follwoing this pattern:\n\nSELECT FUNCTION(columnName) FROM tableName;\n\nLet’s test them in our brand table!\nFind the average hotel room square footage for all brands.\n\nSELECT AVG(brandMinSqFt) AS avgArea FROM brand;\n\nWhat is the area of the largest hotel room specification in the DB? Rename as “Biggest Room”\n\nSELECT MAX(brandMinSqFt) AS 'Biggest Room' FROM brand;\n\nHow many total brands do we have data for?\n\nSELECT COUNT(*)FROM brand;\n\n\n\n\n\n\n\nTip\n\n\n\nThe query below is an equivalent to the previous one. Can you explain why?\n\n\n\nSELECT COUNT(brandName)FROM brand;\n\nWhat is the total number of hotel rooms? - All rooms of all chains.\n\n\n\n\n\n\nTip\n\n\n\nThe solve this task, you will have to query different table…\n\n\n\nSELECT SUM(numRooms) FROM lodgingchain;"
  },
  {
    "objectID": "2-one-to-many-complete.html#joining-tables",
    "href": "2-one-to-many-complete.html#joining-tables",
    "title": "One-to-Many relationship",
    "section": "JOINing tables",
    "text": "JOINing tables\nJoining tables in SQL allows you to combine related data from different tables into a single result set. The simplest way to join tables is using the WHERE clause with the equals operator (which is great!🤩 because you already know how to use WHERE).\nHere’s how it works:\n\nBasic JOIN using WHERE: You list both tables in the FROM clause and use WHERE to match related columns\nExample syntax: SELECT * FROM brand, lodgingchain WHERE brand.chainID = lodgingchain.chainID;\nHow it works: This tells SQL to match each row from the first table with rows from the second table where the specified columns have the same value\nResult: Only rows where the join condition is true appear in your results\n\nThis approach creates what’s known as an “inner join” - it only shows data where there are matches between both tables. We will explore more powerful ways to join tables in our next session.\nTry it yourself!\n\nSELECT * FROM brand, lodgingchain \n  WHERE brand.chainID = lodgingchain.chainID;\n\n\nExercise\nReport the headquarter location of each brand’s parent chain.Order by brand name.\n\nSELECT brandName, headquarters\n    FROM brand,lodgingchain\n    WHERE brand.chainID = lodgingchain.chainID\n    ORDER BY brandName;\n\n\n\n\n\n\n\nWatch out for cross-products\n\n\n\nA cross-product in SQL occurs when you join two tables without specifying a join condition. This creates a result set containing every possible combination of rows from both tables. For example, if you run SELECT * FROM brand, lodgingchain; without a WHERE clause, each row from the brand table will be paired with every row from the lodgingchain table. If your brand table has 100 rows and your lodgingchain table has 500 rows, you’ll end up with 50,000 rows in your result set.\nCross-products are rarely useful in practical applications and can cause serious performance problems with large tables, which is why properly specifying join conditions with WHERE clauses is essential for efficient queries.\n\nSELECT * FROM brand, lodgingchain;\n\n\n\n\n\n\n\n\n\nThe risk of homonyms\n\n\n\nHomonyms in database design—particularly columns with identical names across different tables—create risks. When fields like “id” or “status” appear in multiple tables but represent different concepts, developers may mistakenly join these columns or apply incorrect business logic. This confusion leads to flawed queries, unpredictable results, and potential data corruption.\nTo prevent these issues, best practices include using descriptive, context-specific column names (e.g., “customer_id” instead of just “id”), implementing consistent naming conventions, and maintaining clear documentation of each column’s specific meaning and purpose.\nHowever, sometimes you may find a database with homonyms. Let’s take a look at our nation-stock database. Try to run the query below. What is the result? How would you change the query to get the correct result?\n\n\n\n\n\n\nSELECT * FROM stock, nation\n    WHERE stock.natcode = nation.natcode;"
  },
  {
    "objectID": "2-one-to-many-complete.html#grouping-the-results",
    "href": "2-one-to-many-complete.html#grouping-the-results",
    "title": "One-to-Many relationship",
    "section": "Grouping the results",
    "text": "Grouping the results\nThe GROUP BY clause in SQL allows you to organize similar data into groups and perform aggregate functions on each group separately rather than on the entire table.\nHere’s how it works:\n\nBasic purpose: Groups rows that have the same values in specified columns\nTypical usage: Used with aggregate functions (COUNT, SUM, AVG, etc.) to perform calculations on each group\nExample syntax: SELECT chainHQ, COUNT(*) FROM lodgingChaing GROUP BY chainHQ;\nResult: One row for each unique value in the grouped column(s)\nMultiple columns: You can group by multiple columns like GROUP BY department, job_title\nCommon requirement: Generally, columns in the SELECT list must either be part of the GROUP BY clause or used within an aggregate function\n\n\nSELECT headquarters, COUNT(*) FROM lodgingchain \n  GROUP BY headquarters;\n\nGROUP BY is essential for summarizing data and generating reports that show totals, averages, or counts for different categories within your data.\n\nExercise\nReport number of brands in each chain by chain name (not chainID).\n\nSELECT chainName, COUNT(brandName) AS NumBrands\n    FROM brand, lodgingchain \n    WHERE brand.chainID = lodgingchain.chainID\n    GROUP BY chainName;\n\n\n\nHAVING\nIn SQL, the HAVING clause is used to filter the results of a GROUP BY query. It is like WHERE clause for grouped results. However, HAVING allows you to filter groups based on aggregate functions (like COUNT(), SUM(), AVG(), etc.), which cannot be done using the WHERE clause.\n\n\n\n\n\n\nNote\n\n\n\nThe WHERE clause filters rows before they are grouped, while HAVING filters groups after the aggregation is done.\n\n\nConsider the previous example. We can easily filter the results and keep only, for example, countries with at least 3 headquarters.\n\nSELECT headquarters, COUNT(*) FROM lodgingchain \n  GROUP BY headquarters\n  HAVING COUNT(*) &gt;= 3;\n\n\nExercise\nReport the average room area and number of brands for all chains that own more than one brand\n\nSELECT chainName, AVG(brandMinSqFt) AS avgArea, COUNT(*) AS totalBrands\n    FROM brand, lodgingchain \n    WHERE lodgingchain.chainID = brand.chainID  \n    GROUP BY chainName \n    HAVING COUNT(*) &gt;= 2;"
  },
  {
    "objectID": "2-one-to-many-complete.html#subqueries",
    "href": "2-one-to-many-complete.html#subqueries",
    "title": "One-to-Many relationship",
    "section": "Subqueries",
    "text": "Subqueries\nA subquery is a query that is nested inside another query. It is used to retrieve data that will be used in the main query for filtering, selecting, or computing results. Subqueries can be placed in the SELECT, FROM, or WHERE clauses of a SQL query.\nThere are two main types of subqueries: 1. Scalar subqueries: Return a single value. 2. Table subqueries: Return multiple rows and columns.\nFor now, we will only focus on scalar subqueries.\nWhen to Use Subqueries:\n\nWhen you need to compare a value in a column with a result from another query.\nWhen you want to perform an operation on a subset of data before using it in the main query.\nWhen a join is not possible or too complex to use.\n\n\nExample of a Subquery in the WHERE Clause:\nReport the name of all brands headquartered in the same country as the Grand Hyatt.\n\nSELECT brandName FROM lodgingChain, brand \n  WHERE lodgingChain.chainID = brand.chainID \n  AND headquarters IN (SELECT headquarters \n                FROM lodgingChain, brand\n                WHERE lodgingChain.chainID = brand.chainID \n                AND brandName='Grand Hyatt');\n\nA subquery in the WHERE clause can be used to filter results based on data from another table. You can run the subquery as a separate query and see its results.\n\nSELECT headquarters FROM lodgingChain, brand\n  WHERE lodgingChain.chainID = brand.chainID \n  AND brandName='Grand Hyatt'\n\n\n\nExercise\nReport all data about the oldest chain with worldwide presence (i.e., founded earliest)\n\nSELECT * FROM lodgingchain \n  WHERE yearfounded = (\n    SELECT MIN(yearfounded) FROM lodgingchain);"
  },
  {
    "objectID": "2-one-to-many-complete.html#extra-practice-cell",
    "href": "2-one-to-many-complete.html#extra-practice-cell",
    "title": "One-to-Many relationship",
    "section": "Extra practice cell",
    "text": "Extra practice cell\n\n\n\n\n\n\n\n\n\n\nThat’s it for now, but this is just the beginning! 🎉\nThere’s so much more to explore. With each step, you’ll unlock more powerful ways to interact with databases and make sense of data. Keep practicing, stay curious, and get ready for even more exciting topics ahead!\n\n\n\n\n\n\n\n\nImages and GIFs Disclaimer: Some of the images and GIFs used on this website are not owned by me. They are used for educational and illustrative purposes only. All rights belong to their respective owners. If you believe any content violates copyright, please contact me for prompt removal.\n\n\n\n\n\n\n  \n  \n    © 2025. All Rights Reserved.\n  \n  \n\n  \n  \n    Enabled by Dr. Marcin Bartosiak"
  },
  {
    "objectID": "3-many-to-many-complete.html",
    "href": "3-many-to-many-complete.html",
    "title": "Many-to-Many relationship",
    "section": "",
    "text": "One-to-many relationship will not always be enough to represent all the situations in real life.\n\n\nA sales form is a document or (digital) record that captures details of a sale, including the products sold, the quantities, the price, the date, and the customer information.\n\nIf you think about it, it would be hard to design a one-to-many relationship for a sales form:\n\nYou can sell (conceptually) the same item many times. (E.g. Yesterday you sold two IPhones. Today you also sold an IPhone.)\nIn one sale, you can sell various products. (E.g. A client bought an Iphone and an IPad.)\n\nTo represent this situation in database modeling, we would need a many-to-many relationship between sales and products. This is because a single sale can include multiple products, and the same product can be sold in multiple sales. To model this relationship, a junction table (often called sales_details or order_items) is used, linking the sales table (which stores each transaction) with the products table. This table typically includes fields such as sale_id, product_id, quantity, and price. The many-to-many nature of this relationship allows for flexibility in tracking sales history and inventory management.\n\n\n\nIn a many-to-many (m:m) relationship, a third entity is required to properly map the connection between the two related entities. This third entity, known as an associative entity, acts as a bridge between them.\n\nIn database modeling, the associative table includes two foreign keys, one for each of the entities in the m:m relationship, ensuring that each instance of the relationship is properly recorded. Additionally, a foreign key can also be part of the primary key of the associative entity.\n\nFor example, in a sales database, a LINEITEM table is used to associate SALE and PRODUCT. The LINEITEM table is identified by concatenating lineno and saleno, as indicated by the + on the crow’s foot notation. This structure ensures data integrity and enforces the same relational rules as any other table in the database.\nAs you already know the concepts related to the implementable model, let’s take a look at many-to-many model:\n\n\n\nLet’s go back to our hotel database. So far it was a fairly simple database. However, its’ main purpose is not to track hotels. It stores data about hotel reviews, scraped from the Internet.\n\nHow would you model the following scenario? - An author can write reviews about many hotels. - A hotel can have reviews written by many authors.\n\n\n\n\n\n\nNote\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSo far, we’ve learned how to join tables using the WHERE clause—this is known as an implicit join.\n\n\n\n\n\n\nNote\n\n\n\nImplicit JOIN (OR “Comma syntax” JOIN)\nSELECT ... FROM ..., ... WHERE fk = pk;\nSELECT * FROM table1, table2 WHERE table1.id = table2.id;\n\n\nWhile implicit joins work, SQL also provides a more structured way to combine tables: explicit joins using keywords like JOIN ... ON.\nThe key difference is that implicit joins mix filtering (WHERE) with table relationships, making queries harder to read as they grow. Explicit joins, on the other hand, separate the logic of joining tables from filtering rows, improving readability and maintainability.\n\n\n\n\n\n\nNote\n\n\n\nExplicit JOIN\nSELECT ... FROM ... JOIN ... ON fk = pk;\nSELECT * FROM table1 JOIN table2 ON table1.id = table2.id;\n\n\nDifferent join syntaxes exist because SQL is designed to be flexible. In some cases, explicit joins provide better performance and clarity, especially when dealing with complex queries or different types of joins (we will see them later).\nThere many ways to JOIN tbles in SQL. All these methods are called Equijoin.\nCompare These queries:\n\nSELECT * FROM brand, lodgingchain WHERE brand.chainId = lodgingchain.chainId;\n\n\nSELECT * FROM brand JOIN lodgingchain ON brand.chainId = lodgingchain.chainId;\n\n\nSELECT * FROM brand NATURAL JOIN lodgingchain;\n\n\nSELECT * FROM brand JOIN lodgingchain USING(chainId);\n\n\n\nList the authors that have reviewed hotels. Report the author name, the hotel ID and the name of the hotels. Order the output by author name.\nUse all four methods\nimplicit JOIN (WHERE)\n\nSELECT authorNickname, hotel.hotelId, hotelName\n FROM author, review, hotel\n WHERE review.authorId = author.authorId\n AND review.hotelId = hotel.hotelId\n ORDER BY authorNickname;\n\nNATURAL JOIN\n\nSELECT authorNickname, hotelId, hotelName \n FROM author \n  NATURAL JOIN review \n  NATURAL JOIN hotel \n ORDER BY authorNickname;\n\nJOIN … USING\n\nSELECT authorNickname, hotelId, hotelName \n FROM author \n  JOIN review USING(authorId) \n  JOIN hotel USING(hotelId) \n ORDER BY authorNickname;\n \n\nJOIN … ON\n\nSELECT authorNickname, hotel.hotelId, hotelName\n FROM author JOIN review JOIN hotel\n  ON  hotel.hotelId = review.hotelId\n  AND review.authorId = author.authorId\nORDER BY authorNickname;\n\n\n\nNATURAL JOIN\n\nJoin on “same” column (name and data type)\nRisky: the condition is implicit\n\nUSING()\n\nExplicitly specifies columns in the equijoin\nAllows multiple (comma separated) columns\n\nON\n\nThe ON clause enables multiple conditions\nLogical operator can be used to combine condition\nON and USING are mutually exclusive\nON enables inequality joins (Theta JOIN – more later)\n\n\n\n\n\nSo far, you’ve learner about INNER JOIN, which is the JOIN that returns only the rows that have matching values in both tables based on a specified condition. It eliminates unmatched rows from both tables, ensuring that only records with a relationship between them appear in the result set.\nHowever, there are different JOINS too. An OUTER JOIN is a powerful SQL feature used when you want to retain “dangling tuples”—rows that don’t have a match in the other table. Unlike inner joins, which only return matching records, outer joins ensure that unmatched rows from one or both tables are included in the results. These missing values are padded with NULLs based on the type of outer join used.\n\nA LEFT OUTER JOIN returns all rows from the left table, along with matching rows from the right table. If there’s no match, NULLs are used for the right table’s columns.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSELECT * FROM t1 LEFT OUTER JOIN t2 USING (id);\n\n\n\n\nA RIGHT OUTER JOIN does the opposite—it keeps all rows from the right table and includes matching rows from the left table, filling in NULLs when no match is found.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSELECT * FROM t1 RIGHT OUTER JOIN t2 USING (id);\n\n\n\n\nA FULL OUTER JOIN includes all rows from both tables, ensuring that even non-matching rows from either table appear, with NULLs where data is missing.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSELECT * FROM t1 RIGHT OUTER JOIN t2 USING (id);\n\n\n\nOuter joins are especially useful for analyzing incomplete data, maintaining records even when relationships are not fully established, and ensuring that no important information is lost in queries.\n\n\n\nProvide a list of all chain names and their respective brands. Order the list by chain name.\nTip: Keep in mind that not all chains have sub-brands.\n\nSELECT chainName, brandName\n FROM lodgingchain LEFT OUTER JOIN brand USING(chainId)\n ORDER BY chainName;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThat’s it for this lesson on SQL joins! Understanding how to combine data from multiple tables is a crucial skill for making informed business decisions. Whether you’re analyzing sales trends, tracking customer behavior, or managing inventory, SQL joins help you unlock valuable insights from your data. As you continue learning, you’ll discover even more ways to refine and optimize your queries. Keep practicing, and soon, you’ll be confidently using SQL to drive smarter business strategies! 🚀\n\n\n\n\n\n\n\n\n\nImages and GIFs Disclaimer: Some of the images and GIFs used on this website are not owned by me. They are used for educational and illustrative purposes only. All rights belong to their respective owners. If you believe any content violates copyright, please contact me for prompt removal.\n\n\n\n\n\n\n  \n  \n    © 2025. All Rights Reserved.\n  \n  \n\n  \n  \n    Enabled by Dr. Marcin Bartosiak"
  },
  {
    "objectID": "3-many-to-many-complete.html#a-sales-form-example",
    "href": "3-many-to-many-complete.html#a-sales-form-example",
    "title": "Many-to-Many relationship",
    "section": "",
    "text": "A sales form is a document or (digital) record that captures details of a sale, including the products sold, the quantities, the price, the date, and the customer information.\n\nIf you think about it, it would be hard to design a one-to-many relationship for a sales form:\n\nYou can sell (conceptually) the same item many times. (E.g. Yesterday you sold two IPhones. Today you also sold an IPhone.)\nIn one sale, you can sell various products. (E.g. A client bought an Iphone and an IPad.)\n\nTo represent this situation in database modeling, we would need a many-to-many relationship between sales and products. This is because a single sale can include multiple products, and the same product can be sold in multiple sales. To model this relationship, a junction table (often called sales_details or order_items) is used, linking the sales table (which stores each transaction) with the products table. This table typically includes fields such as sale_id, product_id, quantity, and price. The many-to-many nature of this relationship allows for flexibility in tracking sales history and inventory management."
  },
  {
    "objectID": "3-many-to-many-complete.html#implementing-many-to-many",
    "href": "3-many-to-many-complete.html#implementing-many-to-many",
    "title": "Many-to-Many relationship",
    "section": "",
    "text": "In a many-to-many (m:m) relationship, a third entity is required to properly map the connection between the two related entities. This third entity, known as an associative entity, acts as a bridge between them.\n\nIn database modeling, the associative table includes two foreign keys, one for each of the entities in the m:m relationship, ensuring that each instance of the relationship is properly recorded. Additionally, a foreign key can also be part of the primary key of the associative entity.\n\nFor example, in a sales database, a LINEITEM table is used to associate SALE and PRODUCT. The LINEITEM table is identified by concatenating lineno and saleno, as indicated by the + on the crow’s foot notation. This structure ensures data integrity and enforces the same relational rules as any other table in the database.\nAs you already know the concepts related to the implementable model, let’s take a look at many-to-many model:\n\n\n\nLet’s go back to our hotel database. So far it was a fairly simple database. However, its’ main purpose is not to track hotels. It stores data about hotel reviews, scraped from the Internet.\n\nHow would you model the following scenario? - An author can write reviews about many hotels. - A hotel can have reviews written by many authors.\n\n\n\n\n\n\nNote"
  },
  {
    "objectID": "3-many-to-many-complete.html#database-manipulation",
    "href": "3-many-to-many-complete.html#database-manipulation",
    "title": "Many-to-Many relationship",
    "section": "",
    "text": "So far, we’ve learned how to join tables using the WHERE clause—this is known as an implicit join.\n\n\n\n\n\n\nNote\n\n\n\nImplicit JOIN (OR “Comma syntax” JOIN)\nSELECT ... FROM ..., ... WHERE fk = pk;\nSELECT * FROM table1, table2 WHERE table1.id = table2.id;\n\n\nWhile implicit joins work, SQL also provides a more structured way to combine tables: explicit joins using keywords like JOIN ... ON.\nThe key difference is that implicit joins mix filtering (WHERE) with table relationships, making queries harder to read as they grow. Explicit joins, on the other hand, separate the logic of joining tables from filtering rows, improving readability and maintainability.\n\n\n\n\n\n\nNote\n\n\n\nExplicit JOIN\nSELECT ... FROM ... JOIN ... ON fk = pk;\nSELECT * FROM table1 JOIN table2 ON table1.id = table2.id;\n\n\nDifferent join syntaxes exist because SQL is designed to be flexible. In some cases, explicit joins provide better performance and clarity, especially when dealing with complex queries or different types of joins (we will see them later).\nThere many ways to JOIN tbles in SQL. All these methods are called Equijoin.\nCompare These queries:\n\nSELECT * FROM brand, lodgingchain WHERE brand.chainId = lodgingchain.chainId;\n\n\nSELECT * FROM brand JOIN lodgingchain ON brand.chainId = lodgingchain.chainId;\n\n\nSELECT * FROM brand NATURAL JOIN lodgingchain;\n\n\nSELECT * FROM brand JOIN lodgingchain USING(chainId);\n\n\n\nList the authors that have reviewed hotels. Report the author name, the hotel ID and the name of the hotels. Order the output by author name.\nUse all four methods\nimplicit JOIN (WHERE)\n\nSELECT authorNickname, hotel.hotelId, hotelName\n FROM author, review, hotel\n WHERE review.authorId = author.authorId\n AND review.hotelId = hotel.hotelId\n ORDER BY authorNickname;\n\nNATURAL JOIN\n\nSELECT authorNickname, hotelId, hotelName \n FROM author \n  NATURAL JOIN review \n  NATURAL JOIN hotel \n ORDER BY authorNickname;\n\nJOIN … USING\n\nSELECT authorNickname, hotelId, hotelName \n FROM author \n  JOIN review USING(authorId) \n  JOIN hotel USING(hotelId) \n ORDER BY authorNickname;\n \n\nJOIN … ON\n\nSELECT authorNickname, hotel.hotelId, hotelName\n FROM author JOIN review JOIN hotel\n  ON  hotel.hotelId = review.hotelId\n  AND review.authorId = author.authorId\nORDER BY authorNickname;\n\n\n\nNATURAL JOIN\n\nJoin on “same” column (name and data type)\nRisky: the condition is implicit\n\nUSING()\n\nExplicitly specifies columns in the equijoin\nAllows multiple (comma separated) columns\n\nON\n\nThe ON clause enables multiple conditions\nLogical operator can be used to combine condition\nON and USING are mutually exclusive\nON enables inequality joins (Theta JOIN – more later)\n\n\n\n\n\nSo far, you’ve learner about INNER JOIN, which is the JOIN that returns only the rows that have matching values in both tables based on a specified condition. It eliminates unmatched rows from both tables, ensuring that only records with a relationship between them appear in the result set.\nHowever, there are different JOINS too. An OUTER JOIN is a powerful SQL feature used when you want to retain “dangling tuples”—rows that don’t have a match in the other table. Unlike inner joins, which only return matching records, outer joins ensure that unmatched rows from one or both tables are included in the results. These missing values are padded with NULLs based on the type of outer join used.\n\nA LEFT OUTER JOIN returns all rows from the left table, along with matching rows from the right table. If there’s no match, NULLs are used for the right table’s columns.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSELECT * FROM t1 LEFT OUTER JOIN t2 USING (id);\n\n\n\n\nA RIGHT OUTER JOIN does the opposite—it keeps all rows from the right table and includes matching rows from the left table, filling in NULLs when no match is found.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSELECT * FROM t1 RIGHT OUTER JOIN t2 USING (id);\n\n\n\n\nA FULL OUTER JOIN includes all rows from both tables, ensuring that even non-matching rows from either table appear, with NULLs where data is missing.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSELECT * FROM t1 RIGHT OUTER JOIN t2 USING (id);\n\n\n\nOuter joins are especially useful for analyzing incomplete data, maintaining records even when relationships are not fully established, and ensuring that no important information is lost in queries.\n\n\n\nProvide a list of all chain names and their respective brands. Order the list by chain name.\nTip: Keep in mind that not all chains have sub-brands.\n\nSELECT chainName, brandName\n FROM lodgingchain LEFT OUTER JOIN brand USING(chainId)\n ORDER BY chainName;"
  },
  {
    "objectID": "3-many-to-many-complete.html#extra-practice-cell",
    "href": "3-many-to-many-complete.html#extra-practice-cell",
    "title": "Many-to-Many relationship",
    "section": "",
    "text": "That’s it for this lesson on SQL joins! Understanding how to combine data from multiple tables is a crucial skill for making informed business decisions. Whether you’re analyzing sales trends, tracking customer behavior, or managing inventory, SQL joins help you unlock valuable insights from your data. As you continue learning, you’ll discover even more ways to refine and optimize your queries. Keep practicing, and soon, you’ll be confidently using SQL to drive smarter business strategies! 🚀\n\n\n\n\n\n\n\n\n\nImages and GIFs Disclaimer: Some of the images and GIFs used on this website are not owned by me. They are used for educational and illustrative purposes only. All rights belong to their respective owners. If you believe any content violates copyright, please contact me for prompt removal.\n\n\n\n\n\n\n  \n  \n    © 2025. All Rights Reserved.\n  \n  \n\n  \n  \n    Enabled by Dr. Marcin Bartosiak"
  },
  {
    "objectID": "4-server-challenge.html",
    "href": "4-server-challenge.html",
    "title": "Server Connections - practice",
    "section": "",
    "text": "Write a Python program that connects to the database, retrieves hotel ratings and brand information, and analyzes the average rating for each brand.\n\n\n\n\nConnect to the database using Python (mysql.connector or SQLAlchemy).\nRetrieve the average hotelStarRating for each brand.\nDisplay the results in a sorted table (highest-rated brands first).\n\n\n\n\n\nThe hotel table contains the hotelStarRating and brandId.\nThe brand table contains brand details.\nUse GROUP BY and AVG() in SQL.\n\n\n\n\nA dictionary of brands with their average star rating, sorted by star rating.\n'Park Hyatt': 5.0,\n 'Mandarin Oriental': 5.0,\n 'Luxury Collection': 5.0,\n 'Four Seasons': 4.96154,\n 'Ritz-Carlton': 4.95833,\n 'Waldorf Astoria Hotels & Resorts': 4.83333,\n 'Taj': 4.66667,\n 'Conrad': 4.66667,\n 'Sofitel': 4.4,\n ...\n\n\n\nVisualize the data for the top 30 hotels using matplotlib (bar chart)."
  },
  {
    "objectID": "4-server-challenge.html#exercise-1-hotel-brand-performance-analysis",
    "href": "4-server-challenge.html#exercise-1-hotel-brand-performance-analysis",
    "title": "Server Connections - practice",
    "section": "",
    "text": "Write a Python program that connects to the database, retrieves hotel ratings and brand information, and analyzes the average rating for each brand.\n\n\n\n\nConnect to the database using Python (mysql.connector or SQLAlchemy).\nRetrieve the average hotelStarRating for each brand.\nDisplay the results in a sorted table (highest-rated brands first).\n\n\n\n\n\nThe hotel table contains the hotelStarRating and brandId.\nThe brand table contains brand details.\nUse GROUP BY and AVG() in SQL.\n\n\n\n\nA dictionary of brands with their average star rating, sorted by star rating.\n'Park Hyatt': 5.0,\n 'Mandarin Oriental': 5.0,\n 'Luxury Collection': 5.0,\n 'Four Seasons': 4.96154,\n 'Ritz-Carlton': 4.95833,\n 'Waldorf Astoria Hotels & Resorts': 4.83333,\n 'Taj': 4.66667,\n 'Conrad': 4.66667,\n 'Sofitel': 4.4,\n ...\n\n\n\nVisualize the data for the top 30 hotels using matplotlib (bar chart)."
  },
  {
    "objectID": "4-server-challenge.html#exercise-2-sentiment-analysis-on-hotel-reviews",
    "href": "4-server-challenge.html#exercise-2-sentiment-analysis-on-hotel-reviews",
    "title": "Server Connections - practice",
    "section": "Exercise 2: Sentiment Analysis on Hotel Reviews",
    "text": "Exercise 2: Sentiment Analysis on Hotel Reviews\n\nObjective:\nWrite a Python program that connects to a MySQL database, retrieves hotel reviews and their ratings, and classifies each review as Positive, Neutral, or Negative based on its rating.\n\n\nClassification Rules:\n\nNegative Review: Rating &lt; 3\nNeutral Review: Rating = 3\nPositive Review: Rating &gt; 3\n\n\n\nTasks:\n\nConnect to the MySQL database\n\n\nUse MySQL Connector (mysql.connector) to connect to the database.\nRetrieve reviews and ratings\nQuery the database to get the hotel name, review text, and rating.\n\n\nClassify reviews based on rating\n\n\nUse the classification rules to assign a sentiment category (Positive, Neutral, Negative).\nCount how many reviews fall into each category for each hotel.\n\n\nFind and display:\n\n\nThe top 5 hotels with the most positive reviews.\nThe top 5 hotels with the most negative reviews.\n\n\n\nExpected output\nTop 5 Hotels with Most Positive Reviews:\nThe New Yorker Hotel: 584 positive reviews\nDistrikt Hotel: 580 positive reviews\nStaybridge Suites Times Square - New York City: 558 positive reviews\nHilton Garden Inn Times Square: 556 positive reviews\nLe Parker Meridien: 552 positive reviews\n\nTop 5 Hotels with Most Negative Reviews:\nHotel Pennsylvania New York: 362 negative reviews\nHudson New York: 202 negative reviews\nMilford Plaza Hotel: 184 negative reviews\nHotel Carter: 147 negative reviews\nPark Central: 122 negative reviews\n\n\nChallenge\nUse matplotlib to create a pie chart or histogram."
  },
  {
    "objectID": "4-server-challenge.html#solution",
    "href": "4-server-challenge.html#solution",
    "title": "Server Connections - practice",
    "section": "Solution",
    "text": "Solution\nYou can find both exercises solved in Colab.\n\n\n\nImages and GIFs Disclaimer: Some of the images and GIFs used on this website are not owned by me. They are used for educational and illustrative purposes only. All rights belong to their respective owners. If you believe any content violates copyright, please contact me for prompt removal.\n\n\n\n\n\n\n  \n  \n    © 2025. All Rights Reserved.\n  \n  \n\n  \n  \n    Enabled by Dr. Marcin Bartosiak"
  },
  {
    "objectID": "5-one-to-one-and-recursive-complete.html",
    "href": "5-one-to-one-and-recursive-complete.html",
    "title": "One-to-One and Recursive relationship",
    "section": "",
    "text": "Warning\n\n\n\nRecursive relationship is a bit more complex and it won’t work on the website. To try queries in this section, we will use Workbench.\nYou can also run them in your Python program."
  },
  {
    "objectID": "5-one-to-one-and-recursive-complete.html#modelling-one-to-one-relationship",
    "href": "5-one-to-one-and-recursive-complete.html#modelling-one-to-one-relationship",
    "title": "One-to-One and Recursive relationship",
    "section": "Modelling one-to-one relationship",
    "text": "Modelling one-to-one relationship\nLet’s consider this organizational chart. We can clarely see that each (one) department has a (one) head.\n\n\n1:1 relationship is labeled\n\nA relationship descriptor\n\nObvious relationships are not labeled"
  },
  {
    "objectID": "5-one-to-one-and-recursive-complete.html#querying-one-to-one-relationship",
    "href": "5-one-to-one-and-recursive-complete.html#querying-one-to-one-relationship",
    "title": "One-to-One and Recursive relationship",
    "section": "Querying One-to-One Relationship",
    "text": "Querying One-to-One Relationship\nGOOD NEWS! Querying one-to-one relationship works EXACTLY like the queries you already know :D .\nWe will use these new tables:\n\nList the hotel name, first name and title of each hotel’s contact employee.\nSELECT hotelName, employeeFName, employeeTitle  \n FROM employee JOIN hotel USING(employeeId);\nFor reviews with a response, find the total number of reviews posted and their average response time in days for all reviews posted on Valentine’s day (2011-02-14). ((DATEDIFF(date2, date1) – calculates the difference between two dates)\nSELECT COUNT(reviewDate), AVG(DATEDIFF(responseDate, reviewDate))\n FROM review JOIN response USING(reviewId)\n WHERE reviewDate = '2011-02-14';"
  },
  {
    "objectID": "5-one-to-one-and-recursive-complete.html#modelling-recursive-relationship",
    "href": "5-one-to-one-and-recursive-complete.html#modelling-recursive-relationship",
    "title": "One-to-One and Recursive relationship",
    "section": "Modelling recursive relationship",
    "text": "Modelling recursive relationship\nLet’s go back to our organizational chart. There is more here…\n\n\nA recursive relationship relates an entity to itself\nLabel recursive relationships"
  },
  {
    "objectID": "5-one-to-one-and-recursive-complete.html#querying-recursive-relationship",
    "href": "5-one-to-one-and-recursive-complete.html#querying-recursive-relationship",
    "title": "One-to-One and Recursive relationship",
    "section": "Querying recursive relationship",
    "text": "Querying recursive relationship\nA recursive relationship in a database, also known as a self-join, is when a table is joined with itself to represent relationships within the same entity. This technique is often used to model hierarchical or parent-child relationships, such as employees managing other employees. To perform a self-join, table aliasing is required so that the same table can be referenced multiple times in a query. For instance, using the alias boss in:\nFROM employee AS boss\nallows the query to distinguish between the employee acting as the manager and the one being managed. This approach is essential for querying and understanding internal relationships within a single table.\nOpen your Workbench and find the name of Leo Lee’s boss.\nSELECT boss.employeeFName, boss.employeeLName \n FROM employee AS wrk JOIN employee AS boss   \n  ON wrk.reportsTo = boss.employeeId \n WHERE wrk.employeeLName = 'Lee'  \n AND wrk.employeeFName='Leo';"
  },
  {
    "objectID": "5-one-to-one-and-recursive-complete.html#between",
    "href": "5-one-to-one-and-recursive-complete.html#between",
    "title": "One-to-One and Recursive relationship",
    "section": "BETWEEN",
    "text": "BETWEEN\nBETWEEN is used to filter query results within a specific range. It works with numbers, dates, and text.\nFor example:\n\nReport all reviews between two dates\nReport all review and responses that occurred within one day of the review being posted"
  },
  {
    "objectID": "5-one-to-one-and-recursive-complete.html#limit",
    "href": "5-one-to-one-and-recursive-complete.html#limit",
    "title": "One-to-One and Recursive relationship",
    "section": "LIMIT",
    "text": "LIMIT\nLIMIT restricts the number of rows returned by a query.\nFor example:\n\nFor all the hotels that received at least 50 review. Report the first ten hotels ranked by overall rating."
  },
  {
    "objectID": "5-one-to-one-and-recursive-complete.html#limit-and-offset",
    "href": "5-one-to-one-and-recursive-complete.html#limit-and-offset",
    "title": "One-to-One and Recursive relationship",
    "section": "LIMIT and OFFSET",
    "text": "LIMIT and OFFSET\nOFFSET skips a specified number of rows before starting to return rows.\nFor example:\n\nReport the 10th hotel in the ranking above (not the first ten)"
  },
  {
    "objectID": "5-one-to-one-and-recursive-complete.html#examples",
    "href": "5-one-to-one-and-recursive-complete.html#examples",
    "title": "One-to-One and Recursive relationship",
    "section": "Examples",
    "text": "Examples\nReport all review that occurred from 4.08.2011 to 24.08.2011. Order by review date\n\nSELECT * FROM review\nWHERE reviewDate BETWEEN '2011-08-04' AND '2011-08-24' \nORDER BY reviewDate DESC;\n\nReport all review that occurred from 4.08.2011 to 24.08.2011. Order by review date Show only 10 first rows.\n\nSELECT * FROM review \nWHERE reviewDate BETWEEN '2011-08-04' AND '2011-08-24' \nORDER BY reviewDate DESC \nLIMIT 10;\n\nReport all review that occurred from 4.08.2011 to 24.08.2011. Order by review date. Show only 10 rows. Make sure your results start from the 9th row.\n\nSELECT * FROM review \nWHERE reviewDate BETWEEN '2011-08-04' AND '2011-08-24' \nORDER BY reviewDate DESC \nLIMIT 10 OFFSET 8;\n\n\n\n\nImages and GIFs Disclaimer: Some of the images and GIFs used on this website are not owned by me. They are used for educational and illustrative purposes only. All rights belong to their respective owners. If you believe any content violates copyright, please contact me for prompt removal.\n\n\n\n\n\n\n  \n  \n    © 2025. All Rights Reserved.\n  \n  \n\n  \n  \n    Enabled by Dr. Marcin Bartosiak"
  },
  {
    "objectID": "6-many-to-many-recursive-complete.html",
    "href": "6-many-to-many-recursive-complete.html",
    "title": "One-to-One and Recursive relationship",
    "section": "",
    "text": "Warning\n\n\n\nTo try queries in this section, we will use Workbench.\nYou can also run them in your Python program."
  },
  {
    "objectID": "6-many-to-many-recursive-complete.html#many-to-many-recursive-relationship",
    "href": "6-many-to-many-recursive-complete.html#many-to-many-recursive-relationship",
    "title": "One-to-One and Recursive relationship",
    "section": "Many-to-Many Recursive Relationship",
    "text": "Many-to-Many Recursive Relationship\nA many-to-many recursive relationship occurs when an entity in a table has a relationship with itself. In this type of relationship, each record in the table can be associated with multiple records of the same table. This recursive structure is common when modeling hierarchical data or relationships where entities are interlinked in a complex, self-referential way.\nFor example, consider a company with employees, where each employee can have multiple managers, and each manager can also manage multiple employees. In this case, the relationship is between the same entity (employees), but each record can be connected to many other records of the same type.\nIn a relational database, this is typically represented by a table with a foreign key that references the primary key of the same table. This creates the recursive relationship, where one row can link to another row within the same table.\nA common example of this is a Bill of Materials (BOM) in manufacturing. In a BOM, an item can be made up of multiple components, and those components can also be composed of other sub-components. This creates a recursive relationship where each part (or component) is related to other parts within the same table.\n\n\n\n\n\n\n\n\n\nBy Thorsten Hartmann - Own work, CC BY-SA 3.0, https://commons.wikimedia.org/w/index.php?curid=735359\n\n\n\n\n\n\n\n\nThis allows us to model complex structures, such as corporate hierarchies, family trees, or organizational charts."
  },
  {
    "objectID": "6-many-to-many-recursive-complete.html#subordinate-entity",
    "href": "6-many-to-many-recursive-complete.html#subordinate-entity",
    "title": "One-to-One and Recursive relationship",
    "section": "Subordinate entity",
    "text": "Subordinate entity\nA subordinate entity refers to an entity in a database that depends on another entity (the primary entity) for its existence. The subordinate entity typically cannot exist without the primary entity and is linked by a one-to-one identifying relationship.\nFor example, imagine an animal entity that contains information about various animals like sheep and horses. The sheep and horse entities could both be considered subordinate to the animal entity, as they depend on it to define their shared characteristics (like species, ID, etc.).\n\nExample:\n\nA sheep entity might include attributes like fleeceweight (because a sheep is famous for its wool) to indicate how much wool it produces.\nA horse entity might include furlongspeed (the speed at which a horse can gallop a furlong — approximately 1/8th of a mile).\n\nNow, we typically do not collect fleece from horses. We are, most often, not interested in sheep’s speed (with some notable exceptions that are way baaayond the topic of this session…).\n\nIf we wanted to keep all these attributes in one table, we would have to deal with many NULL values.\n\nIn this case, the sheep and horse entities depend on the animal entity for classification and characteristics, but they also contain unique attributes like fleeceweight and furlongspeed to describe specific details about each species.\n\nBy modeling animals as subordinate entities, we ensure that every sheep and horse record has proper context and detailed attributes while keeping them organized under the broader animal category."
  },
  {
    "objectID": "6-many-to-many-recursive-complete.html#regexp",
    "href": "6-many-to-many-recursive-complete.html#regexp",
    "title": "One-to-One and Recursive relationship",
    "section": "REGEXP",
    "text": "REGEXP\nIn SQL, REGEXP (short for regular expression) is used to match a string against a pattern. It allows you to search for complex patterns in text data. It is often used to perform advanced searches, such as matching substrings, validating formats, or finding specific patterns in a column.\nIn your syntax, you write REGEXP in the WHERE clause instead of =.\n\nExample:\nSELECT name\nFROM employees\nWHERE name REGEXP '^A';  -- Finds names starting with the letter 'A'\nCommon Regular Expression Syntax:\n^ : Matches the start of a string.\n\n$ : Matches the end of a string.\n\n. : Matches any single character.\n\n* : Matches 0 or more occurrences of the preceding element.\n\n+ : Matches 1 or more occurrences of the preceding element.\n\n[] : Matches any character within the brackets.\n\nExamples\nList all brands containing ‘Hotel’ in their name.\nSELECT brandName FROM brand\n        WHERE brandName REGEXP 'hotel';\nReport chains with ‘resort’ or ‘resorts’ in the chain name\nSELECT chainName FROM lodgingchain\n        WHERE chainName REGEXP 'resort';"
  },
  {
    "objectID": "6-many-to-many-recursive-complete.html#set-operations---union-and-union-all",
    "href": "6-many-to-many-recursive-complete.html#set-operations---union-and-union-all",
    "title": "One-to-One and Recursive relationship",
    "section": "Set operations - UNION and UNION ALL",
    "text": "Set operations - UNION and UNION ALL\nSet operations in SQL are used to combine the results of two or more SELECT queries into a single result set. These operations allow you to perform tasks like merging data, comparing results, or finding common elements between queries.\n\nUNION\nThe UNION operator combines the results of two or more SELECT queries into one result set, eliminating duplicates. It ensures that each row in the result set is unique, even if the same data appears in both queries.\nSELECT column1, column2, ...\nFROM table1\nUNION\nSELECT column1, column2, ...\nFROM table2;\n\nExample\nList all the hotel name, city and star rating of hotels in Dallas or hotels that have ‘Palace’ in their name.\nSELECT hotelName, hotelState, hotelStarRating\n FROM hotel\n WHERE hotelCity = 'Dallas'\nUNION\nSELECT hotelName, hotelState, hotelStarRating\n FROM hotel\n WHERE hotelName REGEXP 'Palace';\nYou can do the same with OR. UNION very often will return similar results.\nSELECT DISTINCT hotelName, hotelStarRating, hotelCity\n FROM hotel\n WHERE hotelCity = 'Dallas'\n OR hotelName REGEXP 'Palace';\n\n\n\nUNION ALL\nUNION ALL is similar to UNION, but it does not eliminate duplicates. It will combine the results of both queries, including duplicates.\nSELECT column1, column2, ...\nFROM table1\nUNION ALL\nSELECT column1, column2, ...\nFROM table2;\n\nExample\nFor all reviews of the hotel Id = 73242 merge room and cleanliness ratings. Rename the field as ‘Merged Reviews’.\nSELECT reviewCleanliness AS 'Merged Reviews'\n FROM review\n WHERE hotelId = 73242\nUNION ALL\nSELECT reviewRooms \n FROM review\n WHERE hotelId = 73242;\n\n\nChallenge\nCount the number of brands each lodging chain owns. Rename the count as Total Brands. DO NOT USE OUTER JOIN\nThis is how you could try to write this query with OUTER JOIN\nSELECT chainName, COUNT(brandId) AS `Total Brands`\n FROM lodgingchain LEFT JOIN brand USING(chainId)\n GROUP BY chainName\n ORDER BY COUNT(brandId);\nThis is the solution withou OUTER JOIN\nSELECT chainName, COUNT(*) AS `Total Brands`\n FROM lodgingchain JOIN brand USING(chainId)\n GROUP BY chainName\nUNION\nSELECT chainName, 0\n FROM lodgingchain\n WHERE chainId NOT IN (SELECT chainId FROM brand)\n\n\n\nImages and GIFs Disclaimer: Some of the images and GIFs used on this website are not owned by me. They are used for educational and illustrative purposes only. All rights belong to their respective owners. If you believe any content violates copyright, please contact me for prompt removal.\n\n\n\n\n\n\n  \n  \n    © 2025. All Rights Reserved.\n  \n  \n\n  \n  \n    Enabled by Dr. Marcin Bartosiak"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "cdlibrary.html",
    "href": "cdlibrary.html",
    "title": "CD Library",
    "section": "",
    "text": "CD Library Challenge\n\n\n\n\n\n\nWelcome to the CD Library Database Challenge! In this exercise, you’ll put your SQL skills to work by querying a database that manages a collection of music CDs. As future business analysts and decision-makers, you’ll need to extract meaningful insights from company databases. This challenge simulates a real-world scenario where you’ll help a music store manager understand their inventory and track popular artists. Your task is to craft SQL queries that answer specific business questions and provide actionable intelligence.\n\n\n\n\n\n\nThis is the database model. It is a bit messy, but you will have to deal with it. \n\nWhat are the titles of the recordings on which Asleep at the Wheel appear?\n\n\n\nList all CDs that have any tracks featuring Asleep at the Wheel.\n\n\n\nWho are the members of Manhattan Transfer?\n\n\n\nWhat CDs feature Manhattan Transfer?\n\n\n\nFor what songs has John Hendricks written the lyrics?\n\n\n\nReport all compositions and their composers where more than one person was involved in composing the music.\n\n\n\nList all CDs featuring more than one group.\n\n\n\nList the composers appearing on each CD.\n\n\n\n\n\n\n\n  \n  \n    © 2025. All Rights Reserved.\n  \n  \n\n  \n  \n    Enabled by Dr. Marcin Bartosiak"
  },
  {
    "objectID": "Homework1.html",
    "href": "Homework1.html",
    "title": "Homework 1",
    "section": "",
    "text": "The following queries use the classicmodels schema. All queries use the products table.\n\n\n\n\n\n\n\nPrepare a list of products sorted by product name in descending order.\n\n\n\nList the product names and their quantity available from high to low?\n\n\n\nReport the MSRP for the products in “Vintage Cars” category?\n\n\n\nReport the product(s) with the buy price of 48.81.\n\n\n\nReport those products with the price greater than 70.\n\n\n\nWhich products have product scale ratio 1:10 and 1:72?\n\n\n\nList the product names except the ones in the Planes and Ships category.\n\n\n\nReport the names of products excluding Motorcycles and Classic Cars.\n\n\n\nReport the products having MSRP greater than 110.\n\n\n\nList the product vendors in ascending alphabetical order.\n\n\n\n\n\n\n\n  \n  \n    © 2025. All Rights Reserved.\n  \n  \n\n  \n  \n    Enabled by Dr. Marcin Bartosiak"
  },
  {
    "objectID": "Homework1.html#sql---homework-1",
    "href": "Homework1.html#sql---homework-1",
    "title": "Homework 1",
    "section": "",
    "text": "The following queries use the classicmodels schema. All queries use the products table.\n\n\n\n\n\n\n\nPrepare a list of products sorted by product name in descending order.\n\n\n\nList the product names and their quantity available from high to low?\n\n\n\nReport the MSRP for the products in “Vintage Cars” category?\n\n\n\nReport the product(s) with the buy price of 48.81.\n\n\n\nReport those products with the price greater than 70.\n\n\n\nWhich products have product scale ratio 1:10 and 1:72?\n\n\n\nList the product names except the ones in the Planes and Ships category.\n\n\n\nReport the names of products excluding Motorcycles and Classic Cars.\n\n\n\nReport the products having MSRP greater than 110.\n\n\n\nList the product vendors in ascending alphabetical order.\n\n\n\n\n\n\n\n  \n  \n    © 2025. All Rights Reserved.\n  \n  \n\n  \n  \n    Enabled by Dr. Marcin Bartosiak"
  },
  {
    "objectID": "Homework2.html",
    "href": "Homework2.html",
    "title": "Homework2",
    "section": "",
    "text": "The following queries use the classicmodels schema.\n\n\n\nSource: https://www.richardtwatson.com/\n\n\n\nHow many unique products are in the table products?\n\n\n\n\n\nWhat is the total number of products and the total quantity of all products?\n\n\n  \n\n\nWhat are the minimum and maximum prices of products?\n\n\n    \n\n\nProvide the number of products by product line (hint: use group by)\n\n\n    \n\n\nReport the sales representative for each customer.\n\n\n    \n\n\nReport the total payments by date.\n\n\n    \n\n\nReport the products that have not been sold.\n\n\n    \n\n\nList the amount paid by each customer.\n\n\n    \n\n\nHow many orders have been placed by Herkku Gifts?\n\n\n    \n\n\nWho are the employees in Boston?\n\n\n    \n\n\nReport those payments greater than $100,000. Group the report by customer name. Sort the report so the customer who made the highest payment appears first.\n\n\n    \n\n\n\n\n  \n  \n    © 2025. All Rights Reserved.\n  \n  \n\n  \n  \n    Enabled by Dr. Marcin Bartosiak"
  },
  {
    "objectID": "Homework2.html#sql---homework-2",
    "href": "Homework2.html#sql---homework-2",
    "title": "Homework2",
    "section": "",
    "text": "The following queries use the classicmodels schema.\n\n\n\nSource: https://www.richardtwatson.com/\n\n\n\nHow many unique products are in the table products?\n\n\n\n\n\nWhat is the total number of products and the total quantity of all products?\n\n\n  \n\n\nWhat are the minimum and maximum prices of products?\n\n\n    \n\n\nProvide the number of products by product line (hint: use group by)\n\n\n    \n\n\nReport the sales representative for each customer.\n\n\n    \n\n\nReport the total payments by date.\n\n\n    \n\n\nReport the products that have not been sold.\n\n\n    \n\n\nList the amount paid by each customer.\n\n\n    \n\n\nHow many orders have been placed by Herkku Gifts?\n\n\n    \n\n\nWho are the employees in Boston?\n\n\n    \n\n\nReport those payments greater than $100,000. Group the report by customer name. Sort the report so the customer who made the highest payment appears first.\n\n\n    \n\n\n\n\n  \n  \n    © 2025. All Rights Reserved.\n  \n  \n\n  \n  \n    Enabled by Dr. Marcin Bartosiak"
  },
  {
    "objectID": "Homework3.html",
    "href": "Homework3.html",
    "title": "Homework3",
    "section": "",
    "text": "The following queries use the classicmodels schema.\n\n\n\nSource: https://www.richardtwatson.com/\n\n\n\nReport product number, product name of products sold by order date. Order results by date (descending) and product code (ascending). Use both the USING and ON syntax for the join. Observe their different behavior.\n\n\n\nList all the order number and status for all the orders containing the 1940 Ford Pickup Truck.\n\n\n\nList the names of customers and the corresponding order numbers for those orders from that customer that have a total value greater than $25,000? Total value is obtained by adding the price times quantity sold of all products in the order.\n\n\n\nAre there any products that appear on all orders? If so, list their product code and the total number of orders they appear in. Rename the columns as ‘Total Orders’.\n\n\n\nReport those orders containing products sold at a discount (i.e., sold at a price less than the product’s MSRP). For these orders report the order number, the product code of the items sold at discount and both the price and the MSRP.\n\n\n\nRepeat the above query but only return the order number for the orders containing products sold at a discount.\n\n\n\nReport those products that have been sold with a markup of 100% or more (i.e., the priceEach is at least twice the buyPrice) on at least one sale. Provide the product code, the price at which it sold, the buy price and the MSRP. Be sure not to duplicate output unnecessarily.\n\n\n\nWhat is the total quantity on hand for products listed in orders with staus: ‘On Hold’? Rename the quantity ordered as ‘Total Ordered’ and the quantity in stock as ‘Total on Hand’. Use the ON syntax for the JOIN.\n\n\n\nReport product code, name and MSRP for all products that have not sold any units.\n\n\n\n\n\n\n\n  \n  \n    © 2025. All Rights Reserved.\n  \n  \n\n  \n  \n    Enabled by Dr. Marcin Bartosiak"
  },
  {
    "objectID": "Homework3.html#sql---homework-3",
    "href": "Homework3.html#sql---homework-3",
    "title": "Homework3",
    "section": "",
    "text": "The following queries use the classicmodels schema.\n\n\n\nSource: https://www.richardtwatson.com/\n\n\n\nReport product number, product name of products sold by order date. Order results by date (descending) and product code (ascending). Use both the USING and ON syntax for the join. Observe their different behavior.\n\n\n\nList all the order number and status for all the orders containing the 1940 Ford Pickup Truck.\n\n\n\nList the names of customers and the corresponding order numbers for those orders from that customer that have a total value greater than $25,000? Total value is obtained by adding the price times quantity sold of all products in the order.\n\n\n\nAre there any products that appear on all orders? If so, list their product code and the total number of orders they appear in. Rename the columns as ‘Total Orders’.\n\n\n\nReport those orders containing products sold at a discount (i.e., sold at a price less than the product’s MSRP). For these orders report the order number, the product code of the items sold at discount and both the price and the MSRP.\n\n\n\nRepeat the above query but only return the order number for the orders containing products sold at a discount.\n\n\n\nReport those products that have been sold with a markup of 100% or more (i.e., the priceEach is at least twice the buyPrice) on at least one sale. Provide the product code, the price at which it sold, the buy price and the MSRP. Be sure not to duplicate output unnecessarily.\n\n\n\nWhat is the total quantity on hand for products listed in orders with staus: ‘On Hold’? Rename the quantity ordered as ‘Total Ordered’ and the quantity in stock as ‘Total on Hand’. Use the ON syntax for the JOIN.\n\n\n\nReport product code, name and MSRP for all products that have not sold any units.\n\n\n\n\n\n\n\n  \n  \n    © 2025. All Rights Reserved.\n  \n  \n\n  \n  \n    Enabled by Dr. Marcin Bartosiak"
  },
  {
    "objectID": "Homework4.html",
    "href": "Homework4.html",
    "title": "Homework4",
    "section": "",
    "text": "Warning\n\n\n\nYou have to run these queries in Workbench (or Python program).\n\n\nThe following queries use the classicmodels schema.\n\n\n\nSource: https://www.richardtwatson.com/\n\n\n\nWho is at the top of organization?\nWho reports to directly to William Patterson?\nList the employees who report to those employees who report to Diane Murphy.\nHow many employees report to the Sales Manager that is employee named ‘Bow Anthony’? Rename the column as “Mr. Bow’s Direct Reports”\nFind the pair of customer that have the same credit limit. Omit the customers having no credit limit (That is creditlimit = 0): Report the customer name and credit limit for each pair and be sure to avoid unnecessary duplication.\n\n\n\n\n  \n  \n    © 2025. All Rights Reserved.\n  \n  \n\n  \n  \n    Enabled by Dr. Marcin Bartosiak"
  },
  {
    "objectID": "Homework4.html#sql---homework-4",
    "href": "Homework4.html#sql---homework-4",
    "title": "Homework4",
    "section": "",
    "text": "Warning\n\n\n\nYou have to run these queries in Workbench (or Python program).\n\n\nThe following queries use the classicmodels schema.\n\n\n\nSource: https://www.richardtwatson.com/\n\n\n\nWho is at the top of organization?\nWho reports to directly to William Patterson?\nList the employees who report to those employees who report to Diane Murphy.\nHow many employees report to the Sales Manager that is employee named ‘Bow Anthony’? Rename the column as “Mr. Bow’s Direct Reports”\nFind the pair of customer that have the same credit limit. Omit the customers having no credit limit (That is creditlimit = 0): Report the customer name and credit limit for each pair and be sure to avoid unnecessary duplication.\n\n\n\n\n  \n  \n    © 2025. All Rights Reserved.\n  \n  \n\n  \n  \n    Enabled by Dr. Marcin Bartosiak"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "MIBE SQL Corner",
    "section": "",
    "text": "Welcome to the MIBE SQL Corner! This page is dedicated to all the key concepts, notes, and resources you need for mastering SQL in the Coding and Data Management course. Whether you’re just starting or refining your skills, you’ll find everything you need to excel in SQL here. Let’s dive in and sharpen those coding skills!\nYou will also use this website to query databases. It features interactive fields, where you can type and edit your SQL queries.\n\n\n\n\n\n\n\n  \n  \n    © 2025. All Rights Reserved.\n  \n  \n\n  \n  \n    Enabled by Dr. Marcin Bartosiak"
  },
  {
    "objectID": "Notes.html",
    "href": "Notes.html",
    "title": "Notes",
    "section": "",
    "text": "In SQL, REGEXP (short for regular expression) is used to match a string against a pattern. It allows you to search for complex patterns in text data. It is often used to perform advanced searches, such as matching substrings, validating formats, or finding specific patterns in a column.\nFor example, the query below lists all brands containing ‘Hotel’ in their name. We don’t know the exact names. Just that small piece.\nSELECT brandName FROM brand\n        WHERE brandName REGEXP 'hotel';\n\n\n\n\n\n\nNote\n\n\n\nPay attention how the syntax for REGEXP uses the WHERE clause (which is, again, great!🤩 because you already know how to use WHERE).\n\n\nCommon Regular Expression Syntax:\n\n^ : Matches the start of a string.\n$ : Matches the end of a string.\n. : Matches any single character.\n* : Matches 0 or more occurrences of the preceding element.\n+ : Matches 1 or more occurrences of the preceding element.\n[] : Matches any character within the brackets.\n[A-Z] : Matches any upper case letter.\n[a-z] : Matches any lower case letter\n[0-9] : Matches any digit from 0 through to 9.\n\nExamples\nSELECT brandName FROM brand\n        WHERE brandName REGEXP '^H';\nSELECT brandName FROM brand\n        WHERE brandName REGEXP '$or';\nSELECT headquarters FROM lodgingchain\n        WHERE headquarters REGEXP '[united]';\nSELECT headquarters FROM lodgingchain\n        WHERE headquarters REGEXP '[United]';\nSELECT headquarters FROM lodgingchain\n        WHERE headquarters REGEXP '+or';"
  },
  {
    "objectID": "Notes.html#regular-expressions",
    "href": "Notes.html#regular-expressions",
    "title": "Notes",
    "section": "",
    "text": "In SQL, REGEXP (short for regular expression) is used to match a string against a pattern. It allows you to search for complex patterns in text data. It is often used to perform advanced searches, such as matching substrings, validating formats, or finding specific patterns in a column.\nFor example, the query below lists all brands containing ‘Hotel’ in their name. We don’t know the exact names. Just that small piece.\nSELECT brandName FROM brand\n        WHERE brandName REGEXP 'hotel';\n\n\n\n\n\n\nNote\n\n\n\nPay attention how the syntax for REGEXP uses the WHERE clause (which is, again, great!🤩 because you already know how to use WHERE).\n\n\nCommon Regular Expression Syntax:\n\n^ : Matches the start of a string.\n$ : Matches the end of a string.\n. : Matches any single character.\n* : Matches 0 or more occurrences of the preceding element.\n+ : Matches 1 or more occurrences of the preceding element.\n[] : Matches any character within the brackets.\n[A-Z] : Matches any upper case letter.\n[a-z] : Matches any lower case letter\n[0-9] : Matches any digit from 0 through to 9.\n\nExamples\nSELECT brandName FROM brand\n        WHERE brandName REGEXP '^H';\nSELECT brandName FROM brand\n        WHERE brandName REGEXP '$or';\nSELECT headquarters FROM lodgingchain\n        WHERE headquarters REGEXP '[united]';\nSELECT headquarters FROM lodgingchain\n        WHERE headquarters REGEXP '[United]';\nSELECT headquarters FROM lodgingchain\n        WHERE headquarters REGEXP '+or';"
  }
]